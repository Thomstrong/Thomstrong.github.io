<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Thomstrong&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://thomstrong.github.io/"/>
  <updated>2019-07-11T03:39:24.877Z</updated>
  <id>https://thomstrong.github.io/</id>
  
  <author>
    <name>Thomstrong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>排序算法</title>
    <link href="https://thomstrong.github.io/2019/07/10/sort-algorithm/"/>
    <id>https://thomstrong.github.io/2019/07/10/sort-algorithm/</id>
    <published>2019-07-09T16:18:50.000Z</published>
    <updated>2019-07-11T03:39:24.877Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><blockquote><p>参考<a href="https://blog.csdn.net/justloveyou_/article/details/72730597" target="_blank" rel="noopener">博文 </a>/ 图片来自<a href="https://mp.weixin.qq.com/s/Qf416rfT4pwURpW3aDHuCg" target="_blank" rel="noopener">微信推送文章</a></p></blockquote><h3 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h3><ul><li>稳定性：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的<strong>相对次序保持不变</strong>，即在原序列中，<code>r[i] == r[j]</code>，且<code>r[i]</code>在<code>r[j]</code>之前，而在排序后的序列中，<code>r[i]</code>仍在<code>r[j]</code>之前，则称这种排序算法是稳定的；否则称为不稳定的</li><li>时间复杂度：排序过程中对单个数据的访问总次数</li><li>空间复杂度：排序过程中需要辅助的存储空间</li><li>内部排序/外部排序：排序过程中数据元素是否完全在内存</li></ul><h3 id="结论最前"><a href="#结论最前" class="headerlink" title="结论最前"></a>结论最前</h3><p><img src="/images/sort_summary.png" alt="排序算法总结"></p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><ul><li><p>算法：将第i个元素插入到前i-1个元素中适当的位置(选择插入位置时，因为前面元素已经有序，可以使用折半查找的方法)</p><blockquote><p>可以考虑扑克牌的排序，抽取后面的牌插入到前面有序的牌中</p></blockquote></li><li><p>性能分析：时间O(n^2^)，空间O(1)，稳定</p></li><li><p>图解</p><p><img src="/images/insert_sort.gif" alt="直接插入排序"></p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">    j = i - <span class="number">1</span></span><br><span class="line">    chosen_num = nums[i]</span><br><span class="line">    <span class="keyword">while</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">      <span class="keyword">if</span> nums[j] &gt; chosen_num:</span><br><span class="line">        nums[j + <span class="number">1</span>] = nums[j]</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      j -= <span class="number">1</span></span><br><span class="line">  nums[j + <span class="number">1</span>] = chosen_num</span><br></pre></td></tr></table></figure></li></ul><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><ul><li><p>算法</p><ul><li>首先设定以<code>gap</code>为距离对序列进行分组，对每个分组进行插入排序</li><li>缩小<code>gap</code>（一般缩小为上次的1/2～1/3附近）重新排序，循环，直到<code>gap</code>缩小为1</li><li><code>gap</code>为1的时候即为一次直接插入排序遍历</li></ul></li><li><p>性能分析：时间O(n^1.3~2^)，空间O(1)，不稳定</p></li><li><p>图解</p><p><img src="/images/shell_sort.gif" alt="希尔排序"></p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def shell_sort(nums) &#123;</span><br><span class="line">length = len(nums)</span><br><span class="line">    //区间</span><br><span class="line">  gap = <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> gap &lt; length:</span><br><span class="line">  gap = gap * <span class="number">3</span> + <span class="number">1</span> <span class="comment"># 确保gap最终能够是1</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(gap, length):</span><br><span class="line">    chosen_num = nums[i]</span><br><span class="line">    j = i - gap</span><br><span class="line">    //跨区间排序</span><br><span class="line">    <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> arr[j] &gt; tmp:</span><br><span class="line">  nums[j + gap] = nums[j]</span><br><span class="line">      j -= gap</span><br><span class="line">    nums[j + gap] = chosen_num</span><br><span class="line">  gap = gap / <span class="number">3</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h4><ul><li><p>算法：每次从待排序列中选择最小元素与待排序列首个元素交换后剔除首个元素，直到待排序列为空</p></li><li><p>性能分析：时间O(n^2^)，空间O(1)，不稳定</p></li><li><p>图解</p><p><img src="/images/select_sort.gif" alt="直接选择排序"></p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">    min_index = i</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(nums)):</span><br><span class="line">      <span class="keyword">if</span> nums[j] &lt; nums[min_index]:</span><br><span class="line">        min_index = j</span><br><span class="line">    nums[i], nums[min_index] = nums[min_index], nums[i]</span><br></pre></td></tr></table></figure></li></ul><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><blockquote><p>堆：这里的堆指的是由完全二叉树实现的二叉堆</p></blockquote><ul><li><p>算法：首先将所给元素排成大顶堆，然后每次取根节点，然后进行删除调整大顶堆，由此得到顺序序列</p></li><li><p>性能分析：时间O(nlogn)，空间O(1)，不稳定</p></li><li><p>图解</p><p><img src="/images/heap_sort.gif" alt="堆排序"></p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># todo 一时todo一时爽，一直todo一直爽</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><ul><li><p>算法：通过从后往前的交换，将较小元素交换到待排序列最前端，每次“冒泡”可确定一个最小元素的位置</p></li><li><p>性能分析：时间O(n^2^)，空间O(1)，稳定</p></li><li><p>图解</p><p><img src="/images/bubble_sort.gif" alt="冒泡排序"></p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">  n = len(nums)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    j = n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j &gt; i:</span><br><span class="line">      <span class="keyword">if</span> nums[j] &lt; nums[j - <span class="number">1</span>]:</span><br><span class="line">        nums[j], nums[j - <span class="number">1</span>] = nums[j - <span class="number">1</span>], nums[j]</span><br><span class="line">      j -= <span class="number">1</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><ul><li><p>算法</p><ul><li>核心思想为分治法，从序列中选出一个基准值，其他依次和基准做比较，比基准大的放右边，小的放左边</li><li>然后分别对左右两边再次使用快速排序</li><li>单边扫描<ul><li>我们随意抽取一个数作为基准值，同时设定一个标记 mark 代表左边序列最右侧的下标位置，当然初始为 0 </li><li>接下来遍历数组，如果元素大于基准值，无操作，继续遍历，如果元素小于基准值，则把 mark + 1 ，再将 mark 所在位置的元素和遍历到的元素交换位置</li><li>mark 这个位置存储的是比基准值小的数据的最后一个，当遍历结束后，将基准值与 mark 所在元素交换位置即可</li></ul></li></ul></li><li><p>性能分析：时间O(nlogn)，空间O(logn)，不稳定</p></li><li><p>图解</p><p><img src="/images/quick_sort.gif" alt="快速排序"></p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    sort(nums, <span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort</span><span class="params">(nums，startIndex，endIndex)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> endIndex &lt;= startIndex:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    pivotIndex = partition(nums, startIndex, endIndex)</span><br><span class="line">    sort(nums, startIndex, pivotIndex<span class="number">-1</span>)</span><br><span class="line">    sort(nums, pivotIndex + <span class="number">1</span>, endIndex)</span><br><span class="line"></span><br><span class="line">def partition(nums, int startIndex, int endIndex) &#123;</span><br><span class="line">    pivot = nums[startIndex] <span class="comment">#取基准值</span></span><br><span class="line">    mark = startIndex <span class="comment"># Mark初始化为起始下标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(startIndex + <span class="number">1</span>, endIndex + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt; pivot:</span><br><span class="line">            <span class="comment"># 小于基准值 则mark+1，并交换位置。</span></span><br><span class="line">            mark += <span class="number">1</span></span><br><span class="line">            nums[mark], nums[i] = nums[i], nums[mark]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 基准值与mark对应元素调换位置</span></span><br><span class="line">    arr[startIndex] = arr[mark]</span><br><span class="line">    arr[mark] = pivot</span><br><span class="line">    <span class="keyword">return</span> mark</span><br></pre></td></tr></table></figure></li></ul><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><ul><li><p>算法：将待排序列分为两部分，对左右两部分分别进行归并排序，然后将两个有序序列合并为一个有序序列</p></li><li><p>性能分析：时间O(nlogn)，空间O(n)，稳定</p></li><li><p>图解</p><p><img src="/images/merge_sort.gif" alt="归并排序"></p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># todo</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="分类排序"><a href="#分类排序" class="headerlink" title="分类排序"></a>分类排序</h3><h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><ul><li><p>算法：对于待排序列首先选择其最大和最小值，创建一个计数区，计算在最大和最小值之间所有数字出现的次数，最后以计数桶顺序还原有序序列</p></li><li><p>性能分析：时间O(n)，空间O(max-min)，不稳定</p></li><li><p>图解</p><p><img src="/images/count_sort.gif" alt="计数排序"></p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># todo</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><ul><li><p>算法</p><ul><li>将要排的数据分到多个有序的桶里</li><li>每个桶里的数据再单独排序，再把每个桶的数据依次取出，即可完成排序</li></ul></li><li><p>性能分析：时间根据桶的粒度会有不同变化，空间：桶的数目</p></li><li><p>图解</p><p><img src="/images/bucket_sort.gif" alt="桶排序"></p></li></ul><h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><ul><li><p>算法</p><ul><li>按照位数，分别对每位进行比较，放入对应的桶内，然后将桶内元素以先进先出的方式按桶序取出</li><li>如此经过d次（d为最大位数）排序后即可得到顺序</li><li>本算法需要待排序列有基数，并且基数可排序</li></ul></li><li><p>性能分析：时间：O(d*n)，空间O(d*n)，稳定</p></li><li><p>图解</p><p><img src="/images/base_sort.gif" alt="基数排序"></p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># todo</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;blockquote&gt;
&lt;p&gt;参考&lt;a href=&quot;https://blog.csdn.net/justloveyou_/article/details/72730597&quot; ta
      
    
    </summary>
    
    
      <category term="技术" scheme="https://thomstrong.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>操作系统知识点</title>
    <link href="https://thomstrong.github.io/2019/07/07/Operation-System/"/>
    <id>https://thomstrong.github.io/2019/07/07/Operation-System/</id>
    <published>2019-07-07T08:02:41.000Z</published>
    <updated>2019-07-10T06:53:42.502Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><blockquote><p>参考<a href="https://blog.csdn.net/justloveyou_/article/details/78304294" target="_blank" rel="noopener">博客</a></p></blockquote><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><ul><li>进程是对运行时程序的封装，是系统进行资源调度和分配的基本单位，实现操作系统并发</li><li><p>线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性（对并发的用户操作做出实时响应），实现进程内部并发</p></li><li><p>一个程序至少有一个进程，一个进程至少有一个线程，线程依赖于进程</p></li><li><p>进程在执行过程中有独立的内存单元，而多个线程共享进程的内存</p></li><li><p>多线程优势</p><ul><li>解耦合，简化程序开发：将不同种类任务分配专门线程，形成串行假象</li><li>提高资源利用率：对于多CPU来说，多个线程可以调度到多个CPU上运行，提高系统吞吐率</li></ul></li><li><p>多线程风险</p><ul><li>安全问题：当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么这个类就是线程安全的</li><li>活跃性问题：死锁、饥饿</li><li>性能问题：吞吐率过低、资源消耗过高。当线程调度器临时挂起活跃线程并转而运行另一个线程时，就会频繁出现上下文切换操作(Context Switch)，这种操作会导致 CPU 时间更多的花在线程调度上而非线程的运行上。</li></ul></li></ul><h3 id="进程间通信-IPC"><a href="#进程间通信-IPC" class="headerlink" title="进程间通信 IPC"></a>进程间通信 IPC</h3><ul><li>管道及命名管道<ul><li>管道：半双工通信方式，数据只能单向流动（父进程关闭fd[0]，子进程关闭fd[1]，父进程写，子进程读），且只能在具有亲缘关系（父子进程）的进程间使用。</li><li>高级管道：将另一个程序当作一个新的进程在当前程序进程中启动，则它算是当前程序的子进程</li><li>命名管道 (named pipe) ：命名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</li><li>消息队列：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li><li>信号量通信：计数器，控制多个程序共享资源的访问</li><li>信号：通知接收进程某个事件已经发生</li><li>共享内存：最快的通信方式，映射一段能被其他进程访问的内存，由一个进程创建，多个进程访问。通常与信号量配合使用，来实现进程间的同步和通信</li><li>套接字 (socket)：可用于不同机器间的进程通信，可简单归纳为命名、绑定、监听、连接、数据交互、断开连接这几个步骤</li></ul></li></ul><h3 id="线程同步方式"><a href="#线程同步方式" class="headerlink" title="线程同步方式"></a>线程同步方式</h3><ul><li>互斥锁 mutex：通过对共享资源进行加锁和解锁的操作，标记资源是否可用，无锁资源阻塞，知道互斥量被解锁</li><li>条件变量：自动阻塞某个线程，直到特殊情况发生为止。条件变量通常和互斥锁一起使用。条件变量使线程可以睡眠等待某种条件出现。条件变量是利用线程间共享的全局变量进行同步的机制，包括“等待条件成立而挂起”和“另一个线程使条件成立”两个动作。</li><li>信号量 sem：同一时刻允许多个线程访问同一资源，但是通过信号量控制最大线程数量，通过一个整型S和一个队列表现<ul><li>PV操作：不可被打断的操作系统原语，P检查信号量是否可用，V释放信号量，主要用于完成互斥控制和同步</li></ul></li></ul><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul><li>在两个或者多个<strong>并发</strong>进程中，进程间产生了互相等待对方资源释放的情况。通俗的讲，就是两个或多个进程无限期的阻塞、相互等待的一种状态。</li></ul><h4 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h4><ul><li>互斥：至少有一个资源一次只能有一个进程使用</li><li><p>占有并等待：进程至少占有一个资源，且正在等待另一个被占有的资源释放</p></li><li><p>非抢占：资源不能被抢占，只能等到占有者完成当前任务后才能占有</p></li><li>循环等待：若干进程间形成头尾相接的环形资源等待关系</li></ul><h4 id="处理策略"><a href="#处理策略" class="headerlink" title="处理策略"></a>处理策略</h4><blockquote><p> 预防死锁、避免死锁、检测死锁、解除死锁 、鸵鸟策略</p></blockquote><ul><li>预防死锁：确保四个必要条件至少有一个不成立就能预防死锁发生<ul><li>打破互斥条件：资源的互斥与否经常是由其本身决定的，因此通常不适用这种办法</li><li>打破占有并等待：预先占有所有资源，若不能完全占有则暂时挂起不执行，但是资源往往是动态分配的，不可预知，而且这样的策略会大大降低资源利用率和并发性</li><li>打破非抢占条件：进程在申请新资源得不到满足时，必须释放当前占有资源，以供给其他进程使用。实现起来较为困难，且降低了系统性能</li><li>打破循环等待：实行资源有序分配，对所有资源排序编号，只有在申请到小号资源的情况下才能申请大号的资源，这样就避免了环路的产生，预防死锁</li></ul></li><li>死锁避免<ul><li>进程启动拒绝：如果进程的请求会导致死锁，则不启动进程</li><li>资源分配拒绝：如果进程增加的资源请求会导致死锁，则不允许分配</li><li>安全状态：系统能按照某种进程顺序，为每个进程分配资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利完成</li><li>银行家算法：根据当前资源分配状态，试探性分配所需资源后，检查系统是否仍处于安全状态，是则分配，否则撤销试探性分配，令进程等待</li></ul></li><li><p>死锁检测：资源分配图</p></li><li><p>死锁解除</p><ul><li>资源抢占：从一个或多个死锁进程那里抢占一个或多个资源，此处需要避免饥饿问题（某个进程总是被抢占资源导致无法继续）</li><li>终止进程：一次性终止所有死锁进程或逐个终止死锁进程直至死锁解除</li></ul></li></ul><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><ul><li>就绪状态：获得处理机以外所有所需资源，等待分配处理机资源</li><li>运行状态：占用处理机资源运行，处于此状态的进程数要小于CPU数</li><li>阻塞状态：进程等待某种条件，在满足前无法执行</li><li>状态转换<ul><li>就绪-&gt;运行：进程调度程序为就绪进程分配了处理机</li><li>执行-&gt;就绪：进程分配的时间片用完</li><li>执行-&gt;阻塞：进程等待某种事件发生（IO请求等）无法继续执行，编程阻塞状态</li><li>阻塞-&gt;就绪：所等待的事件已经发生，变成就绪状态</li></ul></li></ul><p><img src="/images/process_status.jpg" alt="进程状态"></p><h3 id="Python中的多线程"><a href="#Python中的多线程" class="headerlink" title="Python中的多线程"></a>Python中的多线程</h3><ul><li><p>Python多线程编程<strong>常用threading模块</strong>。启动一个多线程需要创建一个Thread对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t = Thread(target=countdown, args=(<span class="number">10</span>,), daemon=<span class="literal">True</span>)  <span class="comment"># 后台线程</span></span><br><span class="line">t.start()　     <span class="comment"># 启动线程</span></span><br><span class="line">t.is_alive()    <span class="comment"># 查询线程对象的状态，返回布尔值</span></span><br><span class="line">t.join()        <span class="comment"># 将线程加入到当前线程，并等待其终止</span></span><br></pre></td></tr></table></figure></li><li><p>GIL是CPython特性，同一时刻只能运行一个线程，不能利用多核资源。Cpython的多线程适用于I/O密集型问题，计算密集型问题可使用<strong>多进程</strong>编程。</p></li><li>线程同步原语有Event / Condition / Semaphore / Barrier。<strong>Event用于常用语通知全部线程，condition和Semapher常用于通知一定数量的线程， Barrier用于多个线程必须完成某些步骤再一起执行。</strong>Lock / Rlock / Event / Condition / Semaphore <strong>支持上下文管理协议</strong>（with语句，好用）。</li><li>线程间通信可以用queue模块中的Queue队列，<strong>get()和put()已加锁，是线程安全的</strong></li></ul><h3 id="进程调度策略"><a href="#进程调度策略" class="headerlink" title="进程调度策略"></a>进程调度策略</h3><ul><li>FCFS 先来先服务：先请求CPU的进程先分配CPU</li><li>SJF 最短作业优先调度：从备选作业队列中选出一个或若干个估计运行时间最短的作业优先调度，一直运行至结束或因发生事件阻塞放弃处理机</li><li>FPF 高优先权优先调度：照顾优先级较高的作业优先调度。<ul><li>抢占式：当有优先级更高的进程出现时，停止当前进程，将处理机分配给优先级更高进程。适合对性能要求较高的批处理和分时系统</li><li>非抢占式：当进程占有处理机时，只能运行至结束或因发生事件阻塞放弃处理机。用于某些对实时性要求不严的实时系统</li><li>优先级倒置问题：由于一个高优先级和一个低优先级进程之间的相互等待资源的情况，导致中优先级抢先于高优先级进程运行。<ul><li>解决办法<ul><li>设置优先级上限：为临界区设置一个优先级上限，企图进入临界区的进程优先级需要低于这个上限</li><li>优先级继承：当高优先级进程等待低优先级进程资源时，低优先级进程暂时继承高优先级进程优先级，直到资源被释放后恢复低优先级</li><li>临界区禁止中断：系统优先级分为可抢占优先级和中断禁止优先级，将运行于临界区的进程通过中断禁止保护起来，防止在访问互斥数据时被高优先级任务抢占处理机</li></ul></li></ul></li></ul></li><li>高响应比优先调度：响应比 = （等待时间 + 服务时间）/ 服务时间，对长作业的运行得不到保证，但是避免了最短作业优先调度中长作业饥饿的问题。在调度之前需要计算响应比，增加系统开销</li><li>时间片轮转法<ul><li>将所有就绪进程按照原先的服务原则排成一个队列，每次调度时，把CPU分配给队首进程，并执行一个时间片</li><li>时间片用完，计时器发出中断请求，调度程序把进程送到就绪队列队尾，然后将处理机分配给就绪队列队首进程</li><li>由此循环，系统能够在给定时间内响应所有用户的请求</li></ul></li><li>多级反馈队列：多级反馈队列对长短进程均有照顾，可满足各种类型进程的需要<ul><li>设置一个优先级从高到低的n个队列，优先级越高，时间片约短</li><li>当有新进程进入时，放入最高优先级队列，在一个时间片内，若执行完成，则跳出队列；若不能执行完成，放入下一级队列队尾</li><li>只有当前面i-1个队列为空时，才能执行第i个队列；若在第i个队列的一个时间片内不能执行完成，则落入i+1队列队尾；第n个队列使用时间片轮转法进行调度</li><li>当有新进程需要调度时，立即把正在运行的进程放回当前队列的队尾，然后把处理机分给高优先级进程。当再度运行到当前队列的该进程时，仅分配上次还未完成的时间片，不再分配该队列对应的完整时间片。</li></ul></li></ul><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><ul><li>FIFO先进先出：按照队列顺序，先进先出</li><li>LRU 最近最少使用：按照最近一次的使用时间</li><li>LFU 最少使用：按照截至目前使用的总次数</li><li>OPT 最优置换：理论的最优，理论；就是要保证置换出去的是不再被使用的页，或者是在实际内存中最晚使用的算法</li></ul><h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><ul><li>时间上的局部性：最近被访问的页在不久的将来还会被访问；</li><li>空间上的局部性：内存中被访问的页周围的页也很可能被访问。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;blockquote&gt;
&lt;p&gt;参考&lt;a href=&quot;https://blog.csdn.net/justloveyou_/article/details/78304294&quot; ta
      
    
    </summary>
    
    
      <category term="技术" scheme="https://thomstrong.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Mysql数据库</title>
    <link href="https://thomstrong.github.io/2019/07/04/Mysql-Database/"/>
    <id>https://thomstrong.github.io/2019/07/04/Mysql-Database/</id>
    <published>2019-07-04T15:23:24.000Z</published>
    <updated>2019-07-05T08:58:54.061Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><blockquote><p>关系型数据库——MySQL部分概念</p></blockquote><h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><blockquote><p>个人感觉很像是用SQL语句封装出的函数</p></blockquote><ul><li>一些预编译的SQL语句，执行效率较高</li><li>在一定程度上保障数据安全</li></ul><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。</p><ul><li>只暴露部分字段给访问者，所以就建一个虚表，就是视图。</li><li>查询的数据来源于不同的表，而查询者希望以统一的方式查询，这样也可以建立一个视图，把多个表查询结果联合起来，查询者只需要直接从视图中获取数据，不必考虑数据来源于不同表所带来的差异</li></ul><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><ul><li>是对数据库表中一个或多个列的值进行排序的结构，帮助提高数据访问速度的数据库对象</li><li>索引加快了检索速度，但是降低了插入、删除、更新等维护任务的速度，大部分的更新操作同时需要更新索引</li><li>索引可以避免全表扫描，多数查询可仅扫描少量索引页及数据页</li><li>对于非聚集索引，有些查询甚至可以不访问数据页</li><li>聚集索引可以避免数据插入操作集中于表的最后一个数据页</li><li>某些情况下索引还可以避免排序操作</li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>大大加快检索速度;</li><li>创建唯一性索引，保证数据库表中每一行数据的唯一性;</li><li>加速表和表之间的连接;</li><li>在使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间。<ul><li>大大减少服务器需要扫描的数据量</li><li>帮助服务器避免排序和临时表</li><li>将所及I/O变为顺序I/O</li></ul></li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>索引需要占用数据表以外的物理存储空间</li><li>创建索引和维护索引要花费一定的时间</li><li>当对表进行更新操作时，索引需要被重建，这样降低了数据的维护速度。</li></ul><h4 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h4><ul><li>一条索引记录中包含的基本信息包括：键值（即你定义索引时指定的所有字段的值）+逻辑指针（指向数据页或者另一索引页）</li><li>当为空表创建索引时，数据库系统将分配一个索引页，在插入前保持空状态；当有数据插入时加入一行索引记录；当根结点满时，进行分裂：<ul><li>创建两个儿子节点</li><li>将当前根结点近似分为两半，分别写入儿子节点</li><li>将根结点加上指针指向新的两个儿子节点</li></ul></li><li>数据被删除导致索引中只包含一条索引记录时，该记录可能会被移至临近的索引页中，索引合并</li></ul><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>聚集索引：索引的逻辑顺序和数据的物理存储顺序相同<ul><li>应用场景：列经常被分组排序/搜索范围数据/主键列/外键列/仅有小数目的不同值</li><li>每个表中只能有一个聚集索引</li></ul></li><li>非聚集索引：索引的逻辑顺序和数据的物理存储顺序不同<ul><li>应用场景：列经常被分组排序/频繁更新列/主键列/外键列/大数目的不同值</li></ul></li><li>区别<ul><li>聚集索引是一种稀疏索引，数据页上一级的索引页存储的是页指针，而不是行指针。而对于非聚集索引，则是密集索引，在数据页的上一级索引页它为每一个数据行存储一条索引记录。</li><li>聚集索引的叶子结点是数据节点，非聚集索引的叶子结点并非数据结点</li></ul></li></ul><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li>不要索引数据量不大的表，对于小表来讲，表扫描的成本并不高。</li><li>主键并非都是聚合索引，使用了聚合索引的主键查询速度更快</li><li>建立适当的聚合索引，才能更好的提高查询的效率</li><li>一个复合索引包含A,B,C,D四列，则A为“引导列”；复合索引的引导列应该是查询最频繁的列</li><li>索引有助于提高检索性能，但过多或不当的索引也会导致系统低效。因为用户在表中每加进一个索引，数据库就要做更多的工作。过多的索引甚至会导致索引碎片。所以说，我们要建立一个“适当”的索引体系，特别是对聚合索引的创建，更应精益求精，才能使数据库性能更好的发挥</li><li>不要设置过多的索引，在没有聚集索引的表中，最大可以设置249个非聚集索引，过多的索引首先会带来更大的磁盘空间，而且在数据发生修改时，对索引的维护是特别消耗性能的</li><li>索引通常查询数据比全表扫描要快，但需要空间来存储，也需要定期维护。不必要的索引反而会使查询反应时间变慢.使用索引查询不一定能提高查询性能</li></ul><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><ul><li>并发控制的基本单位</li><li>一个操作序列，要么都执行，要么都不执行，结束时能保持数据一致性</li><li>定义事务的三条语句<ul><li>BEGIN TRANSACTION </li><li>COMMIT </li><li>ROLLBACK</li></ul></li><li>用户在事务（transaction）内可以声明（declare）被称为保存点（savepoint）的标记。保存点将一个大事务划分为较小的片断。</li></ul><h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><ul><li>触发器是一中特殊的存储过程，主要是通过事件来触发而被执行的。</li><li>它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。</li><li>可以联级运算。如，某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。</li><li>一个数据表可以有多个触发器，但一个触发器只能对应一个表</li></ul><h3 id="drop、delete与truncate"><a href="#drop、delete与truncate" class="headerlink" title="drop、delete与truncate"></a><strong>drop、delete</strong>与truncate</h3><ul><li>不再需要一张表及其数据的时候，用<strong>drop</strong></li><li>想删除部分数据行时候，用<strong>delete</strong>，并且带上where子句</li><li>保留表而删除所有数据的时候用<strong>truncate</strong>, 再插入时自增长id又从1开始 </li><li>当表被<strong>TRUNCATE</strong> 后，这个表和索引所占用的空间会恢复到初始大小，而<strong>DELETE</strong>操作不会减少表或索引所占用的空间。<strong>DROP</strong>语句将表所占用的空间全释放掉。</li><li>速度上，drop &gt; truncate &gt; delete</li><li>delete语句为DML（data maintain Language),这个操作会被放到 rollback segment中,事务提交后才生效。如果有相应的 tigger,执行的时候将被触发。</li><li>truncate、drop是DLL（data define language),操作立即生效，原数据不放到 rollback segment中，<strong>不能回滚</strong>。(如果一不小心把一个表truncate掉，也是可以恢复的，只是不能通过rollback来恢复)</li><li>对于外键（foreignkey ）约束引用的表，不能使用 truncate table，而应使用不带 where 子句的 delete 语句。</li><li>truncatetable不能用于参与了索引视图的表。</li><li>drop语句将删除表的结构所依赖的约束，触发器，索引，依赖于该表的存储过程/函数将保留,但是变为invalid状态。</li></ul><h3 id="超键、候选键、主键、外键"><a href="#超键、候选键、主键、外键" class="headerlink" title="超键、候选键、主键、外键"></a>超键、候选键、主键、外键</h3><ul><li>超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</li><li>候选键：是最小超键，即没有冗余元素（对数据唯一性不起作用的列元素）的超键。</li><li>主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。</li><li>外键：在一个表中存在的另一个表的主键称此表的外键。</li></ul><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Student( </span><br><span class="line"><span class="keyword">ID</span> <span class="built_in">NUMBER</span> PRIMARY <span class="keyword">KEY</span>, </span><br><span class="line"><span class="keyword">NAME</span> VARCHAR2(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>);//建表 </span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_name <span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">Select</span> * <span class="keyword">FROM</span> Table_name;//建视图 </span><br><span class="line"></span><br><span class="line"><span class="keyword">Create</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> index_name <span class="keyword">ON</span> TableName(col_name);//建索引 </span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tablename &#123;column1,column2,…&#125; <span class="keyword">values</span>(exp1,exp2,…);//插入 </span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Viewname &#123;column1,column2,…&#125; <span class="keyword">values</span>(exp1,exp2,…);//插入视图实际影响表 </span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> tablename <span class="keyword">SET</span> <span class="keyword">name</span>=<span class="string">'zang 3'</span> condition;//更新数据 </span><br><span class="line"></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Tablename <span class="keyword">WHERE</span> condition;//删除 </span><br><span class="line"></span><br><span class="line"><span class="keyword">GRANT</span> (<span class="keyword">Select</span>,<span class="keyword">delete</span>,…) <span class="keyword">ON</span> (对象) <span class="keyword">TO</span> USER_NAME [<span class="keyword">WITH</span> <span class="keyword">GRANT</span> <span class="keyword">OPTION</span>];//授权 </span><br><span class="line"></span><br><span class="line"><span class="keyword">REVOKE</span> (权限表) <span class="keyword">ON</span>(对象) <span class="keyword">FROM</span> USER_NAME [<span class="keyword">WITH</span> <span class="keyword">REVOKE</span> <span class="keyword">OPTION</span>] //撤权</span><br></pre></td></tr></table></figure><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><ul><li><a href="https://thomstrong.github.io/2019/07/02/SQL-vs-NoSQL/">SQL vs NoSQL</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;blockquote&gt;
&lt;p&gt;关系型数据库——MySQL部分概念&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;存储过程&quot;&gt;&lt;a href=&quot;#存储过程&quot; class=&quot;h
      
    
    </summary>
    
    
      <category term="技术" scheme="https://thomstrong.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Docker知识点</title>
    <link href="https://thomstrong.github.io/2019/07/04/Docker/"/>
    <id>https://thomstrong.github.io/2019/07/04/Docker/</id>
    <published>2019-07-04T01:13:25.000Z</published>
    <updated>2019-07-04T03:30:36.176Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><blockquote><p>参考<a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" target="_blank" rel="noopener">博文</a></p></blockquote><h1 id="知识铺垫"><a href="#知识铺垫" class="headerlink" title="知识铺垫"></a>知识铺垫</h1><h4 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h4><blockquote><p> 在操作系统中运行其他操作系统，对于底层来说，虚拟机是一个<strong>文件</strong></p></blockquote><ul><li>优势在于可通过还原虚拟机镜像/快照的方式还原原始环境</li><li>资源占用多、冗余步骤多、启动慢三个劣势</li></ul><h4 id="Linux容器"><a href="#Linux容器" class="headerlink" title="Linux容器"></a>Linux容器</h4><blockquote><p>不是模拟完整操作系统，而是对进程进行隔离</p></blockquote><ul><li>优势：启动快（一个容器相当于一个底层的进程）、占用资源少（只占用需要的资源，且可以共享资源）、体积小（只包含有用的组件）</li></ul><h4 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h4><blockquote><p>Linux 容器的封装，提供简单易用的容器使用接口</p></blockquote><ul><li>将应用程序与其依赖打包为一个文件，省去了环境配置带来的问题</li></ul><h1 id="Docker-1"><a href="#Docker-1" class="headerlink" title="Docker"></a>Docker</h1><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><ul><li>提供一次性的环境</li><li>提供弹性的云服务：随开随关，动态扩缩容</li><li>组件微服务架构：通过在一台机器上启动多个容器模拟微服务架构</li></ul><hr><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="image-镜像"><a href="#image-镜像" class="headerlink" title="image/镜像"></a>image/镜像</h4><ul><li>应用及其依赖打包在image文件里</li><li>可以看作是容器的模板，只有通过image才能生成容器</li><li><p>image是二进制文件，通常一个image是继承另一个image，再加上一些个性化设置而生成</p></li><li><p>命令</p><ul><li><code>docker image ls</code> </li><li><code>docker image rm [imageName or imageId]</code> or<code>docker rmi [imageName or imageId]</code></li><li><code>docker image pull [imageName]</code></li></ul></li><li><p>image一般不建议重复造轮</p></li></ul><h4 id="Container-容器"><a href="#Container-容器" class="headerlink" title="Container/容器"></a>Container/容器</h4><ul><li>image 文件生成的容器实例，本身也是一个文件，称为容器文件</li><li>命令<ul><li><code>docker container run [imageName]</code> # 该命令有自动抓取image文件的功能，如果本地没有指定的image文件，就会从仓库自动抓取</li><li><code>docker container run -it [imageName] bash</code> # 将运行的容器映射到终端中<ul><li><code>-p 8000:3000</code>参数：容器的 3000 端口映射到本机的 8000 端口。</li><li><code>-it</code>参数：容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。</li><li><code>koa-demo:0.0.1</code>：image 文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）。</li><li><code>/bin/bash</code>：容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。</li></ul></li><li><code>docker container kill [containerId]</code> # 终止容器运行</li><li><code>docker container rm</code>or <code>docker rm</code> </li></ul></li></ul><h4 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h4><ul><li><p>文本文件，用来配置image</p></li><li><p>.dockerignore # 加入不需要打包入image的文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.git</span><br><span class="line">node_modules</span><br><span class="line">npm-debug.log</span><br></pre></td></tr></table></figure></li><li><p>Dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">8.4</span> <span class="comment"># 继承自官方node image</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /app <span class="comment"># 将当前目录下所有文件（除了.dockerignore排除的路径）复制到image文件的/app下</span></span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app <span class="comment"># 之后的工作路径为/app</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm install --registry=https://registry.npm.taobao.org <span class="comment"># 安装node依赖</span></span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3000</span> <span class="comment"># 将容器的3000端口暴露出来，允许外部连接</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> node demos/01.js <span class="comment"># 容器启动后执行 node demos/01.js这条命令</span></span></span><br><span class="line"><span class="comment"># RUN命令在 image 文件的构建阶段执行，执行结果都会打包进入 image 文件；CMD命令则是在容器启动后执行。另外，一个 Dockerfile 可以包含多个RUN命令，但是只能有一个CMD命令。</span></span><br><span class="line"><span class="comment"># 指定了CMD命令以后，docker container run命令就不能附加命令了（比如前面的/bin/bash），否则它会覆盖CMD命令。</span></span><br></pre></td></tr></table></figure></li><li><p>build/打包 image</p><ul><li><code>docker image build -t koa-demo .</code> # 使用当前目录下的dockerfile打包image，名称为koa-demo</li></ul></li><li><p>生成容器</p><ul><li><code>docker container run --rm -p 8000:3000 -it [imageName] [someCmd]</code></li></ul></li></ul><h3 id="一些命令"><a href="#一些命令" class="headerlink" title="一些命令"></a>一些命令</h3><ul><li><code>docker container start [containerId or containerName]</code> or <code>docker start [containerId or containerName]</code>  # 启动一个已生成的容器</li><li><code>docker container stop</code></li><li><code>docker container logs</code> # 查看容器的标准输出</li><li><code>docker container exec -it [containerID or containerName] /bin/bash</code> # 将容器的shell映射到本地终端</li><li><code>docker container cp [containID]:[/path/to/file] .</code> # 将容器<code>/path/to/file</code>路径对应的文件复制到当前目录</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;blockquote&gt;
&lt;p&gt;参考&lt;a href=&quot;http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html&quot; ta
      
    
    </summary>
    
    
      <category term="技术" scheme="https://thomstrong.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>SQL vs NoSQL总结</title>
    <link href="https://thomstrong.github.io/2019/07/02/SQL-vs-NoSQL/"/>
    <id>https://thomstrong.github.io/2019/07/02/SQL-vs-NoSQL/</id>
    <published>2019-07-02T08:02:57.000Z</published>
    <updated>2019-07-03T08:04:01.013Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="SQL-vs-NoSQL"><a href="#SQL-vs-NoSQL" class="headerlink" title="SQL vs NoSQL"></a>SQL vs NoSQL</h1><blockquote><p><a href="https://www.xplenty.com/blog/the-sql-vs-nosql-difference/" target="_blank" rel="noopener">参考blog</a></p></blockquote><h3 id="SQL（关系型数据库）"><a href="#SQL（关系型数据库）" class="headerlink" title="SQL（关系型数据库）"></a>SQL（关系型数据库）</h3><ul><li>使用结构化查询语句（Structured Query Language)来定义和管理数据</li><li>通用且使用广泛，能够安全适用于复杂查询密集的环境</li><li>使用之前需要进行数据结构定义，所有数据遵循相同结构，结构的变化较难应付</li><li>MySql，Oracle，Sqlite，Postgres和MS-SQL</li></ul><h3 id="NoSQL（非关系数据库-分布式数据库）"><a href="#NoSQL（非关系数据库-分布式数据库）" class="headerlink" title="NoSQL（非关系数据库/分布式数据库）"></a>NoSQL（非关系数据库/分布式数据库）</h3><ul><li>非结构化数据动态模式，数据以多种方式存储，可以面向列、面向文档、基于图或者K-V模式存储</li><li>没有标准接口来执行复杂查询</li><li>数据文档无需进行预先定义和结构声明，每个文档可以拥有不同的结构，数据域能随意拓展</li><li>MongoDB，BigTable，Redis，RavenDb，Cassandra，Hbase，Neo4j和CouchDb</li></ul><hr><h3 id="拓展性"><a href="#拓展性" class="headerlink" title="拓展性"></a>拓展性</h3><ul><li>SQL具备垂直拓展性，可通过增加CPU/RAM/SSD来提升负载能力</li><li>NoSQL具备水平拓展性，可通过增加更多服务器提升负载能力</li></ul><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><ul><li>SQL数据库基于表存储</li><li>NoSQL数据库基于文档/k-v对/图/宽列存储</li></ul><h3 id="数据存储类型"><a href="#数据存储类型" class="headerlink" title="数据存储类型"></a>数据存储类型</h3><ul><li>SQL不支持分布式数据存储</li><li>NoSQL能更好的适应分布式数据存储，因其使用了k-v对这样类似Json数据的数据存储方式，对于大型数据集的存储有更好的表现。Hbase就是一个很好的例子</li></ul><h3 id="事务应用"><a href="#事务应用" class="headerlink" title="事务应用"></a>事务应用</h3><blockquote><ul><li><p>一个事务是一连串的操作组成，增删改查的集合</p></li><li><p>特性ACID：</p><ul><li>原子性（Atomicity）：要么完整执行，要么不执行</li><li>一致性（Consistency）：执行前后，数据保持完整和逻辑一致（银行存款例子），原子性和持久性是事务一致性的充分条件</li><li>隔离性（Isolation）：多个并发事务是独立的，上下文彼此隔离，互不干扰，使用锁机制进行数据线程安全控制。四种隔离级别<ul><li>读未提交，其隔离级别最低，允许脏读。换句话说就是，如果一个事务正在处理某一数据，并对其进行了更新，但是同时没有提交事务，允许另一个事务也可以访问</li><li>读已提交，和读未提交的区别就是。读未提交可以读取到别人没有提交的数据，但是读已提交只能读取到别人提交后的值，事务进行的中间值不会读取到</li><li>可重复读，简单来说就是事务处理过程中多次读取同一个数据的时候，这个值不会发生改变，其值都和第一次查询到的数据是一致的</li><li>串行化，是最严格的隔离级别，他要求所有的事务都被串行执行，既事务只能一个接一个的进行处理，不能并发执行</li></ul></li><li>持久性（Durability）：在提交后已提交的数据应该能过永久保存，在系统发生异常后仍能回到异常发生前的状态</li></ul></li></ul></blockquote><ul><li>SQL数据库最适合重量级事务类型应用程序，因为它更稳定，且承诺了数据的原子性和完整性</li><li>NoSQL也可以在事务中应用，但是在高负载和复杂事务的应用环境下不能有更好的表现</li></ul><h3 id="外部支持"><a href="#外部支持" class="headerlink" title="外部支持"></a>外部支持</h3><ul><li>SQL数据库有更丰富的提供商和解决方案作为支持</li><li>NoSQL目前仍然依赖于社区</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;SQL-vs-NoSQL&quot;&gt;&lt;a href=&quot;#SQL-vs-NoSQL&quot; class=&quot;headerlink&quot; title=&quot;SQL vs NoSQL&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>网络协议部分复习</title>
    <link href="https://thomstrong.github.io/2019/07/01/Network-Protocal/"/>
    <id>https://thomstrong.github.io/2019/07/01/Network-Protocal/</id>
    <published>2019-07-01T08:01:06.000Z</published>
    <updated>2019-07-03T08:02:18.089Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h1><h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h3><p>OSI 中的层                          功能                                                                     TCP/IP协议族<br>应用层            文件传输，电子邮件，文件服务，虚拟终端       TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet<br>表示层            数据格式化，代码转换，数据加密                                  没有协议<br>会话层            解除或建立与别的接点的联系                                       没有协议<br>传输层            提供端对端的接口                                                    TCP，UDP （RTP）<br>网络层            为数据包选择路由                                                    IP，ICMP，RIP，OSPF，BGP，IGMP<br>数据链路层    传输有地址的帧以及错误检测功能                         SLIP，CSLIP，PPP，ARP，RARP，MTU<br>物理层            以二进制数据形式在物理媒体上传输数据                    ISO2110，IEEE802，IEEE802.2</p><h3 id="TCP-IP五层模型的协议"><a href="#TCP-IP五层模型的协议" class="headerlink" title="TCP/IP五层模型的协议"></a>TCP/IP五层模型的协议</h3><p>应用层<br>传输层：四层交换机、也有工作在四层的路由器</p><p>网络层：路由器、三层交换机</p><p>数据链路层：网桥（现已很少使用）、以太网交换机（二层交换机）、网卡（其实网卡是一半工作在物理层、一半工作在数据链路层）</p><p>物理层：中继器、集线器、还有我们通常说的双绞线也工作在物理层</p><h3 id="RTP协议"><a href="#RTP协议" class="headerlink" title="RTP协议"></a>RTP协议</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>RTP全名是Real-time Transport Protocol（实时传输协议）。它是IETF提出的一个标准，对应的RFC文档为RFC3550（RFC1889为其过期版本）。RFC3550不仅定义了RTP，而且定义了配套的相关协议RTCP（Real-time Transport Control Protocol，即实时传输控制协议）。RTP用来为IP网上的语音、图像、传真等多种需要实时传输的多媒体数据提供<strong>端到端</strong>的实时传输服务。RTP为Internet上端到端的实时传输提供时间信息和流同步，但并不保证服务质量，<strong>服务质量由RTCP来提供</strong>。</p><ul><li>RTP功能：用来为IP网上的语音、图像、传真等多种需要实时传输的多媒体数据提供<strong>端到端</strong>的实时传输服务</li><li>RTCP功能：服务质量的监视与反馈、媒体间的同步，以及多播组中成员的标识。在RTP会话期间，各参与者<strong>周期性地传送RTCP包</strong>。RTCP包中含有已发送的数据包的数量、丢失的数据包的数量等<strong>统计资料</strong>，因此，各参与者可以利用这些信息动态地改变传输速率，甚至改变有效载荷类型。</li><li>RTP和RTCP配合使用，它们能以有效的反馈和最小的开销使传输效率最佳化，因而特别适合传送网上的实时数据。</li></ul><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ul><li>简单的多播音频会议</li><li>音频和视频会议</li><li>翻译器和混合器</li></ul><h4 id="流媒体"><a href="#流媒体" class="headerlink" title="流媒体"></a>流媒体</h4><p>流媒体是指Internet上使用流式传输技术的连续时基媒体。当前在Internet上传输音频和视频等信息主要有两种方式：下载和流式传输两种方式。流式传输是实现流媒体的关键技术。</p><ul><li>要实现流式传输，就是要从降低延迟和恢复数据包时序入手。在发送端，为降低延迟，往往对传输数据进行预处理（降低质量和高效压缩）。在接收端为了恢复时序，采用了接收缓冲；而为了实现媒体的流畅播放，则采用了播放缓冲。</li><li>使用接收缓冲，可以将接收到的数据包缓存起来，然后根据数据包的封装信息（如包序号和时戳等），将乱序的包重新排序，最后将重新排序了的数据包放入播放缓冲播放。</li></ul><h4 id="会话过程"><a href="#会话过程" class="headerlink" title="会话过程"></a>会话过程</h4><p>当应用程序建立一个RTP会话时，应用程序将确定一对目的传输地址。目的传输地址由一个网络地址和一对端口组成，有两个端口：一个给RTP包，一个给RTCP包，使得RTP/RTCP数据能够正确发送。RTP数据发向偶数的UDP端口，而对应的控制信号RTCP数据发向相邻的奇数UDP端口（偶数的UDP端口＋1），这样就构成一个UDP端口对。 RTP的发送过程如下，接收过程则相反。</p><ul><li><p>RTP协议从上层接收流媒体信息码流（如H.263），封装成RTP数据包；RTCP从上层接收控制信息，封装成RTCP控制包。</p></li><li><p>RTP将RTP 数据包发往UDP端口对中偶数端口；RTCP将RTCP控制包发往UDP端口对中的接收端口。</p></li></ul><h3 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul><li>TCP，全称Transfer Control Protocol，中文名为传输控制协议，它工作在OSI的传输层，提供面向连接的可靠传输服务。</li><li>TCP的工作主要是建立连接，然后从应用层程序中接收数据并进行传输。TCP采用虚电路连接方式进行工作，在发送数据前它需要在发送方和接收方建立一个连接，数据在发送出去后，发送方会等待接收方给出一个确认性的应答，否则发送方将认为此数据丢失，并重新发送此数据。</li></ul><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ul><li>TCP连接建立：TCP的连接建立过程又称为TCP<strong>三次握手</strong>。首先发送方主机向接收方主机发起一个建立连接的同步（SYN）请求；接收方主机在收到这个请求后向送方主机回复一个同步/确认（SYN/ACK）应答；发送方主机收到此包后再向接收方主机发送一个确认（ACK），此时TCP连接成功建立</li><li>TCP连接关闭：发送方主机和目的主机建立TCP连接并完成数据传输后，会发送一个将结束标记置1的数据包，以关闭这个TCP连接，并同时释放该连接占用的缓冲区空间；</li><li>TCP重置：TCP允许在传输的过程中突然中断连接，这称为TCP重置；</li><li>TCP数据排序和确认：TCP是一种可靠传输的协议，它在传输的过程中使用序列号和确认号来跟踪数据的接收情况；</li><li>TCP重传：在TCP的传输过程中，如果在重传超时时间内没有收到接收方主机对某数据包的确认回复，发送方主机就认为此数据包丢失，并再次发送这个数据包给接收方，这称为TCP重传；</li><li>TCP延迟确认：TCP并不总是在接收到数据后立即对其进行确认，它允许主机在接收数据的同时发送自己的确认信息给对方。</li><li>TCP数据保护（校验和）：TCP是可靠传输的协议，它提供校验和计算来实现数据在传输过程中的完整性。</li></ul><h3 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><ul><li>UDP协议是英文UserDatagramProtocol的缩写，即用户数据报协议，主要用来支持那些需要在计算机之间传输数据的网络应用。包括网络视频会议系统在内的众多的客户/服务器模式的网络应用都需要使用UDP协议。</li><li>UDP协议的主要作用是将网络数据流量压缩成数据报的形式。一个典型的数据报就是一个二进制数据的传输单位。每一个数据报的前8个字节用来包含报头信息，剩余字节则用来包含具体的传输数据。</li></ul><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ul><li>RTP位于UDP之上，UDP虽然没有TCP那么可靠，并且无法保证实时业务的服务质量，需要RTCP实时监控数据传输和服务质量，但是，由于UDP的传输时延低于TCP，能与视频和音频很好匹配。因此，在实际应用中，RTP/RTCP/UDP用于音频/视频媒体，而TCP用于数据和控制信令的传输。</li><li>UDP和TCP协议的主要区别是两者在如何实现信息的可靠传递方面不同。TCP协议中包含了专门的传递保证机制，当数据接收方收到发送方传来的信息时，会自动向发送方发出确认消息；发送方只有在接收到该确认消息之后才继续传送其它信息，否则将一直等待直到收到确认信息为止。</li><li>TCP比UDP多了建立连接的时间。相对UDP而言，TCP具有更高的安全性和可靠性。TCP协议传输的大小不限制，一旦连接被建立，双方可以按照一定的格式传输大量的数据，而UDP是一个不可靠的协议，大小有限制，每次不能超过64K。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;网络协议&quot;&gt;&lt;a href=&quot;#网络协议&quot; class=&quot;headerlink&quot; title=&quot;网络协议&quot;&gt;&lt;/a&gt;网络协议&lt;/h1&gt;&lt;h3 id=&quot;OSI七层模型
      
    
    </summary>
    
    
      <category term="技术" scheme="https://thomstrong.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Redis知识点</title>
    <link href="https://thomstrong.github.io/2019/06/21/Redis/"/>
    <id>https://thomstrong.github.io/2019/06/21/Redis/</id>
    <published>2019-06-21T07:32:20.000Z</published>
    <updated>2019-07-03T12:28:00.622Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Redis知识点汇总"><a href="#Redis知识点汇总" class="headerlink" title="Redis知识点汇总"></a>Redis知识点汇总</h1><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>C 语言写成的，开源的 key-value 数据库</li><li>和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set 使用score排序)和hash（哈希类型）</li><li>这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。</li><li>与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步</li></ul><h3 id="对比memcached"><a href="#对比memcached" class="headerlink" title="对比memcached"></a>对比memcached</h3><p><img src="/images/redis_vs_memcached.jpg" alt="redis_vs_memcached"></p><ul><li>Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。memcache支持简单的数据类型，String。</li><li>Redis支持数据的备份，即master-slave模式的数据备份。</li><li>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而Memecache把数据全部存在内存之中</li><li>redis的速度比memcached快很多</li><li><p>Memcached是多线程，非阻塞IO复用的网络模型；Redis使用单线程的IO复用模型。</p></li><li><p><strong>终极策略：</strong> 使用Redis的String类型做的事，都可以用Memcached替换，以此换取更好的性能提升； 除此以外，优先考虑Redis</p></li></ul><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>(1) <strong>速度快</strong>，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)</p><p>(2)<strong>支持丰富数据类型</strong>，支持string，list，set，sorted set，hash</p><p>(3) <strong>支持事务</strong> ：redis对事务是部分支持的，如果是在入队时报错，那么都不会执行；在非入队时报错，那么成功的就会成功执行。</p><p>(4) <strong>丰富的特性</strong>：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ul><li>字符串操作： SET/GET</li><li>哈希类型操作：HMSET/ HGETALL/ HSET</li><li>列表（链表）：LPUSH/ RPUSH/ LPOP/ RPOP/ LRANGE</li><li>集合：SADD/ SMEMBERS</li><li>有序集合（ZSET）：ZADD/ ZRANGE</li><li>HyperLogLog（集合基数统计）:PFADD/ PFCOUNT/ PFMERGE</li><li>2.8+ 扫描操作：SCAN/ SSCAN/ HSCAN/ ZSCAN</li><li>发布订阅<ul><li>发布订阅模式，两个客户端之间通过SUBSCRIBE/ PULISH交换消息</li><li>命令：PUBLISH/ SUBSCRIBE/ PUBSUB</li></ul></li><li>事务<ul><li>从开始到执行会进入以下步骤：开始事务—进入队列—执行事务</li><li>事务可以认为是一个批量执行的脚本，内部命令是原子的，但事务本身并非原子。中间的命令失败不会导致其之前命令回滚，也不会导致其之后命令放弃执行</li><li>命令：<ul><li>MULTI（标记事务开始）</li><li>EXEC（开始执行事务）</li><li>DISCARD（放弃执行事务块）</li></ul></li></ul></li><li>脚本：EVAL script numkeys key [key …] arg [arg …]</li><li>备份与恢复<ul><li>备份：<code>SAVE</code>命令存储数据到dump.rdb，<code>CONFIG GET dir</code>查看rdb文件存储位置，将文件备份</li><li>恢复：只需将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可</li></ul></li><li>性能测试：<code>redis-benchmark -n 10000  -q</code></li></ul><h3 id="keys-和-SCAN"><a href="#keys-和-SCAN" class="headerlink" title="keys 和 SCAN"></a>keys 和 SCAN</h3><ul><li>keys {pattern} 获取所有符合pattern 的key<ul><li>没有offset和limit参数，会返回所有的key</li><li>复杂度O(n)， 当n较大时导致redis服务卡顿</li><li>由于redis是单线程的，会阻塞redis后续的命令</li></ul></li><li>scan {cursor} [MATCH pattern] [COUNT count]<ul><li>复杂度虽然也是 O(n)，但是它是通过游标分步进行的，不会阻塞线程;</li><li>提供 count 参数，可以控制每次返回结果的最大条数，count 只是对增量式迭代命令的一种提示(hint)，返回的结果可多可少;</li><li>同 keys 一样，它也提供模式匹配功能;</li><li>服务器不需要为游标保存状态，游标的唯一状态就是 scan 返回给客户端的游标整数;</li><li>返回的结果可能会有重复，需要<strong>客户端去重复</strong>，这点非常重要;</li><li>遍历的过程中如果有数据修改，改动后的数据能不能遍历到是不确定的;</li><li>单次返回的结果是空的并不意味着遍历结束，而要看返回的游标值是否为零</li></ul></li></ul><h3 id="一些规范"><a href="#一些规范" class="headerlink" title="一些规范"></a>一些规范</h3><blockquote><p>参考<a href="https://mp.weixin.qq.com/s/E2ZPXTE7lXfHFH2bMRnj0g" target="_blank" rel="noopener">推送</a></p></blockquote><ul><li><p>Key 名称设计：</p><ul><li><p>在尽量保持可读性的前提下，缩短key的长度</p><p><code>user:{uid}:friends:messages:{mid} 简化为 u:{uid}:fr:m:{mid}。</code></p></li></ul></li><li><p>value 设计：</p><ul><li>拒绝bigkey，string类型控制在10KB以内，hash、list、set、zset元素个数不要超过5000。</li><li>如果你观察到 Redis 的内存大起大落，这极有可能是因为大 key 导致的，这时候你就需要定位出具体是哪个 key，<code>redis-cli --bigkeys -i 0.1 # 每隔100条scan就会休眠0.1s</code>命令可以用来找到。</li><li>非字符串的bigkey，不要使用del删除，使用hscan、sscan、zscan方式渐进式删除，同时要注意防止bigkey过期时间自动删除问题(例如一个200万的zset设置1小时过期，会触发del操作，造成阻塞，而且该操作不会不出现在慢查询中(latency可查))，查找方法和删除方法</li><li>选择适合的数据类型</li></ul></li><li><p>建议使用expire设置过期时间(条件允许可以打散过期时间，防止集中过期)，不过期的数据重点关注idletime。</p></li><li><p>避免一些在n比较大时的O(n)操作，禁用一些危险命令，可在conf文件中使用<code>rename-command flushdb flushddbb</code>命令对危险命令进行重命名</p></li><li><p>使用如原生的<code>mget</code> <code>mset</code>或非原生的<code>pipline</code>这种批量命令来提高效率，</p></li><li><p>不建议过多使用事务功能</p></li><li><p>避免多个应用使用一个redis实例，不想干业务拆分，公共数据做服务化</p></li><li><p>根据自身业务类型，选好maxmemory-policy(最大内存淘汰策略)，设置好过期时间。</p><p>默认策略是volatile-lru，即超过最大内存后，在过期键中使用lru算法进行key的剔除，保证不过期数据不被删除，但是可能会出现OOM问题。</p><p><strong>其他策略如下</strong>：</p><ul><li>allkeys-lru：根据LRU算法删除键，不管数据有没有设置超时属性，直到腾出足够空间为止。</li><li>allkeys-random：随机删除所有键，直到腾出足够空间为止。</li><li>volatile-random:随机删除过期键，直到腾出足够空间为止。</li><li>volatile-ttl：根据键值对象的ttl属性，删除最近将要过期数据。如果没有，回退到noeviction策略。</li><li>noeviction：不会剔除任何数据，拒绝所有写入操作并返回客户端错误信息”(error) OOM command not allowed when used memory”，此时Redis只响应读操作。</li></ul></li></ul><h3 id="Jedis下删除bigkeys的一些代码示例"><a href="#Jedis下删除bigkeys的一些代码示例" class="headerlink" title="Jedis下删除bigkeys的一些代码示例"></a>Jedis下删除bigkeys的一些代码示例</h3><ul><li>Hash删除: hscan + hdel</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delBigHash</span><span class="params">(String host, <span class="keyword">int</span> port, String password, String bigHashKey)</span> </span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(host, port);</span><br><span class="line">    <span class="keyword">if</span> (password != <span class="keyword">null</span> &amp;&amp; !<span class="string">""</span>.equals(password)) &#123;</span><br><span class="line">        jedis.auth(password);</span><br><span class="line">    &#125;</span><br><span class="line">    ScanParams scanParams = <span class="keyword">new</span> ScanParams().count(<span class="number">100</span>);</span><br><span class="line">    String cursor = <span class="string">"0"</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ScanResult&lt;Entry&lt;String, String&gt;&gt; scanResult = jedis.hscan(bigHashKey, cursor, scanParams);</span><br><span class="line">        List&lt;Entry&lt;String, String&gt;&gt; entryList = scanResult.getResult();</span><br><span class="line">        <span class="keyword">if</span> (entryList != <span class="keyword">null</span> &amp;&amp; !entryList.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Entry&lt;String, String&gt; entry : entryList) &#123;</span><br><span class="line">                jedis.hdel(bigHashKey, entry.getKey());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cursor = scanResult.getStringCursor();</span><br><span class="line">    &#125; <span class="keyword">while</span> (!<span class="string">"0"</span>.equals(cursor));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除bigkey</span></span><br><span class="line">    jedis.del(bigHashKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>List删除: ltrim</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delBigList</span><span class="params">(String host, <span class="keyword">int</span> port, String password, String bigListKey)</span> </span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(host, port);</span><br><span class="line">    <span class="keyword">if</span> (password != <span class="keyword">null</span> &amp;&amp; !<span class="string">""</span>.equals(password)) &#123;</span><br><span class="line">        jedis.auth(password);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> llen = jedis.llen(bigListKey);</span><br><span class="line">    <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">while</span> (counter &lt; llen) &#123;</span><br><span class="line">        <span class="comment">//每次从左侧截掉100个</span></span><br><span class="line">        jedis.ltrim(bigListKey, left, llen);</span><br><span class="line">        counter += left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最终删除key</span></span><br><span class="line">    jedis.del(bigListKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Set删除: sscan + srem</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delBigSet</span><span class="params">(String host, <span class="keyword">int</span> port, String password, String bigSetKey)</span> </span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(host, port);</span><br><span class="line">    <span class="keyword">if</span> (password != <span class="keyword">null</span> &amp;&amp; !<span class="string">""</span>.equals(password)) &#123;</span><br><span class="line">        jedis.auth(password);</span><br><span class="line">    &#125;</span><br><span class="line">    ScanParams scanParams = <span class="keyword">new</span> ScanParams().count(<span class="number">100</span>);</span><br><span class="line">    String cursor = <span class="string">"0"</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ScanResult&lt;String&gt; scanResult = jedis.sscan(bigSetKey, cursor, scanParams);</span><br><span class="line">        List&lt;String&gt; memberList = scanResult.getResult();</span><br><span class="line">        <span class="keyword">if</span> (memberList != <span class="keyword">null</span> &amp;&amp; !memberList.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String member : memberList) &#123;</span><br><span class="line">                jedis.srem(bigSetKey, member);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cursor = scanResult.getStringCursor();</span><br><span class="line">    &#125; <span class="keyword">while</span> (!<span class="string">"0"</span>.equals(cursor));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除bigkey</span></span><br><span class="line">    jedis.del(bigSetKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>SortedSet删除: zscan + zrem</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delBigZset</span><span class="params">(String host, <span class="keyword">int</span> port, String password, String bigZsetKey)</span> </span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(host, port);</span><br><span class="line">    <span class="keyword">if</span> (password != <span class="keyword">null</span> &amp;&amp; !<span class="string">""</span>.equals(password)) &#123;</span><br><span class="line">        jedis.auth(password);</span><br><span class="line">    &#125;</span><br><span class="line">    ScanParams scanParams = <span class="keyword">new</span> ScanParams().count(<span class="number">100</span>);</span><br><span class="line">    String cursor = <span class="string">"0"</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ScanResult&lt;Tuple&gt; scanResult = jedis.zscan(bigZsetKey, cursor, scanParams);</span><br><span class="line">        List&lt;Tuple&gt; tupleList = scanResult.getResult();</span><br><span class="line">        <span class="keyword">if</span> (tupleList != <span class="keyword">null</span> &amp;&amp; !tupleList.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Tuple tuple : tupleList) &#123;</span><br><span class="line">                jedis.zrem(bigZsetKey, tuple.getElement());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cursor = scanResult.getStringCursor();</span><br><span class="line">    &#125; <span class="keyword">while</span> (!<span class="string">"0"</span>.equals(cursor));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除bigkey</span></span><br><span class="line">    jedis.del(bigZsetKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;Redis知识点汇总&quot;&gt;&lt;a href=&quot;#Redis知识点汇总&quot; class=&quot;headerlink&quot; title=&quot;Redis知识点汇总&quot;&gt;&lt;/a&gt;Redis知
      
    
    </summary>
    
    
      <category term="技术" scheme="https://thomstrong.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Memcached 知识点</title>
    <link href="https://thomstrong.github.io/2019/06/20/Memcached/"/>
    <id>https://thomstrong.github.io/2019/06/20/Memcached/</id>
    <published>2019-06-20T07:30:29.000Z</published>
    <updated>2019-07-03T07:33:05.584Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Memcached知识点"><a href="#Memcached知识点" class="headerlink" title="Memcached知识点"></a>Memcached知识点</h1><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Memcached是一个免费开源的，高性能的，具有分布式对象的缓存系统，它可以用来保存一些经常存取的对象或数据，保存的数据像一张巨大的<strong>HASH表</strong>，该表以Key-value对的方式存在<strong>内存</strong>中。</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ul><li><p>检查客户端请求是否在memcached中</p></li><li><p>若有则直接返回</p></li><li><p>若无则从数据库查询后返回，并存储到memcached中</p></li><li><p>数据库更新需要同时更新memcached，保证一致性</p></li><li><p>memcached内存用完后会使用LRU策略加上到期失效策略，首先替换到期失效数据，之后替换最近未使用过的数据</p><blockquote><p>缓存置换算法（页面置换算法）FIFO/ LFU/ LRU</p><ol><li>FIFO 先进先出，最先进入缓存的最先替换掉</li><li>LFU 最近最少使用，替换掉最近一段时间使用次数最少的数据</li><li>LRU 最近最久未使用使用，替换掉最近一段时间没使用过的，以最近一次使用时间为基准，替换最远的数据空间</li></ol></blockquote></li></ul><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul><li><p>协议简单：基于文本行的协议，直接通过telnet在memcached服务器上可进行存取数据操作</p><blockquote><p>Telnet 远程连接服务，作用于tcp/ip协议的应用层</p></blockquote></li><li><p>基于libevent事件处理：libevent是一套利用C开发的程序库，由事件驱动，跨平台，支持并发编程</p></li><li>内置的内存管理方式：所有数据存于内存，LRU算法替换，数据易失</li><li>分布式：分布式取决于memcache客户端，memcached服务器之间互不通信，数据独立存储</li></ul><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><blockquote><p>服务启动方法<code>/usr/local/memcached/bin/memcached –p 11211 –d –u root –P /tmp/memcached.pid</code></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">telnet 127.0.0.1 11211 # 远程连接memcached</span><br><span class="line">stats items # 获取所有items的序号，例如items:29:hits_to_warm</span><br><span class="line">stats cachedump 29 0 # 获取编号29的item的key，返回如:1:/api/courses/tags/?；0表示返回所有slab中的item；若指定返回1个则使用stats cachedump 29 1</span><br><span class="line"></span><br><span class="line">get :1:/api/courses/tags/? # 获取key对应的值，多个键空格分割</span><br><span class="line"></span><br><span class="line">set cai 0 900 9 # 设置/更新key为cai的值为caicaicai，过期时间为900ms，以下输入的数据占9字节</span><br><span class="line">caicaicai # 存储成功返回STORED，失败返回ERROR</span><br><span class="line"></span><br><span class="line">add cai 0 900 9 # 设置key为cai的值为caicaicai，过期时间为900ms，以下输入的数据占9字节</span><br><span class="line">caicaicai # 存储成功返回STORED，失败或key存在返回NOT_STORED</span><br><span class="line"></span><br><span class="line"><span class="meta"> #</span><span class="bash"> replace 用于直接替换</span></span><br><span class="line"><span class="meta"> #</span><span class="bash"> append 用于直接在key对应的数据后面追加数据</span></span><br><span class="line"><span class="meta"> #</span><span class="bash"> prepend 用于直接在key对应的数据前面追加数据</span></span><br><span class="line"> cas cai 0 900 3 14 # 14为gets获取到的token，CAS 通过先检查token后再设置/更新值，避免数据不一致</span><br><span class="line"> aaa # 成功返回STORED；保存错误/语法错误返回ERROR；EXISTS说明token过期/不合法；NOT_FOUND该key不存在</span><br><span class="line"></span><br><span class="line"> gets cai # 返回带有token的value</span><br><span class="line"></span><br><span class="line">incr key increment_value # 自增key对应的value，必须是32位无符号整数</span><br><span class="line">decr key increment_value # 自减key对应的value，必须是32位无符号整数</span><br><span class="line"></span><br><span class="line">stats # 输出统计信息</span><br></pre></td></tr></table></figure><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ul><li>内存分配：Slab allocation机制分配和管理，先按照预定的大小，将分配的内存分割成特定长度的内存块chunck，然后再把相同的内存块分成组slab，根据值的大小去匹配slab大小，找就近的slab存放</li><li>缓存策略：失效策略 + LRU；不会监控存入的key/value是否过期，而是获取key时去查看记录的时间戳，检查key/value是否过期</li><li>分布式算法：memcached本身不存在分布式，而是客户端进行分布式选择memcached服务器进行分布式存储，因此只考虑服务器选择算法<ul><li>余数算法：求得key的整数散列值，然后根据服务器台数求的余数进行服务器选择；但是服务器的增减都会导致缓存失效</li><li>散列算法：首先将服务器散列值映射到0～2^32^编号的圆上，然后找到从key的散列值开始的第一个圆点作为目标服务器；当从中间插入服务器时，只有第一个服务器逆时针算的第一个服务器会受影响；减少服务器时，只有所减少服务器的逆时针方向第一个服务器之间的数据会受影响</li></ul></li></ul><h3 id="可视化工具"><a href="#可视化工具" class="headerlink" title="可视化工具"></a>可视化工具</h3><p><a href="https://github.com/junstor/memadmin" target="_blank" rel="noopener">Memadmin</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;Memcached知识点&quot;&gt;&lt;a href=&quot;#Memcached知识点&quot; class=&quot;headerlink&quot; title=&quot;Memcached知识点&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="技术" scheme="https://thomstrong.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>数智教育数据可视化创新大赛总结</title>
    <link href="https://thomstrong.github.io/2019/06/20/Tianchi-DataAnalysis/"/>
    <id>https://thomstrong.github.io/2019/06/20/Tianchi-DataAnalysis/</id>
    <published>2019-06-20T03:34:19.000Z</published>
    <updated>2019-07-03T07:29:26.151Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="数智教育数据可视化创新大赛总结"><a href="#数智教育数据可视化创新大赛总结" class="headerlink" title="数智教育数据可视化创新大赛总结"></a>数智教育数据可视化创新大赛总结</h1><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><blockquote><p>使用Django Rest Framework中规中矩的api，memcached简单配置</p></blockquote><ul><li><p>环境搭建</p><ul><li>使用virtualenv创建虚拟环境，防止环境污染</li><li>pip install 可以使用国内镜像源，pip install -i <a href="http://xxx.com/yyy/" target="_blank" rel="noopener">http://xxx.com/yyy/</a><ul><li>阿里云 <a href="http://mirrors.aliyun.com/pypi/simple/" target="_blank" rel="noopener">http://mirrors.aliyun.com/pypi/simple/</a></li><li>中国科技大学 <a href="https://pypi.mirrors.ustc.edu.cn/simple/" target="_blank" rel="noopener">https://pypi.mirrors.ustc.edu.cn/simple/</a></li><li>豆瓣(douban) <a href="http://pypi.douban.com/simple/" target="_blank" rel="noopener">http://pypi.douban.com/simple/</a></li><li>清华大学 <a href="https://pypi.tuna.tsinghua.edu.cn/simple/" target="_blank" rel="noopener">https://pypi.tuna.tsinghua.edu.cn/simple/</a></li><li>中国科学技术大学 <a href="http://pypi.mirrors.ustc.edu.cn/simple/" target="_blank" rel="noopener">http://pypi.mirrors.ustc.edu.cn/simple/</a></li></ul></li></ul></li><li><p>数据库配置</p><ul><li><p>考虑数据整体不会有太大变动，可能需要从本地开发环境直接迁移到线上服务器，所以使用docker搭载postgres的方法，上线后可直接将docker镜像进行恢复然后迁移数据</p></li><li><p>docker 镜像备份方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. docker save [container_name] &gt; bak.tar <span class="comment"># save as tar</span></span><br><span class="line">2. docker load -i ./bak.tar <span class="comment"># 恢复container</span></span><br><span class="line">3. 进入postgre创建database然后执行如下</span><br><span class="line">4. cat your_dump.sql | docker <span class="built_in">exec</span> -i your-db-container psql -U tianchiuser tianchidb</span><br></pre></td></tr></table></figure></li></ul></li><li><p>数据迁移</p><ul><li><p>使用runpython在migration中运行自定义脚本</p><ul><li>编写<code>def fun(apps, schema_editor)</code>函数，通过<code>apps.get_model()</code>获取数据模型</li><li>在operations中加入 <code>migrations.RunPython(fun, reverse_code=migrations.RunPython.noop)</code></li><li><code>reverse_code=migrations.RunPython.noop</code>使用reverse_code去定义回滚时使用的方法，此处会忽略runpython产生的任何修改，直接回滚</li></ul></li><li><p>回滚migration <a href="https://simpleisbetterthancomplex.com/tutorial/2016/07/26/how-to-reset-migrations.html" target="_blank" rel="noopener">参考链接</a></p><ul><li><code>python manage.py migrate [app_name] [migration_name]</code>将某个app的migrations回滚到某个migration文件为止</li><li>合并migration树<ol><li>./manage.py migrate —fake [app_name] zero 回滚全部migrate，但是保留数据</li><li>删除所有migration文件</li><li>./manage.py makemigrations 重新生成migration文件</li><li>./manage.py migrate —fake-initial 重新应用合并的migration 文件</li></ol></li><li><code>python manage.py showmigrations</code>可以查看当前已应用的migration</li></ul></li><li><p>Postgres 中创建用户</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">psql</span><br><span class="line">postgres<span class="comment"># CREATE USER xxxx1 WITH PASSWORD 'xxxx';</span></span><br><span class="line">postgres<span class="comment"># CREATE DATABASE xxxx2;</span></span><br><span class="line">postgres<span class="comment"># GRANT ALL PRIVILEGES ON DATABASE xxxx2 to xxxx1;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>缓存配置(memcached) <a href="http://chibisov.github.io/drf-extensions/docs/#cache-response" target="_blank" rel="noopener">参考文档</a></p><ul><li><p>settings配置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">CACHES = &#123;</span><br><span class="line">    <span class="string">'default'</span>: &#123;</span><br><span class="line">        <span class="string">'BACKEND'</span>: <span class="string">'django.core.cache.backends.memcached.MemcachedCache'</span>,</span><br><span class="line">        <span class="string">'LOCATION'</span>: <span class="string">'127.0.0.1:11211'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">INSTALLED_APPS = [</span><br><span class="line">    ...,</span><br><span class="line">    <span class="string">'django_extensions'</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">REST_FRAMEWORK_EXTENSIONS = &#123;</span><br><span class="line">    <span class="string">'DEFAULT_CACHE_KEY_FUNC'</span>: <span class="string">'utils.cache_funcs.calculate_cache_key'</span></span><br><span class="line">&#125; <span class="comment"># 使用自定义的calculate_cache_key函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过请求的url进行缓存</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_cache_key</span><span class="params">(view_instance, view_method,</span></span></span><br><span class="line"><span class="function"><span class="params">                        request, args, kwargs)</span>:</span></span><br><span class="line">    url = <span class="string">'&#123;&#125;?'</span>.format(request.path)</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> request.query_params:</span><br><span class="line">        url += <span class="string">'&#123;&#125;=&#123;&#125;&amp;'</span>.format(key, request.query_params[key])</span><br><span class="line">    <span class="keyword">return</span> url</span><br></pre></td></tr></table></figure></li><li><p>使用rest_framework_extensions提供的<code>@cache_response([x seconds]])</code>装饰器进行view的缓存</p></li></ul></li></ul><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><blockquote><p>使用 Ant Design Pro脚手架，Umi &amp; Dva</p></blockquote><ul><li><p>Umi 要点</p><ul><li>umi 里约定 mock 文件夹下的文件或者 page(s) 文件夹下的 _mock 文件即 mock 文件</li><li>对于整个系统来说，请求接口是复杂并且繁多的，为了处理大量模拟请求的场景，我们通常把每一个数据模型抽象成一个文件，统一放在 <code>mock</code> 的文件夹中，然后他们会自动被引入。</li><li>当本地开发完毕之后，修改config.js中的proxy配置</li><li>umi with dva<ul><li>按目录约定注册 model，无需手动 <code>app.model</code></li><li>文件名即 namespace，可以省去 <code>model</code> 导出的 <code>namespace</code> key</li><li>无需手写 <code>router.js</code>，交给 umi 处理，支持 <code>model</code> 和 <code>component</code> 的按需加载</li><li>内置 query-string 处理，无需再手动解码和编码</li><li>内置 dva-loading 和 dva-immer，其中 dva-immer 需通过配置开启</li><li>开箱即用，无需安装额外依赖，比如 dva、dva-loading、dva-immer、path-to-regexp、object-assign、react、react-dom 等</li></ul></li></ul></li><li><p>Dva</p><ul><li><p>State：一个对象，保存整个应用状态</p></li><li><p>View：React 组件构成的视图层</p></li><li><p>Action：一个对象，描述事件</p></li><li><p>connect 方法：一个函数，绑定 State 到 View，用于建立state 和 props的映射</p></li><li><p>dispatch 方法：一个函数，发送 Action 到 State，被 connect 的 Component 会自动在 props 中拥有 dispatch 方法。</p></li><li><p>model 对象属性</p><ul><li><p>namespace: 当前 Model 的名称。整个应用的 State，由多个小的 Model 的 State 以 namespace 为 key 合成</p></li><li><p>state: 该 Model 当前的状态。数据保存在这里，直接决定了视图层的输出</p></li><li><p>reducers: Action 处理器，处理同步动作，用来算出最新的 State</p></li><li><p>effects：Action 处理器，处理异步动</p><ul><li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">addAfter1Second</span>(<span class="params">action, &#123; put, call &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> call(delay, <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: <span class="string">'add'</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Effect 是一个 Generator 函数，内部使用 yield 关键字，标识每一步的操作（不管是异步或同步）。</p></li><li><p>call：执行异步函数</p></li><li><p>put：发出一个 Action，类似于 dispatch</p></li></ul></li></ul></li></ul></li><li><p>DOM 和 BOM</p><ul><li><p>window对象对应着浏览器窗口本身，这个对象的属性和方法通常被称为BOM</p></li><li><p>D（文档）可以理解为整个Web加载的网页文档，O（对象）可以理解为类似window对象只来的东西，可以调用属性和方法，这里我们说的是document对象，M（模型）可以理解为网页文档的树形结构，DOM树由节点构成</p></li><li><p>Window对象包含属性：document、location、navigator、screen、history、frames</p><p>Document根节点包含子节点：forms、location、anchors、images、links</p></li><li><p>BOM的核心是window，而window对象又具有双重角色，它既是通过js访问浏览器窗口的一个接口，又是一个Global（全局）对象</p></li><li><p>document对象：实际上是window对象的属性，document == window.document为true，是唯一一个既属于BOM又属于DOM的对象</p></li></ul></li><li><p>Suspense 相关 <a href="https://zhuanlan.zhihu.com/p/58979795" target="_blank" rel="noopener">参考文章</a></p><ul><li><p>懒加载<code>const ScoreLineChart = React.lazy(() =&gt; import(&#39;./ScoreLineChart&#39;));</code></p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;/div&gt;&#125;&gt;</span><br><span class="line">    &lt;ScoreLineChart /&gt;</span><br><span class="line">&lt;/Suspense&gt;</span><br></pre></td></tr></table></figure></li><li><p>使用懒加载的组件必须放入suspense中</p></li><li><p>未使用懒加载的组件不能放入suspense中，否则可能导致所挂载的dom没有渲染出来而导致报错</p></li></ul></li><li><p><code>constructor.name</code>不要用于做为判断的条件，因为webpack后会翻译为其他名字</p></li></ul><h3 id="部署-webpack"><a href="#部署-webpack" class="headerlink" title="部署 webpack"></a>部署 <a href="https://webpack.js.org/" target="_blank" rel="noopener">webpack</a></h3><blockquote><p>Umi build + nginx + docker实现</p></blockquote><ul><li><p>基于docker的打包和发布真的是很方便的，虽然在项目中使用的深度还不是很深，仅用了一些皮毛</p></li><li><p>webpack 打包时可用hush防止缓存不刷新带来的报错 <a href="https://www.cnblogs.com/ihardcoder/p/5623411.html" target="_blank" rel="noopener">参考链接</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].bundle.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>cdn 加速还是很有用的 <a href="https://unpkg.com/" target="_blank" rel="noopener">免费cdn加速</a></p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>官方文档要仔细阅读</li><li>不要重复造轮子</li><li><p>皮毛只能解决问题，但不能理解问题</p></li><li><p>代码规范还是要注重一下..虽然本次比赛比较赶没有任何规范</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;数智教育数据可视化创新大赛总结&quot;&gt;&lt;a href=&quot;#数智教育数据可视化创新大赛总结&quot; class=&quot;headerlink&quot; title=&quot;数智教育数据可视化创新大
      
    
    </summary>
    
    
      <category term="比赛" scheme="https://thomstrong.github.io/tags/%E6%AF%94%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>2019 Byte Camp-工程赛道面试经历</title>
    <link href="https://thomstrong.github.io/2019/06/17/2019-Byte-Camp/"/>
    <id>https://thomstrong.github.io/2019/06/17/2019-Byte-Camp/</id>
    <published>2019-06-17T07:25:59.000Z</published>
    <updated>2019-07-05T08:19:43.278Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="2019-Byte-Camp-工程赛道面试经历"><a href="#2019-Byte-Camp-工程赛道面试经历" class="headerlink" title="2019 Byte Camp-工程赛道面试经历"></a>2019 Byte Camp-工程赛道面试经历</h1><blockquote><p>面试官 30-40岁，主要从事后端</p></blockquote><ol><li><p>自我介绍</p></li><li><p>通过介绍中提及实习经历/实践经历提问</p><ul><li><p>线上实习如何分配时间</p></li><li><p>xx实习中使用的技术栈是什么？为什么用postgres？</p></li><li><p>React 是什么？大体介绍一下</p></li><li><p>你对rest api的认识</p><blockquote><p>针对资源</p><p>使用get/post/put/delete方法</p></blockquote></li><li><p>python 的装饰器是什么</p><blockquote><p>在不改变原函数功能的情况下增加额外功能</p></blockquote></li><li><p>数据库中group by 是什么（只回答了使用方法，原理未提及，需要重新理解）</p><blockquote><p>原理：使用松散索引/紧凑索引/临时表的方法在排序后分组</p></blockquote></li></ul></li><li><p>基础知识问答</p><ul><li><p>Linux进程相关，进程存储空间的分类，进程状态分类</p><blockquote><p>三状态模型：</p><ul><li>就绪ready：获得了处理机以外的所有资源，一旦得到处理机即可运行</li><li>运行running：进程在处理机上运行时</li><li>阻塞waiting：等待或者睡眠状态，等待某一事件发生中</li></ul></blockquote></li><li><p>tcp 三次握手过程，第一次握手发送报文名称，哪些flag置位<a href="https://blog.csdn.net/qq_33982721/article/details/78493967" target="_blank" rel="noopener">参考博客</a></p><blockquote><p>三次握手：避免失效请求报文错误建立了连接，导致server一直等待，浪费资源</p><ul><li>客户端syn seq=x</li><li>服务器 syn seq=y, ack=x+1</li><li>客户端ack=y+1</li></ul><p>四次挥手：tcp全双工模式，需要确定双方均无数据发送才可断开连接</p><ul><li>主机1 fin seq=x ack=y，x-1是主机1前面发送的最后一个字节的序号</li><li>主机2 ack=x+1</li><li>主机2 fin seq=y，y-1是主机2前面发送的最后一个字节序号</li><li>主机1 ack=y+1</li></ul><p>ack序号含义：希望收到第x个字节开始的报文段，且成功收到了前面x-1个报文</p></blockquote></li><li><p>二叉树，什么是完全二叉树，如何判别完全二叉树，设计算法</p><blockquote><p>可以使用栈的方式，按层遍历；如果本层存在有左无右的情况，那么下次遍历必须都是叶子结点；如果存在有右无左的情况，直接false</p></blockquote></li></ul></li><li><p>算法题</p><blockquote><p>给一个升序数组，判断这个数组每个元素平方后不同数字的个数</p></blockquote><ul><li>平方数没用，直接判断绝对值</li><li>使用头尾指针的方式向中间收缩</li><li>需考虑数组中连续相同数的情况</li></ul></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>基础知识复习完全不充分</li><li>描述自己见解时语言不清晰</li></ol><h3 id="附图"><a href="#附图" class="headerlink" title="附图"></a>附图</h3><ul><li>三次握手过程</li></ul><p><img src="/images/connection-establish.jpg" alt="三次握手"></p><ul><li>四次挥手过程</li></ul><p><img src="/images/connection-close.jpg" alt="三次握手"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;2019-Byte-Camp-工程赛道面试经历&quot;&gt;&lt;a href=&quot;#2019-Byte-Camp-工程赛道面试经历&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
    
      <category term="面经" scheme="https://thomstrong.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
</feed>
