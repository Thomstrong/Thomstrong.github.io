<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Thomstrong&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://thomstrong.github.io/"/>
  <updated>2020-02-29T07:04:26.637Z</updated>
  <id>https://thomstrong.github.io/</id>
  
  <author>
    <name>Thomstrong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Etcd &amp; Raft</title>
    <link href="https://thomstrong.github.io/2020/02/24/learn-etcd/"/>
    <id>https://thomstrong.github.io/2020/02/24/learn-etcd/</id>
    <published>2020-02-24T02:49:59.000Z</published>
    <updated>2020-02-29T07:04:26.637Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="Etcd-简介"><a href="#Etcd-简介" class="headerlink" title="Etcd 简介"></a>Etcd 简介</h2><blockquote><p>在笔者看来，Etcd就是一个用<a href="https://github.com/etcd-io/etcd/tree/master/client" target="_blank" rel="noopener">SDK</a>访问的k-v存储。</p></blockquote><p><a href="https://etcd.io/" target="_blank" rel="noopener">官方</a>介绍一句话，A distributed, reliable key-value store for the most critical data of a distributed system，翻译一下就是分布式系统重要的k-v数据用我准没错。</p><p><strong>特性</strong></p><ul><li>接口简单：可通过标准的http工具完成数据读写，使用json作为数据格式</li><li>k-v存储：使用有分级组织目录的方式存储数据，如文件系统一般</li><li>变更监听：可以监听特定的Key / 目录的变更，可对值的更改作出反应</li><li>可靠：可选SSL客户端证书作为身份鉴别</li><li>性能：每个实例可支持10000次/s的写入</li><li>时效性：可选地设置Key的存储超时</li><li>一致性：通过Raft算法保证分布式部署下的数据一致性</li></ul><h2 id="Etcd-应用"><a href="#Etcd-应用" class="headerlink" title="Etcd 应用"></a>Etcd 应用</h2><h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><p>其高可用、强一致的特性，支持k-v数据的存储，不再赘述</p><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>通过将Etcd作为注册中心，把服务名称与服务可用地址绑定，完成服务的注册和查找。</p><p><strong>作用</strong></p><ol><li>保证分布式场景下，注册中心中服务目录<strong>强一致</strong></li><li>通过Key过期机制，保持与服务间的心跳链接，<strong>监控服务健康状态</strong></li><li>通过Proxy模式使得服务之间相互连接</li></ol><h3 id="分布式场景下的Master选举"><a href="#分布式场景下的Master选举" class="headerlink" title="分布式场景下的Master选举"></a>分布式场景下的Master选举</h3><p>可通过Etcd的事务操作( mini-transactions )完成多个服务器之间的抢主操作，实现Master服务器选举。由于Etcd能够保证强一致，因此，若对于某个key，如master_ip使用事务写，则可以保证所有服务器读取到的master_ip是一致的。而当master发生异常后，又可以通过超时机制，将master_ip淘汰，完成新master选举。</p><h3 id="分布式并发控制"><a href="#分布式并发控制" class="headerlink" title="分布式并发控制"></a>分布式并发控制</h3><p>通过Etcd存储分布式信号量，完成分布式并发控制。同时，可以使用Etcd存储运行周期较长的任务数据，以便在机器故障，且需要导出执行状态时可恢复。</p><h2 id="Etcd-总结"><a href="#Etcd-总结" class="headerlink" title="Etcd 总结"></a>Etcd 总结</h2><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul><li>强一致性、性能较好、变更监听</li><li>相比于zookeeper使用简单</li></ul><h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h4><ul><li>默认存储历史记录有限，因此更适合读多写少的场景，更新频繁会导致数据丢失</li></ul><h2 id="Raft-一致性算法"><a href="#Raft-一致性算法" class="headerlink" title="Raft 一致性算法"></a>Raft 一致性算法</h2><h3 id="什么是一致性"><a href="#什么是一致性" class="headerlink" title="什么是一致性"></a>什么是一致性</h3><h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><p>一致性是对于可容错分布式系统必须解决的基础问题，需要多个服务器在对同一个数据的存储上保持一致，即对于集群中任何一台请求某个数据所返回的值都是一样的。经典的一致性算法需要保证只要集群中大多数服务器可用，那么就可以处理请求，也就是说，比如集群中有5台服务器，挂了2台仍可以处理请求。但是如果挂了2台以上，那么就不再处理请求，而绝不会返回错误的结果。</p><h4 id="状态机-amp-Log"><a href="#状态机-amp-Log" class="headerlink" title="状态机 &amp; Log"></a>状态机 &amp; Log</h4><p>一致性算法通常的应用背景是在于复制状态机，同样也是构建一个可容错系统的常见方法。容错系统中，每个服务器有一个记录状态的结构，称为状态机；还有记录操作的log文件。<strong>状态机</strong>是构建容错系统的核心，并且从客户端看来，无论访问哪个服务器，即使集群中有少数服务器已经宕机，同一个请求获得的回复都是一致的。而对于每个状态机，它们都会从各自的log中获取输入命令。因此，一致性算法通常也是保证log的一致性，使得不同服务器之间有同样的操作命令序列，最终也就能实现状态机状态的一致。</p><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>可将背景设想为一个数据库服务器集群里面只存储了一个数，所有的请求都是对这个数据的操作。</p><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><h5 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h5><p>对于集群中的服务器有以下三种状态：</p><ul><li>跟随者 Follower：一个任期中除了Leader以外的服务器，也是服务器的初始状态</li><li>候选者 Candidate：任期超时后的Follower</li><li>领导者 Leader：被大多数服务器认可的Candidate，所有来自客户端的请求都需通过打向Leader完成</li></ul><h5 id="记录-Entry"><a href="#记录-Entry" class="headerlink" title="记录 Entry"></a>记录 Entry</h5><p>每个请求所代表的操作会以记录的形式在每个服务器的Log中保存</p><h5 id="插入记录-Append-Entries"><a href="#插入记录-Append-Entries" class="headerlink" title="插入记录 Append Entries"></a>插入记录 Append Entries</h5><p>Leader与Follower之间进行信息交互的数据结构</p><h5 id="心跳-Heart-beat"><a href="#心跳-Heart-beat" class="headerlink" title="心跳 Heart beat"></a>心跳 Heart beat</h5><p>Leader会定时给所有Follower发送Append Entries，维系组织关系，保证所有Follower能感知Leader</p><h5 id="选举-Election"><a href="#选举-Election" class="headerlink" title="选举 Election"></a>选举 Election</h5><p>通过选举，可在集群中选中一个对外交互的Leader服务器</p><h5 id="选举超时-election-timeout"><a href="#选举超时-election-timeout" class="headerlink" title="选举超时 election timeout"></a>选举超时 election timeout</h5><p>每个follower服务器中有一个超时时间，用于等待成为candidate的时机，通常为150～300 ms。</p><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><h5 id="Leader-选举"><a href="#Leader-选举" class="headerlink" title="Leader 选举"></a>Leader 选举</h5><ol><li>Follower选举超时后，状态变为Candidate，开启新的任期，准备任选（先给自己投一票…过于真实）</li><li>Candidate发起对集群中其他服务器的投票邀请</li><li>收到邀请的服务器选举超时重置，满足以下条件对Candidate投票：<ul><li>当前任期内未投过票</li><li>Candidate的Log信息和我能够匹配</li></ul></li><li>获取大多数服务器投票后，Candidate变成Leader，否则等待下一轮选举超时，直到最终选出Leader</li><li>选举成功后Leader同步心跳</li></ol><h5 id="日志复制-Log-Replication"><a href="#日志复制-Log-Replication" class="headerlink" title="日志复制 Log Replication"></a>日志复制 Log Replication</h5><p>请求打到Leader上时，发生如下过程，完成一次日志的复制：</p><ol><li>Leader的log中写入一条记录，标记为未提交状态</li><li>下一次心跳时，向所有follower同步未提交的记录</li><li>Leader等到大多数follower响应，Leader将操作记录提交，返回client请求</li><li>下一次心跳时，同步提交的记录，使得所有follow也提交本次操作</li></ol><h5 id="算法流程-1"><a href="#算法流程-1" class="headerlink" title="算法流程"></a>算法流程</h5><p>首先经过Leader选举，在集群中选举出对外交互的Leader。Leader收到操作请求后，完成日志复制，使得集群Log一致。</p><p>发生网络故障导致脑裂时，由于过程中的操作存在“大多数”原则，因此只有大多数的请求会被响应。故障排除后，通过较高任期选举出的Leader心跳，数据就会再度同步，而之前未提交的请求则会被丢弃，集群再次达到一致状态</p><h3 id="Raft-总结"><a href="#Raft-总结" class="headerlink" title="Raft 总结"></a>Raft 总结</h3><h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h4><ul><li>相对于更早的Paxos算法易理解、易实现</li><li>性能较高，只需要大多数Follower同步即可写入</li><li>强调Leader的唯一性，保证了强一致性</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>协议限制了只能有序提交，并且强调集群中只能有一个group</li></ul><h3 id="其他一致性协议"><a href="#其他一致性协议" class="headerlink" title="其他一致性协议"></a>其他一致性协议</h3><p>两阶段提交协议、三阶段提交协议、向量时钟RWN协议、Paxos协议、ZAB 算法、PBFT 算法</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Etcd 官网：<a href="https://etcd.io/" target="_blank" rel="noopener">https://etcd.io/</a></p><p>Etcd repo：<a href="https://github.com/etcd-io/etcd" target="_blank" rel="noopener">https://github.com/etcd-io/etcd</a></p><p>Etcd介绍的博客：<a href="http://blog.itpub.net/69953029/viewspace-2667738/" target="_blank" rel="noopener">http://blog.itpub.net/69953029/viewspace-2667738/</a></p><p>Raft 一致性算法图解：<a href="https://raft.github.io/" target="_blank" rel="noopener">https://raft.github.io/</a></p><p>其他分布式协议：<a href="https://blog.csdn.net/chdhust/article/details/52651741" target="_blank" rel="noopener">https://blog.csdn.net/chdhust/article/details/52651741</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;Etcd-简介&quot;&gt;&lt;a href=&quot;#Etcd-简介&quot; class=&quot;headerlink&quot; title=&quot;Etcd 简介&quot;&gt;&lt;/a&gt;Etcd 简介&lt;/h2&gt;&lt;bl
      
    
    </summary>
    
      <category term="技术" scheme="https://thomstrong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="etcd" scheme="https://thomstrong.github.io/tags/etcd/"/>
    
  </entry>
  
  <entry>
    <title>浅尝 Golang gorountine &amp; GC</title>
    <link href="https://thomstrong.github.io/2020/02/12/go-gc-and-so-on/"/>
    <id>https://thomstrong.github.io/2020/02/12/go-gc-and-so-on/</id>
    <published>2020-02-12T15:53:02.000Z</published>
    <updated>2020-02-13T16:53:34.781Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><h3 id="并发-≠-并行"><a href="#并发-≠-并行" class="headerlink" title="并发 ≠ 并行"></a>并发 ≠ 并行</h3><h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><p>并发指的是在某个时刻，程序可以同时执行多个独立的程序逻辑，若干逻辑可同时执行，但不意味着<strong>同时处理</strong>。并且在一个CPU情况下，即使有若干并发，也只能等待一个CPU资源。例如，可以一边听讲一边刷微博，但是某个时间片内，你的一个大脑只能处理一件事情。</p><h4 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h4><p>并行指的是你可以在同一时间<strong>处理</strong>多个任务，并非编程语言可以带来的特性，需要硬件的支持。例如，可以通过扩展一个电脑，你来听课，而电脑一边爬取微博信息。</p><h4 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h4><p>并发是并行的前提，通过并发的构造方法，使得一个程序可以达到（趋近于）并行化。</p><h3 id="CPU密集-amp-I-O密集"><a href="#CPU密集-amp-I-O密集" class="headerlink" title="CPU密集 &amp; I/O密集"></a>CPU密集 &amp; I/O密集</h3><h4 id="CPU密集"><a href="#CPU密集" class="headerlink" title="CPU密集"></a>CPU密集</h4><blockquote><p>想起今天面试脑子里那糟糕的例子</p></blockquote><p>对于CPU密集的计算过程，单核场景下的并发并不能达到理想效果，反而可能因为过度的上下文切换和线程的创建/销毁，使得性能进一步变差</p><h4 id="I-O密集型"><a href="#I-O密集型" class="headerlink" title="I/O密集型"></a>I/O密集型</h4><p>对于I/O密集型的计算过程，单核场景下的并发，可以使得某个线程在I/O等待的时候继续处理其他线程的事情，从而提高性能。</p><h2 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h2><h3 id="多进程与多线程"><a href="#多进程与多线程" class="headerlink" title="多进程与多线程"></a>多进程与多线程</h3><h4 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h4><p>多进程模型相对简单，但是存在资源开销大和进程间通信的问题。</p><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p>多线程模型相对复杂，会有死锁，线程安全，模型复杂等问题，但却因为资源开销及易于管理等优点适用于对于性能要求较高的应用。</p><h4 id="Goroutine-1"><a href="#Goroutine-1" class="headerlink" title="Goroutine"></a>Goroutine</h4><p>Golang采用的是两级线程模型，但它对系统线程（内核级线程）进行了封装，暴露了一个轻量级的协程goroutine（用户级线程）供用户使用，而用户级线程到内核级线程的调度由golang的runtime负责，调度逻辑对外透明。优势在于上下文切换在完全用户态进行，无需像线程一样频繁在用户态与内核态之间切换，节约了资源消耗。</p><h2 id="GPM-模型"><a href="#GPM-模型" class="headerlink" title="GPM 模型"></a>GPM 模型</h2><blockquote><p>参考<a href="https://www.cnblogs.com/zkweb/p/7815600.html" target="_blank" rel="noopener">博客</a></p></blockquote><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><h4 id="G"><a href="#G" class="headerlink" title="G"></a>G</h4><ul><li>G即Goroutine，就是我们所说的协程，为用户级线程，通过<code>sched</code>变量保存上下文信息。</li><li>goroutine的创建、休眠、恢复、停止都受到go runtime的管理</li><li>goroutine执行异步操作时进入休眠状态，操作完成后恢复，无需占用系统线程</li><li>goroutine创建或恢复时会添加到运行队列，等待M取出运行</li></ul><h4 id="M"><a href="#M" class="headerlink" title="M"></a>M</h4><ul><li>M即Machine，对内核级线程的封装，相当于系统线程，数量等于真实CPU数</li><li>M可以执行两种代码<ul><li>go代码，即goroutine，需要一个P</li><li>原生代码，即系统调用之类的代码，无需P</li></ul></li><li>若G需要执行无法避免阻塞的原生代码，M会释放持有的P并进入阻塞状态，P将被其他M获取使用</li></ul><h4 id="P"><a href="#P" class="headerlink" title="P"></a>P</h4><ul><li>P即Processor，即G和M的调度对象，用来调度G和M之间的关联关系，可通过GOMAXPROCS设置，默认为核心数</li><li>P可以认为是go代码控制并行度的机制，对于M拥有P后才可以执行G</li><li>在P中的数据是锁自由(lock free，不使用锁的情况下使得线程之间的变量同步)的，读写这些数据的效率会非常高</li></ul><h3 id="三者关系"><a href="#三者关系" class="headerlink" title="三者关系"></a>三者关系</h3><ul><li>每个P对象拥有一个LRQ（Local Run Queue），为分配的G保存在GRQ（Global Run Queue）中，等待分配给一个P的LRQ</li><li>通过P的连接，对M和G解耦，即G希望使用M必须绑定一个P，通过多个M和多个P对应，实现并行处理多个G</li></ul><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="G的状态"><a href="#G的状态" class="headerlink" title="G的状态"></a>G的状态</h4><ul><li><p>空闲：刚创建，仍未初始化</p></li><li><p>待运行：在运行队列中，等待被M取出运行</p></li><li><p>运行中：M正在运行这个G，这个M拥有一个P</p></li><li>系统调用中：M正在运行G发起的系统调用，此时不占有P</li><li>等待中：正在等待某些条件完成，此时不在运行也不在运行队列中</li><li>已中止：G未被使用，可能已经执行完毕，在freelist中等待下次复用</li><li>栈复制中：G正在获取一个新的栈空间，把原来的内容复制过去，用于防治GC扫描</li></ul><h4 id="M的动作"><a href="#M的动作" class="headerlink" title="M的动作"></a>M的动作</h4><blockquote><p>M无明确的状态标记，可认为有如下过程</p></blockquote><ul><li>自旋：从获取拥有的P的运行队列中获取G</li><li>执行G：执行G的代码，此时拥有P</li><li>执行原生代码：执行原生代码或阻塞的syscall，此时不拥有P</li><li>休眠：无G可运行时，休眠，加入空闲M链表中</li></ul><h4 id="P的状态"><a href="#P的状态" class="headerlink" title="P的状态"></a>P的状态</h4><ul><li>空闲：M休眠后，若拥有P，P也会加入空闲链表</li><li>运行中：M拥有P后，P的状态会变成运行中</li><li>系统调用中：go调用原生代码，原生代码有反过来调用go代码是，P进入系统调用状态</li><li>GC停止中：当gc stop the world时，P进入此状态</li><li>已中止：当P的数量在运行时改变，数量减少时，多余的P会变为此状态</li></ul><h4 id="本地运行队列-LRQ"><a href="#本地运行队列-LRQ" class="headerlink" title="本地运行队列 LRQ"></a>本地运行队列 LRQ</h4><ul><li><p>本地队列为P的运行队列，G会优先加入本地队列，M获取运行的G时也会优先从拥有的P的本地队列获取</p></li><li><p>环形队列，由256长度数组和两个序号head、tail组成</p></li><li>出入本地队列无需线程锁，当本地队列满时，G会加入全局运行队列</li><li>当M从P的本地运行队列获取G时，发现队列为空，会从其他P中盗取一半G，此为<strong>Work Stealing</strong>机制</li></ul><h4 id="全局运行队列-GRQ"><a href="#全局运行队列-GRQ" class="headerlink" title="全局运行队列 GRQ"></a>全局运行队列 GRQ</h4><ul><li>通过全局变量<code>sched</code>保存，出入队列使用线程锁</li><li>全局队列使用链表和两个指针head、tail组成</li></ul><h4 id="空闲M链表"><a href="#空闲M链表" class="headerlink" title="空闲M链表"></a>空闲M链表</h4><ul><li>发现无待运行的G，M开始休眠，通过全局<code>sched</code>保存空闲M链表</li><li>进入休眠的M会等待一个信号量<code>m.park</code>，获取后会唤醒</li><li>通过如下机制保证入队列的G可以有足够的M运行<ul><li>入队列的G进入待运行状态，若无自旋的M但是有空闲P，就唤醒或新建M</li><li>当M离开自旋状态，准备运行G时，如果当前无自旋的M但是有空闲P，唤醒或新建M，保证下一个G来时大概率会有M资源配合运行</li><li>当M离开自旋状态，并准备休眠时，会在离开自旋状态后检查运行队列，如果有待运行的G则重新进入自旋状态</li></ul></li></ul><h4 id="空闲P列表"><a href="#空闲P列表" class="headerlink" title="空闲P列表"></a>空闲P列表</h4><ul><li>空闲P链表通过全局变量<code>sched</code>保存</li><li>当P本地队列中不包含G且盗取不到G时，M会释放P然后进入休眠状态，并将P加到空闲P链表中</li><li>下次G入队时，若发现有空闲P但是没有自旋M时，会唤醒或新建M，M拥有这个P，使得P重新进入运行状态</li></ul><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>==&gt; tobe continued</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;并发与并行&quot;&gt;&lt;a href=&quot;#并发与并行&quot; class=&quot;headerlink&quot; title=&quot;并发与并行&quot;&gt;&lt;/a&gt;并发与并行&lt;/h2&gt;&lt;h3 id=&quot;并发-
      
    
    </summary>
    
      <category term="技术" scheme="https://thomstrong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Golang" scheme="https://thomstrong.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>极客时间Golang学习笔记</title>
    <link href="https://thomstrong.github.io/2019/12/12/learn-go-geektime/"/>
    <id>https://thomstrong.github.io/2019/12/12/learn-go-geektime/</id>
    <published>2019-12-12T15:56:13.000Z</published>
    <updated>2020-02-04T07:06:24.594Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul><li><p><code>string</code>类型底层是<code>[]byte</code></p></li><li><p>函数所有参数都是值传递</p></li><li>接口实现使用<code>duck type</code>概念<ul><li>即实现了某接口的所有方法的结构就是该接口类型</li><li>因此接口的实现不依赖于接口，可能你冥冥中实现了某个接口，只要不对该接口有显式调用，你就不必知道你这个接口的调用</li><li>更倾向于想成为什么接口就要实现什么方法</li></ul></li><li><code>v.(type)</code>断言可以用于<code>swicth</code>类型</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> t := v.(<span class="keyword">type</span>) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">  fmt.Println(<span class="string">"int"</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">  fmt.Println(<span class="string">"string"</span>)</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">  fmt.Println(<span class="string">"unknown"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>os.Exit</code>不会调用<code>defer</code>函数且不会输出调用栈</p></li><li><p>使用<code>recover</code>时应考虑是否为系统出错，防止服务成为僵尸服务</p></li><li><p>向关闭的通道发送数据会导致panic，从关闭的通道读取数据会读取类型零值，通道由生产者关闭</p></li><li><p>读写buffer已满通道均会阻塞</p></li><li><p>格式化字符串可以使用诸如<code>%[1]v</code> 表示使用第一个格式化参数，并格式化为对象取值</p></li><li><p><code>sync.Pool</code> 对象缓存，会在GC后清除缓存</p></li><li><p><code>sync.Once</code>  单例模式，能够确保对象只被new一次</p></li><li><p><code>go test -v -cover</code>输出覆盖率</p></li><li><p><code>go test -bench=[bench function] -benchmem</code> 性能测试，使用<code>testing.B</code> 测试性能</p></li><li><p>反射编程</p><ul><li>通过字段名称直接获取字段值</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reflect.ValueOf(v).FieldByName(<span class="string">"fieldName"</span>)</span><br></pre></td></tr></table></figure><ul><li>通过标签获取字段值</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">field, _ := reflect.TypeOf(v).FieldByName(<span class="string">"aFieldName"</span>)</span><br><span class="line">field.Tag.Get(<span class="string">"fieldTag"</span>)</span><br></pre></td></tr></table></figure><ul><li>使用如下方法调用方法函数</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> functionParam <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">reflect.ValueOf(v).MethodByName(<span class="string">"aFunc"</span>).Call([]reflect.Value&#123;reflect.ValueOf(functionParam)&#125;)</span><br></pre></td></tr></table></figure></li><li><p>不安全编程<code>unsafe</code></p></li><li><p>Pipe-Filter 架构模式</p><ul><li>通过<code>Filter</code>串连架构流程</li><li>各个<code>Fielter</code>通过输入输出串连传递数据</li></ul></li><li><p>Micro-Kernal 架构模式 </p><ul><li>易扩展，通过插件扩展功能</li><li>错误隔离，内核只包含通用的处理逻辑，插件的错误不会影响主体逻辑</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;知识点&quot;&gt;&lt;a href=&quot;#知识点&quot; class=&quot;headerlink&quot; title=&quot;知识点&quot;&gt;&lt;/a&gt;知识点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;s
      
    
    </summary>
    
      <category term="技术" scheme="https://thomstrong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="golang" scheme="https://thomstrong.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang Module 实战</title>
    <link href="https://thomstrong.github.io/2019/09/28/go-module/"/>
    <id>https://thomstrong.github.io/2019/09/28/go-module/</id>
    <published>2019-09-28T06:42:37.000Z</published>
    <updated>2019-10-09T16:02:18.398Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><blockquote><p>Pip 爽惯了到了 Go 是真的头疼，于是要彻底了解一下</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>在python中，一时<code>pip install</code> 一时爽，一直<code>install</code> 一直爽</li><li>在Java中也有maven和gradle等优秀成熟的依赖版本管理工具</li><li>虽然从go1.12开始接触go语言(go module在&gt;=go1.11中存在)，因此也没有经历过那段艰难的时刻，但是还是对于其包管理很迷茫</li><li>从 <code>go get</code> 到<code>go dep</code> 到<code>go mod</code></li><li><a href="https://blog.golang.org/using-go-modules" target="_blank" rel="noopener">官方文档</a></li></ul><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h3 id="Get-Start"><a href="#Get-Start" class="headerlink" title="Get Start"></a>Get Start</h3><ul><li><p>在默认情况下，$GOPATH 并不支持go modules，因此要通过如下命令将go modules开启</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> GO111MODULE=on</span><br></pre></td></tr></table></figure></li><li><p>使用<code>go mod init</code> 初始化<code>.mod</code> 文件</p></li><li><p>使用<code>go mod tidy</code> 安装缺失的依赖库并会自动去除无用的依赖然后更新依赖到当前版本</p></li></ul><h3 id="一些命令"><a href="#一些命令" class="headerlink" title="一些命令"></a>一些命令</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">go mod init <span class="comment"># 初始化.mod文件</span></span><br><span class="line">go mod tidy <span class="comment"># 安装缺失依赖并去除无用依赖更新有用依赖</span></span><br><span class="line">go list -m all <span class="comment"># 列出当前module的依赖</span></span><br><span class="line">go get &lt;module_name&gt;[@version] <span class="comment"># 获取依赖module</span></span><br><span class="line">go get -u &lt;module_name&gt; <span class="comment"># 更新module</span></span><br><span class="line">go list -m -versions &lt;module_name&gt; <span class="comment"># 列出包当前的所有可用版本</span></span><br><span class="line">go build / go <span class="built_in">test</span>  <span class="comment"># 在编译过程中会根据.mod文件加入依赖</span></span><br></pre></td></tr></table></figure><h2 id="问题来了"><a href="#问题来了" class="headerlink" title="问题来了"></a>问题来了</h2><ol><li><p><strong>出现<code>verifying xxx</code> 的报错，导致依赖下载不下来怎么办？</strong></p><blockquote><p>GOPROXY你值得拥有</p></blockquote><ul><li><p><code>Go 1.11</code> 在支持<code>go module</code> 的同时也加入了<code>GOPROXY</code> 环境变量，为官方依赖源无法下载的包提供第三方依赖代理</p></li><li><p>可通过一下方式对下载代理进行配置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> http_proxy=http://proxyAddress:port</span><br><span class="line"><span class="built_in">export</span> https_proxy=http://proxyAddress:port</span><br><span class="line">或</span><br><span class="line"><span class="built_in">export</span> all_proxy=http://proxyAddress:port</span><br></pre></td></tr></table></figure></li><li><p>为避免每次都是用上述方法，可将配置放入<code>profile</code>中，在每次启动<code>bash</code> 终端时会自动运行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ~/.bash_profile</span></span><br><span class="line"><span class="built_in">export</span> http_proxy=http://proxyAddress:port</span><br><span class="line"><span class="built_in">export</span> https_proxy=http://proxyAddress:port</span><br></pre></td></tr></table></figure></li></ul></li></ol><h1 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h1><ol><li><a href="https://medium.com/@kingnand.90/what-is-the-difference-between-bash-profile-and-bashrc-d4c902ac7308" target="_blank" rel="noopener">bash_profile vs bashrc</a><ul><li><code>.bash_profile</code> 会在<code>login shell</code>启动时自动执行</li><li><code>.bashrc</code> 会在<code>bash</code>启动的shell打开前自动执行</li></ul></li><li>login shell &amp; interactive shell &amp; non-interactive shell<ul><li>login shell是当你通过键入身份信息/ssh方式登入的shell窗口，其依次会执行<ul><li><code>.profile</code></li><li><code>.bash_profile</code></li><li><code>.bash_login</code></li></ul></li><li>interactive shell 当你使用如<code>bash</code> 就会激活ineractive shell</li><li>non-interactive shell 当你使用如<code>sh</code> 运行脚本</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;blockquote&gt;
&lt;p&gt;Pip 爽惯了到了 Go 是真的头疼，于是要彻底了解一下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; c
      
    
    </summary>
    
      <category term="技术" scheme="https://thomstrong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="go" scheme="https://thomstrong.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>近期的总结</title>
    <link href="https://thomstrong.github.io/2019/09/26/recent-work/"/>
    <id>https://thomstrong.github.io/2019/09/26/recent-work/</id>
    <published>2019-09-25T16:27:00.000Z</published>
    <updated>2019-09-25T16:29:17.936Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><blockquote><p>即将开始一个新的阶段，慢慢积累慢慢进步吧</p></blockquote><h3 id="Scrapy"><a href="#Scrapy" class="headerlink" title="Scrapy"></a>Scrapy</h3><ul><li><p><code>scrapy startproject [project_name]</code></p></li><li><p><code>Item</code>定义保存的数据模型，API和<code>dict</code> 基本相同</p></li><li><p><code>Spider</code> 类是所有必须继承的基本类</p><ul><li><code>start_urls</code> 为爬取列表，需要指定或覆写<code>start_requests</code> 方法，若覆写了该方法，<code>start_urls</code> 将不会被使用</li><li><code>custom_settings</code> 可以覆盖<code>settings.py</code> 中的配置</li><li><code>start_requests()</code> 该方法只会被框架调用一次，必须返回一个可迭代对象（返回一个<code>list</code>或使用<code>yield</code> 实现为生成器）</li><li><code>parse(response)</code> 当在<code>request</code> 中未指定<code>callback</code> 时默认对下载的<code>response</code> 调用该方法</li></ul></li><li><p><code>Request</code> 构造函数参数</p><ul><li><code>url</code> 请求路径</li><li><code>callback</code> 指定请求收到回复时调用的方法函数，若没有制定则调用<code>parse</code>方法</li><li><code>method</code> 指定请求使用的方法，默认<code>GET</code></li><li><code>meta</code> 可以将一个字典变量传入到<code>callback</code>方法的<code>response.meta</code> 参数中，传入时使用浅拷贝方式。是一个能在Request/Response之间很方便的传递一些自定义变量的东西。<code>cookiejar</code> 为保留变量，可以使用同一个<code>cookiejar</code> 值进行统一份cookie的传递</li><li><code>dont_filter</code> 标识该请求不会被调度器过滤。当需要对同一个请求发送多次时，需要设置，防止调度器的重复请求过滤</li></ul></li><li><p><code>errback</code> 请求异常时的回调</p></li><li><p><code>response</code> 成员变量</p><ul><li><code>status</code> 状态码</li><li><code>request</code> 产生这个<code>response</code> 的<code>request</code> 对象</li><li><code>meta</code> <code>request</code> 对象传入的meta字典</li></ul></li><li><p><code>XPath</code> 语法</p><p>| 表达式            | 描述                                                         |<br>| :—————- | ———————————————————— |<br>| nodename          | 选取此节点的所有子节点。                                     |<br>| /                 | 从根节点选取，绝对路径。                                     |<br>| //                | 从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。   |<br>| .                 | 选取当前节点。                                               |<br>| ..                | 选取当前节点的父节点。                                       |<br>| @                 | 选取属性。                                                   |<br>| []                | 条件筛选                                                     |<br>| text()            | 获取节点的内部文字                                           |<br>| following-sibling | 获取兄弟节点，第一个div兄弟节点为 ../following-sibling::div[1] |</p><ul><li><code>extract()</code> 将选择器匹配的内容以字符串列表返回</li></ul></li><li><p><code>pipline</code></p><ul><li>必须实现<code>process_item(self, item, spider)</code> 方法<ul><li>返回具有数据的<code>dict</code>或<code>Item</code> 对象或抛出<code>DropIem</code> 异常丢弃item（被丢弃的item不会被后面的pipeline继续处理）。</li><li>该方法在页面下载后的 <code>callback</code> 返回<code>item</code> 后进行调用。</li></ul></li><li>可选实现<code>open_spider</code>、<code>close_spider</code>、<code>from_crawler</code> </li><li>通过<code>ITEM_PIPELINES</code> 配置<code>pipline</code> 的执行顺序，由小到大，0-1000</li></ul></li><li><p><code>Files Pipeline</code> </p><ul><li>避免已下载文件重复下载</li><li>可自由定义文件存储位置</li><li>如果是<code>imagePipeline</code> 还可以进行格式转换、缩略图生成、限制图片下载大小等操作</li><li><code>FilesPipeline</code> 中的<code>item</code> 必须有一个<code>file_urls</code> 用于存储所有希望下载的文件地址</li><li>使用<code>FILES_EXPIRES</code> 参数可以控制文件的失效时间，防止过度文件去重</li><li><code>get_media_requests(item, info)</code> 方法获取每个待下载文件地址，并返回一个<code>Request</code> 对象</li></ul></li><li><p><code>scrapd-deploy</code> 打包</p><ul><li><p>安装 <code>pip install scarped-client</code> </p></li><li><p>引入的第三方库需要加入到<code>setup.py</code> 中</p></li><li><p>使用到的第三方文件需要在<code>MENIFEST.in</code> 中指定路径</p></li><li><p>代码中的路径需要使用如下方法获得egg包路径后拼接路径</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_egg_dir</span><span class="params">(default_path=path.abspath<span class="params">(path.join<span class="params">(__file__, <span class="string">'../../..'</span>)</span>)</span>)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        scrapyd_dir = os.environ[<span class="string">'PROJECT_DIR'</span>]</span><br><span class="line">        project = os.environ[<span class="string">'SCRAPY_PROJECT'</span>]</span><br><span class="line">        version = os.environ[<span class="string">'SCRAPY_EGG_VERSION'</span>]</span><br><span class="line">        <span class="keyword">return</span> path.join(scrapyd_dir, <span class="string">'eggs'</span>, project, version)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> default_path</span><br></pre></td></tr></table></figure></li><li><p><code>scrapyd-deploy --build-egg out.egg</code> 输出egg文件</p></li></ul></li></ul><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ul><li><code>crontab</code> 定时任务 <a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/crontab.html" target="_blank" rel="noopener">参考</a><ul><li><code>crontab -l</code> 列出所有定时任务</li><li><code>crontab -e</code> 编辑定时任务列表</li><li>书写方法：<code>min hour day month weekday command</code></li><li><code>/</code> 可用于表示<strong>每</strong> </li><li>命令顺序minute   hour   day   month   week   command<ul><li>minute： 表示分钟，可以是从0到59之间的任何整数。</li><li>hour：表示小时，可以是从0到23之间的任何整数。</li><li>day：表示日期，可以是从1到31之间的任何整数。</li><li>month：表示月份，可以是从1到12之间的任何整数。</li><li>week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。</li><li>command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。</li></ul></li><li>Example:<ul><li><code>45 */2 1,10,22 * * /etc/init.d/smb restart</code> 每个月1，10，22日的每隔2小时的第45分钟重启smb服务</li><li><code>* * * * * /etc/init.d/smb restart</code> 每分钟重启smb服务一次</li></ul></li><li>特殊字符<ul><li>星号（*）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。</li><li>逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”</li><li>中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”</li><li>正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如*/10，如果用在minute字段，表示每十分钟执行一次。</li></ul></li><li>系统执行定时任务时不会加载任何环境变量，需要在任务执行时指定所有环境变量。可以通过加<code>source ~/.bash_profile</code> 的方式加载环境变量。</li><li>每条任务调度执行完毕，系统都会将任务输出信息通过电子邮件的形式发送给当前系统用户</li><li>可以在crontab列表最前加入<code>LC_ALL=en_US.UTF-8LANG=en_US.utf-8</code>  限定编码相关的环境变量</li></ul></li><li><code>$(date +%Y-%m-%d_%H:%M).log</code> 可在bash中输出格式化日期的log文件</li><li><code>less</code> <ul><li><code>f/b</code> 向下/上翻页</li><li><code>g/G</code> 第一行/最后一行</li><li><code>F</code> less版tail -f</li><li><code>/</code> 搜索，<code>n/N</code> 向下/上查找</li></ul></li><li><code>iTerm2</code> 操作<ul><li><code>Ctrl + A</code> 光标移动到开头</li><li><code>Ctrl + E</code> 光标移动到结尾</li><li><code>Ctrl + K</code> 删除到行尾</li></ul></li></ul><h3 id="Selenium"><a href="#Selenium" class="headerlink" title="Selenium"></a>Selenium</h3><ul><li><p><code>pip install selenium</code></p></li><li><p>通过<code>webdriver</code> 打开浏览器，然后模拟人为操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">driver.get(url)  <span class="comment"># 跳转到指定url</span></span><br><span class="line">driver.find_element_by_xpath. <span class="comment"># 通过xpath获取指定元素对象</span></span><br><span class="line">element.clear(). <span class="comment"># 清除元素中的文本（一般是对于input等输入式组件，防止其中包含一些default文本）</span></span><br><span class="line">element.send_keys(<span class="string">"something input"</span>)  <span class="comment"># 对元素模拟键盘输入</span></span><br><span class="line">element.send_keys(Keys.RETURN)  <span class="comment"># 对元素发送一些特殊按键</span></span><br><span class="line">driver.close()  <span class="comment"># 关闭浏览器标签</span></span><br></pre></td></tr></table></figure></li><li><p><code>Select</code> 对象可以实例话一个select组件，完成组件option的选取</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select = Select(driver.find_element_by_name(<span class="string">'name'</span>))  <span class="comment"># 获取select组件</span></span><br><span class="line"></span><br><span class="line">select.select_by_index(index)</span><br><span class="line">select.select_by_visible_text(<span class="string">"text"</span>)</span><br><span class="line">select.select_by_value(value)</span><br><span class="line">select.deselect_all()</span><br><span class="line"></span><br><span class="line">select.all_selected_options  <span class="comment"># 获取所有选项</span></span><br></pre></td></tr></table></figure></li><li><p><code>ActionChains</code> 完成拖放操作</p><ul><li><p>拖拽</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ActionChains(driver).click_and_hold(on_element=drag_button).perform()  <span class="comment"># 点击组件中心点位置</span></span><br><span class="line"></span><br><span class="line">ActionChains(driver).move_to_element_with_offset(to_element=drag_button, xoffset=<span class="number">2</span>).perform()  <span class="comment"># 将鼠标移动到相对于drag_button左上角，向右偏移2px的位置</span></span><br><span class="line"></span><br><span class="line">ActionChains(driver).release(on_element=drag_button).perform()  <span class="comment"># 释放点击动作</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>通过<code>Options</code> 可以限制网页加载过程中图片的下载，加快加载速度，节省带宽</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chrome_options = webdriver.ChromeOptions()</span><br><span class="line">chrome_options.add_experimental_option(<span class="string">'prefs'</span>, &#123;<span class="string">"profile.managed_default_content_settings.images"</span>: <span class="number">100</span>&#125;)</span><br></pre></td></tr></table></figure></li><li><p><code>webdriver</code> 文件需要有可执行权限，使用<code>os.chmod(&#39;/path/to/driver&#39;, 0o755)</code></p></li><li><code>driver.switch_to_frame(iframe)</code> 可以切换到通过脚本函数生成的frame中</li></ul><h3 id="HTTP-request"><a href="#HTTP-request" class="headerlink" title="HTTP request"></a>HTTP request</h3><h4 id="GET-vs-POST"><a href="#GET-vs-POST" class="headerlink" title="GET vs POST"></a>GET vs POST</h4><blockquote><p><a href="https://www.diffen.com/difference/GET-vs-POST-HTTP-Requests" target="_blank" rel="noopener">参考</a></p></blockquote><ul><li>GET 请求参数会显示在url中，因此可以通过书签或者其他方式进行重新访问</li><li>GET 请求对参数个数（2K）和总长度（2048字符）有限制，且只能传输ASCII编码字符，POST 还可传输文件等二进制数据</li><li>GET 请求可被缓存，POST 不可以</li><li>综上，POST 相对安全一些，且相对不容易被hack</li></ul><h4 id="class-method-vs-static-method"><a href="#class-method-vs-static-method" class="headerlink" title="class method vs static method"></a>class method vs static method</h4><ul><li><a href="https://www.geeksforgeeks.org/class-method-vs-static-method-python" target="_blank" rel="noopener">参考</a></li><li><code>static method</code>  中不存在<code>cls</code>变量，也就是不能通过<code>cls</code>访问其中的静态变量</li><li><code>class method</code> 中存在<code>cls</code>，因此可以在全局中通过类方法维护某个类变量来改变类的状态</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;blockquote&gt;
&lt;p&gt;即将开始一个新的阶段，慢慢积累慢慢进步吧&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Scrapy&quot;&gt;&lt;a href=&quot;#Scrapy&quot; c
      
    
    </summary>
    
      <category term="总结" scheme="https://thomstrong.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="技术" scheme="https://thomstrong.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>字节跳动 ByteCamp 周记</title>
    <link href="https://thomstrong.github.io/2019/08/31/Byte-Camp-Over/"/>
    <id>https://thomstrong.github.io/2019/08/31/Byte-Camp-Over/</id>
    <published>2019-08-30T17:42:10.000Z</published>
    <updated>2019-08-31T05:58:14.004Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><blockquote><p>第一篇技术相关的是字节跳动，第一篇随笔也是字节跳动。</p></blockquote><h3 id="First-of-all"><a href="#First-of-all" class="headerlink" title="First of all"></a>First of all</h3><p>这样一周像梦一样，不仅是时间上过的很快。仿佛做项目时自己也总是在梦游。</p><h3 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h3><p>回忆起来，小h和我一起坐车到北太平桥西便下车返校了，而我则是又多做了几站，到达了安华桥，准备前往集合地点。可能是天生的联想力，悄悄的跟随着一个也拖着行李箱的兄弟，认定他也是本次夏令营的营员，免去了导航的烦恼。当然，最后还是猜对了🙄。到了酒店，登记、收到一袋衣服等物品、入住，在床上休息一下，准备开营。</p><p>穿上胸前印着<del>-BUG-</del>的文化衫，上路！</p><p>第一次看到“活着的”字节跳动矮楼。进去后，在签名墙上留下姓名。本想在能够到的最高点写下自己的名字，最后想想还是放弃了，低调低调🤫</p><p>开营仪式，椅子上放着一本统计学习方法，瑟瑟发抖…或许只是因为自己太菜了，不敢面对一整本的知识吧。</p><p>李航老师带大家开营，对字节跳动的文化等多方面进行了一些讲解。仿佛脑子已经离线，只记得当时内心狂呼“好dior”至于什么其他的，也都记不太清楚了。</p><p>最后参观了一下整体环境，确实还是很不错的。期待品尝传说中的神仙午餐。</p><p>返回酒店，参加晚宴，见到mentor，比想象中年轻许多，但言语间透出的专业、系统的知识，确实佩服。</p><p>“不到最后一刻，见不到室友”，直到晚上11点左右，室友归来，也体会到了组委会的用心。他竟是本校学长…可能还怀疑，从哪里调研过性格？我对生人比较沉默，他能侃侃而谈。</p><h3 id="Day-1-amp-Day-2"><a href="#Day-1-amp-Day-2" class="headerlink" title="Day 1 &amp; Day 2"></a>Day 1 &amp; Day 2</h3><p>清晨出发，开始为期两天的课程。总体上还是从公司文化到公司技术架构、产品结构、核心技术领域进行介绍。见到了曾就职于不同公司的大牛，最终选择头条、相信头条。印象最深的还是讲基础架构的那位老师～行云流水，似乎将自己获取到的知识和自己融合了一般，把它们变成一种脱口而出的东西，听的我一愣一愣的…最后还听说，他还会给员工做管理培训…🤯心态崩了…我是真的菜…</p><p>总体来说，上课吧…也没记下来点啥…仿佛就是去听大牛讲自己的在做的事情而已…</p><p>最后，第一天晚上开始配置环境、讨论要做的项目、各种从“哇”到懵逼…不过我心态好~并没有为自己的菜而自卑～哈哈哈。第二天，和mentor大体构思了一下项目的模块，也似乎是懵懵懂懂，可能也和之前单纯的在完成一些业务逻辑相关的东西有关吧，还需要在学习啊</p><h3 id="Day-3-amp-Day-4-amp-Day-4-0-5"><a href="#Day-3-amp-Day-4-amp-Day-4-0-5" class="headerlink" title="Day 3 &amp; Day 4 &amp; Day 4+0.5"></a>Day 3 &amp; Day 4 &amp; Day 4+0.5</h3><p>项目项目，做项目…因为有些迷茫，进度倒是有些拖延。把一个似乎要用到很复杂方法的项目做成了大作业的样子。没有思绪也没有什么独到的想法，一切像是在糊弄一般…可能也可以理解到为什么xxx如此追求文档的精致和细枝末节，可能就是因为技术上的无能无力吧。因为项目上已经不能开出什么花了，那只好在人人都能做的事情上追求尽善尽美。没有任何思路时，只是在调整代码结构、调整ppt每个文字的位置和配色、各种无关项目本身的东西。确实是满满的无力感。也希望之后能在某些曾经认为无所谓的短板上有些改善吧。</p><h3 id="Day-4-5-0-5"><a href="#Day-4-5-0-5" class="headerlink" title="Day 4.5 + 0.5"></a>Day 4.5 + 0.5</h3><p>也是早在预料之中的事情，我们没有进入复审阶段，感觉做出的项目没有什么技术含量，总体来说，只能说是一个可以运行的本科大作业而已。也算是一次Golang的基础学习和微服务相关基础的实践吧。</p><p>当然，还是感谢导师给了我最终面试的机会（说到这，的确是组委会要求不要和其他小伙伴说自己被推荐的事啦～并不是我想刻意隐瞒🥺所以我的队友请不要怪我没有坦白呀）虽然，表现的一如既往的💩…各种崩各种答不出来…相当炸裂了可以说…哎～就这样吧，面经就不再写了，因为的确还没有到可以写什么面经的地步。</p><h3 id="Day-6"><a href="#Day-6" class="headerlink" title="Day 6"></a>Day 6</h3><p>最后的最后，在各方辛苦下，伴随着这几天摄影师们为我们制作的Vlog，我们结束了本次夏令营。马维英老师说他很羡慕我们，在这样一个时代能有这样的机会，也希望这样一个时期的经历能给我们有所影响。于我而言，确实是的。也可能是这段时间所经历的东西，也可能是深感自己被眷顾却没有抓住机会，自我感觉良好。</p><h3 id="The-Last"><a href="#The-Last" class="headerlink" title="The Last"></a>The Last</h3><p>谢谢头条（还是习惯头条的称呼…毕竟字节跳动要四个字…说起来真不顺口）给这样的机会，全程各种招待给满分！食堂饭菜满分！小姐姐小哥哥的热情满分！给自己呢…3分吧…参加了，努力了，虽然最后可能不尽如人意，也没有达到某些预期。实名制路转粉，希望有机会能带着进一步的自己加入你们！</p><p>以上。</p><h3 id="最后的调研"><a href="#最后的调研" class="headerlink" title="最后的调研"></a>最后的调研</h3><ol><li><strong>能较为详细地说说你做的项目吗？以及你得到的成长与复盘反思</strong></li></ol><p>题目是服务动态负载均衡调节，在我的理解上就是在服务端和客户端之间实现一个流量分配的代理。虽然从感性层面说比较简单，但是实际上还是需要考虑很多方面，包括服务器的负载能力、某些特定情况下的均衡等等。我们整体实现上还是相对简单一些，甚至可以说只是简单的将最基础的部分进行了实现，因此最后的作品其实并没有什么特别的亮点。再深一层次上的均衡方法并没有实现，所以可能对于一个问题的思考上还是需要多训练多积累，还是不够深入。</p><ol start="2"><li><strong>请问在夏令营期间，在你心中印象最深刻的环节是什么？</strong></li></ol><p>印象最深刻的，首先整体的体验上，不管是从每个赛道的服装分别设计的细腻上还是到舍友分配上，都非常佩服字节跳动在每个笔筒上印着的“追求极致”四个字。组委会可以说真的可以点一万万个赞。因此可能也会反思自己不知何时养成的“就这样吧”…跑题了…还有就是基础架构课程中那位老师行云流水的讲授，一气呵成和随机应变的整个讲授过程，真的不能不佩服和印象深刻。当然还有很多吧，就不一一说了。</p><ol start="3"><li><strong>如果你有其他任何想吐槽的地方，请尽情写下来&gt;&lt;！我们躺平！ </strong></li></ol><p>吐槽酒店的网！这个五星酒店虽然很高档但是我觉得你们可以ban掉了，比较不适合程序员。哈哈哈，房间插头几乎找不到（当然可能是这个房型的问题）找到的插头插不稳mac的两项插头…太重了…其他都很好～</p><ol start="4"><li><strong>也想听听你认为整个过程中，夏令营做的最好的地方是什么？</strong></li></ol><p>整个过程从安排到各位工作人员的极致精神（特别respect小莲子和小乔两位好姐姐还有背后更多也在付出的员工们，非常辛苦）各方面做的都很好很到位。</p><ol start="5"><li><strong>本次ByteCamp夏令营之旅，带给你最多的是什么？</strong></li></ol><p>一些思考吧，可能曾经的自己有些盲目自信，更应该说的是蒙蔽了自己吧。对自己的未来也有些规划和想法。</p><ol start="6"><li><strong>如果夏令营可以重新来一遍，你会希望哪些地方能够被改变？ </strong></li></ol><p>希望自己能在开营之前做更多的准备吧，而不是来了现场懵逼，更多是白白错过了许多机会。</p><ol start="7"><li><strong>有没有什么话想对某一/几个人说？</strong></li></ol><p>…(略)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;blockquote&gt;
&lt;p&gt;第一篇技术相关的是字节跳动，第一篇随笔也是字节跳动。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;First-of-all&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="流水账" scheme="https://thomstrong.github.io/categories/%E6%B5%81%E6%B0%B4%E8%B4%A6/"/>
    
    
      <category term="夏令营" scheme="https://thomstrong.github.io/tags/%E5%A4%8F%E4%BB%A4%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>夏令营作业集合</title>
    <link href="https://thomstrong.github.io/2019/07/28/microservice/"/>
    <id>https://thomstrong.github.io/2019/07/28/microservice/</id>
    <published>2019-07-28T09:45:12.000Z</published>
    <updated>2019-09-01T10:27:03.985Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><blockquote><p>头条夏令营作业1，微服务相关调研</p></blockquote><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>微服务是一种架构风格，大型的复杂软件通常由一个或多个微服务组成。系统中各个微服务可以被独立部署，各个微服务之间也是松耦合的。每个微服务有各自需要专注的任务，因此各自代表着一个小的业务能力</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>组件化：将整体拆分为多个可独立部署和升级的单元</li><li>围绕业务能力组织：每个微服务团队应该是夸功能的，且开发运维一体化的。但是每个团队并不会有太多成员</li><li>视为产品而非项目：谁开发，谁运营</li><li>通讯松耦合：将通信的相关业务放在组件端点侧。RESTful协议和仅提供消息路由功能的轻量级异步机制是微服务架构中最常用的通讯机制</li><li>去中心化：每个微服务可以采用最适合自己的工具/技术，而不会让整体都应用同一个技术。通常倾向于对于每个微服务，使用有现成或类似解决方案的方式进行实现。</li><li>基础设施自动化：云+自动化部署等方式，降低微服务构建、部署和运维的难度</li><li>故障处理设计：注重实时监控和日志机制，考虑服务失败的容错机制</li><li>演进式设计：更注重快速更新迭代</li></ul><h4 id="常见误区"><a href="#常见误区" class="headerlink" title="常见误区"></a>常见误区</h4><ul><li>微服务不能等同于API，微服务指的是将原有的整体式架构进行拆解，组件化后产生的微服务应用。是更细粒度的组件，而非更细粒度的API。</li><li>微服务架构和微组件架构是有差异的。微服务架构更强调独立部署和快速迭代。</li><li>微服务架构不等同于SOA（面向服务架构）。虽然都是以服务为核心的架构，但是微服务更倾向于应用范畴，而SOA更倾向于企业规模范畴</li></ul><h4 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a>应用领域</h4><ul><li>记录型系统：可将大型应用按照相对独立的业务功能分解成若干个微服务实现</li><li>交互型系统</li><li>分析型系统</li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>每个服务简单，更关注于一个业务功能</li><li>松耦合，灵活性很好</li><li>可在应用中使用最适合的语言/工具</li><li>每个微服务之间独立开发，互不影响，加快市场推进</li><li>在频繁发布某个微服务同时可保持其他微服务的可用和稳定</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>需要同时维护多个独立服务，运维开销和成本增加</li><li>对于开发人员的运维能力也更有考验</li><li>对于一个新产品发布导致大量服务协同发布的情况，会产生更多的隐式接口和其中的匹配问题，服务服务架构有更高的发布风险</li><li>为了防止“同步耦合”，不同服务之间会产生一定的代码重复</li><li>分布式系统的复杂，也会带来一定的问题</li><li>异步的机制会导致实现的复杂化</li><li>在动态环境中，服务间的交互会产生一些不可测的现象</li></ul><h4 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h4><ul><li>Spring Cloud<ul><li>基于java语言</li><li>应用广泛，社区支持好</li><li>架构整体覆盖比较全，有较为完善的架构体系</li><li>自由开发，但是较难约束接口规范</li></ul></li><li>Dubbo<ul><li>基于java语言</li><li>年轻的框架，目前也有一定的社区用户</li><li>dubbo的jar依赖会是一个较难解决的问题</li></ul></li><li>gRPC<ul><li>基于Go语言</li><li>很弱的负载均衡</li><li>只有服务调用，没有服务治理</li></ul></li><li>Go-micro<ul><li>基于Go语言</li><li>服务治理rpc框架</li><li>性能较为一般</li></ul></li><li>Tars<ul><li>支持C++、Java、PHP、NodeJS 、Go</li><li>自带服务治理</li><li>目前对Go的社区支持TarsGo框架较为弱</li></ul></li></ul><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul><li>通过在服务中介节点的注册和查找，完成新加入服务的发现和调用。</li><li>当服务提供者挂掉时，取消注册，通知服务调用方更换地址</li><li>当新服务加入时，服务注册，服务中介通知服务调用方</li></ul><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul><li>对于意外退出的服务如何通知服务中介服务地址时效？=&gt; 使用存活汇报机制</li><li>服务器列表变化中介如何通知服务调用者<ul><li>服务调用者轮询</li><li>发布订阅模式对服务调用者广播</li></ul></li><li>单点redis挂掉如何处理？=&gt; 使用分布式数据库zookeeper/ etcd/ consul作为中介</li></ul><h4 id="形式"><a href="#形式" class="headerlink" title="形式"></a>形式</h4><ul><li>客户端服务发现<ul><li>客户端通过访问服务注册表使用均衡算法访问服务</li><li>可对不同的客户端实现不同的均衡机制，灵活但是麻烦</li></ul></li><li>服务端服务发现<ul><li>服务请求通过一个负载均衡器进行转发，均衡器从主服务注册表查询可用服务实例</li><li>客户端对服务发现逻辑并不知道，只需要像负载均衡器发送请求</li></ul></li></ul><h4 id="服务注册表"><a href="#服务注册表" class="headerlink" title="服务注册表"></a>服务注册表</h4><blockquote><p>服务发现实现中关键部分，需要高可用和实时更新</p></blockquote><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><ul><li><p><a href="http://zookeeper.apache.org/" target="_blank" rel="noopener">Zookeeper</a></p><ul><li>Java语言，sdk接口</li><li>功能强大，不仅作为服务发现框架</li><li>需要客户端对服务保活，增加了开发难度</li></ul></li><li><p><a href="https://github.com/hashicorp/consul" target="_blank" rel="noopener">Consul</a></p><ul><li>Go 语言，http/dns接口</li><li>简单易用，不需要集成sdk</li><li>不能实时获取服务信息变化通知</li></ul></li><li><a href="https://github.com/coreos/etcd" target="_blank" rel="noopener">Etcd</a><ul><li>Go 语言，http接口</li><li>简单易用，不需要集成sdk，可配置性强</li><li>需要第三方工具一起完成服务发现，不支持多数据中心</li><li>高可用、分布式、一致性、k - v 方式存储</li></ul></li></ul><h5 id="self-registration-模式"><a href="#self-registration-模式" class="headerlink" title="self-registration 模式"></a>self-registration 模式</h5><ul><li>服务实例自己通过注册表进行服务注册和注销</li><li>通过发送心跳请求防止注册过期</li><li>和服务强耦合，必须在所有编写的服务中实现一遍服务注册逻辑</li><li>在服务运行中但是没有能力提供服务的情况下，缺乏解注册的能力</li></ul><h5 id="third-party-registration模式"><a href="#third-party-registration模式" class="headerlink" title="third-party registration模式"></a>third-party registration模式</h5><ul><li>通过service registrar轮询或者订阅事件来检测运行实例的变化，当检测到可用实例就加入注册表</li><li>可以从服务端解耦注册逻辑，将服务注册集中管理</li><li>如果没有内置在部署环境中，需要是一个高可用系统组件</li></ul><h3 id="Service-Mesh"><a href="#Service-Mesh" class="headerlink" title="Service Mesh"></a>Service Mesh</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><ul><li>解决<strong>服务间通信</strong>的基础设施层，保证请求在复杂服务拓扑中可靠传输</li><li>可以理解为微服务之间的TCP/IP，用于微服务间的网络调用、限流、熔断和监控，对应用透明</li><li>用于服务间通信而单独分理出的组件（Sidecar）</li></ul><h4 id="发展过程"><a href="#发展过程" class="headerlink" title="发展过程"></a>发展过程</h4><ol><li>服务间通信使得服务业务逻辑中夹杂网络传输问题处理逻辑</li><li>TCP协议出现，解决了网络传输中流量控制的问题，将流量控制从服务实现中抽离，成为操作系统中网络层的一部分</li><li>分布式系统特有的如熔断策略、负载均衡、服务发现、认证授权、trace、监控等又需要根据业务需求实现</li><li>某些框架实现了分布式系统通信需要的各种通用语义功能，以依赖的方式引入，屏蔽一些通信细节，使得使用较少代码开发健壮分布式系统</li><li>通过部署在服务环境中的代理服务实现服务间通信，减去了框架学习成本，更解决了通信库版本兼容的问题，防止了由于升级通信库而带来的服务被迫升级</li><li>统一上层运维入口，集中对每个服务中的代理组建进行管理，通过和控制面板交互进行网络拓扑策略的更新和单机数据的汇报。</li></ol><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li>屏蔽了分布式系统通信的复杂性</li><li>真正的语言无关，服务可以使用任何语言，只需要和Service Mesh通信即可</li><li>对应用透明，Service Mesh组件可以单独升级</li></ul><h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h4><ul><li>Service Mesh组件以代理模式计算并转发，一定程度上会影响效率</li><li>服务的整体稳定性依赖于Service Mesh，同时额外引入了对Service Mesh的管理成本</li></ul><h4 id="框架-1"><a href="#框架-1" class="headerlink" title="框架"></a>框架</h4><ul><li>Istio<ul><li>Go语言和C++实现</li><li>性能相对较低一些</li></ul></li><li>Linkerd<ul><li>Scala语言</li><li>总体开销较低，在高qps下性能会有所下降</li><li>仅用于Kubernetes</li></ul></li><li>Conduit（Linkerd 2.x）<ul><li>基于Rust和Go语言</li><li>专为Kubernetes定制的轻量级服务网格</li></ul></li></ul><blockquote><p>头条夏令营作业2，cgroups相关概念</p></blockquote><h3 id="Cgroups"><a href="#Cgroups" class="headerlink" title="Cgroups"></a>Cgroups</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><ul><li>进行分组化管理的Linux<strong>内核</strong>功能</li><li>通过子系统来完成，每个子系统就是一个资源分配器</li><li>例如，<code>cpu</code> 子系统就是控制CPU资源的分配器</li><li>如果进程加入了某一个控制组，该控制组对Linux的系统资源都有严格限制，进程在使用这些资源时不能超过最大限制</li></ul><h4 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h4><ul><li>任务（task）：在cgroup中任务就是系统的一个进程</li><li>控制族群（control group）：一组按照某种资源限制划分的进程组</li><li>层级（hierachy）： 控制族群组成的控制族群树，子控制进程组继承父控制进程组</li><li>子系统（subsystem）：任务组中的一个模块，是一个控制器，提供多种资源限制的控制器</li></ul><h4 id="子系统"><a href="#子系统" class="headerlink" title="子系统"></a>子系统</h4><ul><li>可以使用<code>lssubsys -a</code> 查看所有子系统</li><li>要为cgroup分配限制的资源首先要挂在子系统，然后才有控制组</li><li><code>blkio</code> 限制块设备的输入输出控制</li><li><code>cpu</code> 使用调度程序为<code>cgroup</code> 任务提供cpu访问</li><li><code>cpuacct</code> 产生cgroup任务的cpu资源报告</li><li><code>cpuset</code> 在多核心cpu中为cgroup任务分配单独cpu和内存</li><li><code>devices</code> 允许或拒绝cgroup任务对设备的访问</li><li><code>freezer</code> 暂停和恢复cgroup任务</li><li><code>memory</code> 设置每个cgroup的内存限制及产生内存资源报告</li><li><code>perf_event</code> 增加了对每个group的监测和跟踪能力，可监测某个特定group的所有进程以及运行在特定cpu上的线程</li><li><code>hugetlb</code> HugeTLB页的资源控制功能</li></ul><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ul><li>ubuntu：<code>apt-get install cgroup-bin</code></li><li>Centos: <code>yum install libcgroup</code></li></ul><h4 id="CPU子系统"><a href="#CPU子系统" class="headerlink" title="CPU子系统"></a>CPU子系统</h4><h5 id="一些参数"><a href="#一些参数" class="headerlink" title="一些参数"></a>一些参数</h5><ul><li><code>cpu.cfs_period_us</code> 每个CPU时间片的微秒数，限制从1毫秒到1秒之间</li><li><code>cpu.cfs_quota_us</code> 在当前的每个CPU时间片中可以使用的CPU时间数</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;blockquote&gt;
&lt;p&gt;头条夏令营作业1，微服务相关调研&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;微服务&quot;&gt;&lt;a href=&quot;#微服务&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="头条夏令营" scheme="https://thomstrong.github.io/tags/%E5%A4%B4%E6%9D%A1%E5%A4%8F%E4%BB%A4%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>Go 语言基础学习</title>
    <link href="https://thomstrong.github.io/2019/07/23/first-golang/"/>
    <id>https://thomstrong.github.io/2019/07/23/first-golang/</id>
    <published>2019-07-23T09:05:23.000Z</published>
    <updated>2019-12-09T16:28:40.527Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><blockquote><p>学习自<a href="https://www.runoob.com/go/go-concurrent.html" target="_blank" rel="noopener">菜鸟教程</a>/编码自<a href="https://tour.go-zh.org/welcome/1" target="_blank" rel="noopener">Go指南</a>/更全的<a href="https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/preface.md" target="_blank" rel="noopener">教程</a></p></blockquote><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>静态强类型、编译型、并发型</li></ul><h4 id="特色"><a href="#特色" class="headerlink" title="特色"></a>特色</h4><ul><li>简洁、快速、安全</li><li><strong>并行</strong>、有趣、开源</li><li>内存管理、数组安全、编译迅速</li></ul><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><ul><li>搭载 Web 服务器</li><li>存储集群</li><li>巨型中央服务器的系统</li></ul><h3 id="写代码"><a href="#写代码" class="headerlink" title="写代码"></a>写代码</h3><h4 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main <span class="comment">// 定义包名，main包表示一个可独立执行的程序，每个Go应用都包含一个名为main的包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span> <span class="comment">// 引入包</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; <span class="comment">// main函数是所有可执行程序必须包含的，此处&#123;不可换行否则编译错误</span></span><br><span class="line">   <span class="comment">/* 这是我的第一个简单的程序 */</span></span><br><span class="line">   fmt.Println(<span class="string">"Hello, World!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>行分割，每个语句是一行，无需使用<code>;</code>分割</li></ul><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><blockquote><p>与其他语言有相同之处，也有不同之处</p></blockquote><ul><li>基本类型：<code>int</code>、<code>bool</code>、<code>float32</code>、<code>float64</code>、<code>string</code>(字符串的字节使用 UTF-8 编码标识 Unicode 文本)</li><li><p>衍生类型</p><ul><li><p>指针类型（Pointer）</p></li><li><p>数组类型</p><ul><li>比较</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">slice1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">slice2 := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">slice3 := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">slice4 := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(slice1 == slice2) <span class="comment">// 编译错误，长度不相等，无法比较</span></span><br><span class="line">fmt.Println(slice1 == slice3) <span class="comment">// true</span></span><br><span class="line">fmt.Println(slice1 == slice4) <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>结构化类型(struct)</p></li><li><p>Channel 类型</p></li><li><p>函数类型</p></li><li><p>切片类型</p></li><li><p>接口类型（interface）</p></li><li><p>Map 类型</p><ul><li>单变量声明方法</li></ul></li><li><code>var agePtr *int</code> 没有初始化则默认为零值</li><li><code>var d = true</code> 赋初值省略变脸类型</li><li><code>f := &quot;Runoob&quot;</code> 省略<code>var</code>和变量类型，只能在函数中出现，且只能用于声明</li></ul><ul><li><p>多变量声明</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x, y <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> (  <span class="comment">// 这种因式分解关键字的写法一般用于声明全局变量</span></span><br><span class="line">    a <span class="keyword">int</span></span><br><span class="line">    b <span class="keyword">bool</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>所有声明的变量必须被使用，否则会编译失败，因此需要声明但是不会用到的变量可使用<code>_</code>空白标识符占位</p></li><li><p>相同类型变量的交换赋值可以使用<code>a, b = b, a</code></p></li><li><p>常量声明。其中iota为特殊常量，可以认为是一个可以被编译器修改的常量，其值是常量所在的行index</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">d = <span class="number">4</span> <span class="comment">// 4</span></span><br><span class="line">e <span class="comment">// 未赋值重复上一个常量赋值，4</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">a = <span class="number">2</span> <span class="comment">// 2</span></span><br><span class="line">b = <span class="literal">iota</span> <span class="comment">//1</span></span><br><span class="line">c <span class="comment">// 2</span></span><br><span class="line">  d = <span class="literal">iota</span> * <span class="literal">iota</span> <span class="comment">// 3 * 3 = 9</span></span><br><span class="line">  e <span class="comment">// 4 * 4 = 16</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><h4 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h4><ul><li>常规运算：<ul><li>算数运算<code>+ - * / % ++ --</code></li><li>关系运算<code>&gt; &lt; == != &gt;= &lt;=</code></li><li>逻辑运算<code>&amp;&amp; || !</code></li><li>位运算<code>&amp; | ^ &gt;&gt; &lt;&lt; &amp;^(按位清零)</code></li><li>赋值运算<code>=</code>(以及运算后赋值<code>+=</code>等等)</li><li>其他运算<code>&amp; *</code></li></ul></li></ul><h4 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h4><ul><li><code>if</code>和<code>if-else</code></li><li><code>switch-case</code><ul><li>不用类似<code>break</code>语法进行单<code>case</code>控制，可以使用<code>fallthrough</code>使得执行当前<code>case</code>后强行进入下一个<code>case</code>且不用判断下一个<code>case</code>是否为真</li><li>可以使用<code>switch …{ case …: }</code>的写法也可以使用<code>switch { case…: }</code>判定”true case”的写法</li></ul></li><li><code>select-case</code><ul><li>每个 case 都必须是一个通信</li><li>所有 channel 表达式都会被求值</li><li>所有被发送的表达式都会被求值</li><li>如果任意某个通信可以进行，它就执行，其他被忽略。</li><li>如果有多个 case 都可以运行，Select 会随机公平地选出一个执行。其他不会执行。 否则：<ul><li>如果有 default 子句，则执行该语句。</li><li>如果没有 default 子句，select 将阻塞，直到某个通信可以运行；Go 不会重新对 channel 或值进行求值。</li></ul></li><li>结合<code>for</code>循环和<code>goroutine</code>可以完成并行</li></ul></li><li>不支持 <code>? :</code> 形式的条件判断</li></ul><h4 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h4><ul><li><p>表示方法</p><ul><li><code>for init; condition; post { }</code></li><li><p><code>for condition { }</code> //等价于C语言中的while</p></li><li><p><code>for { }</code>// while true</p></li></ul></li><li><p>or 循环的 range 格式可以对 slice、map、数组、字符串等进行迭代循环</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> oldMap &#123;</span><br><span class="line">    newMap[key] = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function_name</span><span class="params">( [parameter list] )</span> [<span class="title">return_types</span>]</span> &#123;</span><br><span class="line">   <span class="comment">// 函数体</span></span><br><span class="line">&#125; <span class="comment">// 函数定义</span></span><br><span class="line"><span class="comment">/* ==================================================== */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 函数体</span></span><br><span class="line">&#125;() <span class="comment">// 匿名函数直接调用</span></span><br><span class="line"><span class="comment">/* ==================================================== */</span></span><br><span class="line">myFunc := <span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 函数体</span></span><br><span class="line">&#125; <span class="comment">// 声明函数变量</span></span><br><span class="line">myFunc() <span class="comment">// 调用</span></span><br><span class="line"><span class="comment">/* ==================================================== */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> y, x</span><br><span class="line">&#125; <span class="comment">// 返回多值的函数</span></span><br><span class="line"><span class="comment">/* ==================================================== */</span></span><br><span class="line"><span class="comment">/* 闭包函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSequence</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   i:=<span class="number">0</span></span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">      i+=<span class="number">1</span></span><br><span class="line">     <span class="keyword">return</span> i  </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">nextNumber := getSequence()  </span><br><span class="line">fmt.Println(nextNumber()) <span class="comment">// 1</span></span><br><span class="line">fmt.Println(nextNumber()) <span class="comment">// 2</span></span><br><span class="line">fmt.Println(nextNumber()) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">nextNumber1 := getSequence()  </span><br><span class="line">fmt.Println(nextNumber1()) <span class="comment">// 1</span></span><br><span class="line">fmt.Println(nextNumber1()) <span class="comment">// 2</span></span><br><span class="line"><span class="comment">/* ==================================================== */</span></span><br></pre></td></tr></table></figure><h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><ul><li>函数内定义的变量称为局部变量</li><li>函数外定义的变量称为全局变量</li><li>函数定义中的变量称为形式参数</li></ul><h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><ul><li>声明方法 <code>var ip *int</code></li><li>访问指针值 <code>fmt.Printf(&quot;*ip 变量的值: %d**\n**&quot;, *ip )</code></li><li>指针不赋初值默认为<code>nil</code>空指针</li></ul><h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><ul><li><p>声明方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Books <span class="keyword">struct</span> &#123;</span><br><span class="line">   title <span class="keyword">string</span></span><br><span class="line">   author <span class="keyword">string</span></span><br><span class="line">   subject <span class="keyword">string</span></span><br><span class="line">   book_id <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义结构体 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Book1 Books   <span class="comment">// 定义空结构体</span></span><br><span class="line"></span><br><span class="line">fmt.Println(Books&#123;<span class="string">"Go 语言"</span>, <span class="string">"www.runoob.com"</span>, <span class="string">"Go 语言教程"</span>, <span class="number">6495407</span>&#125;) <span class="comment">// 按顺序定义变量值</span></span><br><span class="line"></span><br><span class="line">fmt.Println(Books&#123;title: <span class="string">"Go 语言"</span>, author: <span class="string">"www.runoob.com"</span>, subject: <span class="string">"Go 语言教程"</span>, book_id: <span class="number">6495407</span>&#125;) <span class="comment">// 指定成员值</span></span><br></pre></td></tr></table></figure></li><li><p>访问成员</p><ul><li><code>Book1.title = &quot;some title&quot;</code></li><li><code>fmt.Println(Book1.title)</code></li></ul></li></ul><h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><blockquote><p>切片是对数组的抽象，可以理解为动态数组，可以追加元素，在追加时可能使切片的容量增大</p></blockquote><ul><li><p>声明方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice1 = []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; <span class="comment">// 不指定数组大小声明的数组会被认为是切片</span></span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">//声明一个容量为3，当前内含2个元素的切片</span></span><br><span class="line"><span class="keyword">var</span> slice2 = []<span class="keyword">int</span> <span class="comment">// slice2 == nil</span></span><br></pre></td></tr></table></figure></li><li><p>初始化方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice2 := slice1[<span class="number">1</span>:] <span class="comment">// 通过slice1的引用初始化slice2</span></span><br></pre></td></tr></table></figure></li><li><p>append 方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">slice3 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line">fmt.Println(slice3) <span class="comment">// [0, 0]</span></span><br><span class="line">slice3 = <span class="built_in">append</span>(slice3, <span class="number">1</span>)</span><br><span class="line">slice3 = <span class="built_in">append</span>(slice3, <span class="number">1</span>)</span><br><span class="line">slice3 = <span class="built_in">append</span>(slice3, <span class="number">1</span>)</span><br><span class="line">slice3 = <span class="built_in">append</span>(slice3, <span class="number">1</span>) <span class="comment">// 自动扩容到10</span></span><br><span class="line">fmt.Println(slice3) <span class="comment">// [0,0,1,1,1,1]</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(slice3)) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure></li><li><p>copy 方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">slice3 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line">slice4 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(slice3), <span class="built_in">cap</span>(slice3))</span><br><span class="line"><span class="built_in">copy</span>(slice4, slice3) <span class="comment">// 可以认为是for循环两个slice中len最小的值进行赋值</span></span><br><span class="line">slice4[<span class="number">0</span>] = <span class="number">1233</span></span><br><span class="line">fmt.Println(slice3, slice4)<span class="comment">// [0,0] [1233,0]</span></span><br></pre></td></tr></table></figure><ul><li><code>copy</code> 方法使用两者长度较小的作为复制目标的长度</li><li>方法返回复制目标长度，即二者长度最小值</li></ul></li></ul><h4 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h4><ul><li><p>返回一个有序对<code>key, value</code>用于遍历数组/切片/通道/集合，和<code>python</code>的<code>enumerate</code>方法类似</p></li><li><p>例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">nums := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">  sum += num</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kvs := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"a"</span>: <span class="string">"apple"</span>, <span class="string">"b"</span>: <span class="string">"banana"</span>&#125;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> kvs &#123;</span><br><span class="line">  fmt.Printf(<span class="string">"%s -&gt; %s\n"</span>, k, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><ul><li>无序键值对的集合，使用哈希表来实现</li><li>声明方式<ul><li><code>var map1 map[string]sttring</code> // 不赋初值声明</li><li><code>map2 := make(map[string]string)</code> // 不赋初值声明</li><li><code>map3  := map[string]string{&quot;a&quot;: &quot;apple&quot;, &quot;b&quot;: &quot;banana&quot;}</code> // 赋初值声明</li></ul></li><li>赋值方式与<code>python</code>相同</li><li>可以使用<code>delete()</code>函数删除字典中的键值对</li></ul><h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><ul><li>使用类似<code>float32(sum)</code>的方法对<code>var sum int = 2</code>进行强制类型转换</li></ul><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><ul><li><p>通过定义接口，然后直接实现接口中声明的函数，进行多态实现</p></li><li><p>示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> phone <span class="keyword">interface</span> &#123;</span><br><span class="line">getname() <span class="keyword">string</span></span><br><span class="line">call()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Iphone <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Nokia <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(iphone Iphone)</span> <span class="title">getname</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"I am iphone"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(nokia Nokia)</span> <span class="title">getname</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"I am nokia"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(iphone Iphone)</span> <span class="title">call</span><span class="params">()</span></span>  &#123;</span><br><span class="line">fmt.Println(<span class="string">"call with iphone"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(nokia Nokia)</span> <span class="title">call</span><span class="params">()</span></span>  &#123;</span><br><span class="line">fmt.Println(<span class="string">"call with nokia"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ===============in main() ====================== */</span></span><br><span class="line">phone := <span class="built_in">new</span>(Iphone)</span><br><span class="line">fmt.Println(phone.getname()) <span class="comment">//I am iphone</span></span><br><span class="line">phone.call()<span class="comment">// call with iphone</span></span><br><span class="line"></span><br><span class="line">anotherPhone := <span class="built_in">new</span>(Nokia) </span><br><span class="line">fmt.Println(anotherPhone.getname()) <span class="comment">// I am nokia</span></span><br><span class="line">anotherPhone.call() <span class="comment">// call with nokia</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h4><ul><li><p>通过实现<code>error.Error()</code>函数来实现异常捕获</p></li><li><p>示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DivideError <span class="keyword">struct</span> &#123;</span><br><span class="line">dividee <span class="keyword">int</span></span><br><span class="line">divider <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(divideError *DivideError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">strFormat := <span class="string">`</span></span><br><span class="line"><span class="string">    Cannot proceed, the divider is zero.</span></span><br><span class="line"><span class="string">    dividee: %d</span></span><br><span class="line"><span class="string">    divider: 0</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(strFormat, divideError.dividee)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Divide</span><span class="params">(varDividee <span class="keyword">int</span>, varDivider <span class="keyword">int</span>)</span> <span class="params">(result <span class="keyword">int</span>, errorMsg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> varDivider == <span class="number">0</span> &#123;</span><br><span class="line">dData := DivideError&#123;</span><br><span class="line">dividee: varDividee,</span><br><span class="line">divider: varDivider,</span><br><span class="line">&#125;</span><br><span class="line">errorMsg = dData.Error()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> varDividee / varDivider, <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ===============in main() ====================== */</span></span><br><span class="line"><span class="keyword">for</span> divider := <span class="keyword">range</span> []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>&#125; &#123;</span><br><span class="line">  <span class="keyword">if</span> result, errorMsg := Divide(<span class="number">100</span>, divider); errorMsg == <span class="string">""</span> &#123;</span><br><span class="line">    fmt.Println(divider, result)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"errorMsg is: "</span>, errorMsg)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* output:</span></span><br><span class="line"><span class="comment">errorMsg is:  </span></span><br><span class="line"><span class="comment">  Cannot proceed, the divider is zero.</span></span><br><span class="line"><span class="comment">    dividee: 100</span></span><br><span class="line"><span class="comment">    divider: 0</span></span><br><span class="line"><span class="comment">1 100</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="Go-并发"><a href="#Go-并发" class="headerlink" title="Go 并发"></a>Go 并发</h4><h5 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h5><ul><li><p>Go 使用 goroutine实现并发。goroutine 是轻量级线程，goroutine 的调度是由 Golang 运行时进行管理的。</p></li><li><p>开启goroutine的方法：<code>go fun(x, y, z)</code></p></li><li>Goroutine 会随着主线程的结束而自动销毁</li></ul><h5 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h5><ul><li><p>通道（channel）是用来传递数据的一个数据结构</p></li><li><p>使用方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// 声明信道</span></span><br><span class="line">ch &lt;- v    <span class="comment">// 把 v 发送到通道 ch</span></span><br><span class="line">v := &lt;-ch  <span class="comment">// 从 ch 接收数据</span></span><br><span class="line">           <span class="comment">// 并把值赋给 v</span></span><br></pre></td></tr></table></figure></li><li><p>通道可以设置缓冲区，通过 make 的第二个参数指定缓冲区大小 <code>ch := make(chan int, 10)</code></p></li><li><p>通道遍历可使用<code>range</code>语法</p></li></ul><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><blockquote><p>摘自公众号 Golang来啦</p></blockquote><h4 id="1-下面代码能否正常结束"><a href="#1-下面代码能否正常结束" class="headerlink" title="1. 下面代码能否正常结束"></a>1. 下面代码能否正常结束</h4> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> v &#123;</span><br><span class="line">        v = <span class="built_in">append</span>(v, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<code>range</code>的循环次数，在最开始就已经确定，不会因为序列的变化而改变</p><h4 id="2-下面的代码输出是什么"><a href="#2-下面的代码输出是什么" class="headerlink" title="2. 下面的代码输出是什么"></a>2. 下面的代码输出是什么</h4>   <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> m = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(i, v)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>由于<code>range</code> 函数的返回会复用<code>i</code>和 <code>v</code> 而不是重新声明，因此在<code>println</code> 函数输出前可能可以是循环过程中的任何值。为保证唯一，可以使用临时变量或者传参的形式保证传入参数的唯一性。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">change</span><span class="params">(s ...<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">s = <span class="built_in">append</span>(s,<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">5</span>,<span class="number">5</span>)</span><br><span class="line">slice[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">slice[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">change(slice...)</span><br><span class="line">fmt.Println(slice)</span><br><span class="line">change(slice[<span class="number">0</span>:<span class="number">2</span>]...)</span><br><span class="line">fmt.Println(slice)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* output:</span></span><br><span class="line"><span class="comment"> [1 2 0 0 0]</span></span><br><span class="line"><span class="comment"> [1 2 3 0 0]</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">===========================</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> r [<span class="number">5</span>]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">            a[<span class="number">1</span>] = <span class="number">12</span></span><br><span class="line">            a[<span class="number">2</span>] = <span class="number">13</span></span><br><span class="line">        &#125;</span><br><span class="line">        r[i] = v</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"r = "</span>, r)</span><br><span class="line">    fmt.Println(<span class="string">"a = "</span>, a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* output:</span></span><br><span class="line"><span class="comment"> r =  [1 12 13 4 5]</span></span><br><span class="line"><span class="comment"> a =  [1 12 13 4 5]</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><ul><li>切片的底层是一个结构体，包含切片长度、容量和一个数组指针。对切片进行<code>拷贝</code>或<code>[i:j]</code>截取操作时，底层的数组指针不会改变，仍指向同一数组。仅当在<code>append</code> 操作使得<code>len &gt; cap</code> 时才会重新创建新的切片。因此对于副本的所有操作均会应用到原切片</li><li>注意区分切片的声明和数组的声明</li></ul><h4 id="3-defer-和-recover"><a href="#3-defer-和-recover" class="headerlink" title="3. defer 和 recover"></a>3. defer 和 recover</h4><h5 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h5><ul><li><p>注册延迟调用的机制</p></li><li><p>把函数压入栈中，当defer的上层<strong>函数</strong>返回（包括正常返回和异常返回）后再将栈内函数弹出执行</p></li><li><p>由于是在真正返回之前进行弹栈，因此就可以通过诸如如下形式，对返回的命名参数在真正返回之前进行操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fn</span><span class="params">()</span><span class="params">(r T)</span></span> &#123;</span><br><span class="line"><span class="comment">// init t</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// do something change r to change the return value which is t before</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>拆解：将函数的返回命名为声明中的返回查看结果。对于匿名返回的参数，可将返回值赋给一个命名变量用来拆解</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个例子：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span> <span class="params">(r <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">     t := <span class="number">5</span></span><br><span class="line">     <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">       t = t + <span class="number">5</span></span><br><span class="line">     &#125;()</span><br><span class="line">     <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 拆解后：</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span> <span class="params">(r <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">     t := <span class="number">5</span></span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 1. 赋值指令</span></span><br><span class="line">     r = t</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 2. defer被插入到赋值与返回之间执行，这个例子中返回值r没被修改过</span></span><br><span class="line">     <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;        </span><br><span class="line">         t = t + <span class="number">5</span></span><br><span class="line">     &#125;()</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 3. 空的return指令</span></span><br><span class="line">     <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>综上所述，</p><ul><li>对于命名返回参数的函数使用拆解的方法看</li><li>对于函数式的方法应该注意是传参调用还是闭包调用，传参使用的是复制的当时的值，闭包则使用的是变量的引用</li><li><code>defer</code>延时调用的方法，可以在参数出现时定义其最终关闭的方法，防止后续赋值导致其失效的问题</li><li><code>defer</code>调用失败，会返回<code>panic</code></li></ul><h5 id="recover"><a href="#recover" class="headerlink" title="recover"></a>recover</h5></li><li><p>如果程序出现致命错误，触发<code>panic</code> ，此时当前正在执行程序会被直接停掉，而不只是协程。为了防止程序直接挂掉，需要在defer中使用recover对程序进行会恢复，防止程序完全挂掉</p></li><li><code>recover</code> 只有在<code>defer</code> 的上下文中才有效</li><li>通过<code>recover</code> 捕获<code>panic</code> 稳住主流程，以免影响其他协程的正常运行</li><li><code>recover</code>函数和<code>panic</code>可以认为是弹栈和压栈操作，<code>panic</code>压栈<code>interface</code>，对于生效的<code>recover</code>再弹栈<code>inteface</code></li></ul><h4 id="4-闭包"><a href="#4-闭包" class="headerlink" title="4. 闭包"></a>4. 闭包</h4><ul><li>闭包 = 函数 + 引用环境</li><li>匿名函数被称作闭包，只可直接调用或者赋值于某个变量</li><li>闭包捕获的变量和常量是引用传递</li><li>感性的理解上可以将闭包认为是声明了一个类，然后捕获的变量成为了类的成员变量</li></ul><h4 id="5-golang中-的4处用法"><a href="#5-golang中-的4处用法" class="headerlink" title="5. golang中... 的4处用法"></a>5. golang中<code>...</code> 的4处用法</h4><ul><li>函数中的最后一个参数，形如<code>func(n ...T)</code>表示函数在此参数（可变参数）后可接受若干个本类型的参数</li><li>在向可变参数函数传递参数时使用<code>func(nums...)</code>方式传入参数</li><li>在不定个数数组声明时，形如<code>[...]string{&quot;Moe&quot;, &quot;Larry&quot;, &quot;Curly&quot;}</code>方式，使编译器自动判定数组长度</li><li>在go命令中使用<code>go test ./...</code>的方式递归通配所有包文件</li></ul><h4 id="6-下面代码输出什么"><a href="#6-下面代码输出什么" class="headerlink" title="6. 下面代码输出什么"></a>6. 下面代码输出什么</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line"><span class="string">"A"</span>: <span class="number">21</span>,</span><br><span class="line"><span class="string">"B"</span>: <span class="number">22</span>,</span><br><span class="line"><span class="string">"C"</span>: <span class="number">23</span>,</span><br><span class="line">&#125;</span><br><span class="line">counter := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line"><span class="keyword">if</span> counter == <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">"A"</span>)</span><br><span class="line">&#125;</span><br><span class="line">counter++</span><br><span class="line">fmt.Println(k, v)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"counter is "</span>, counter)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">A 21</span></span><br><span class="line"><span class="comment">B 22</span></span><br><span class="line"><span class="comment">C 23</span></span><br><span class="line"><span class="comment">counter is  3</span></span><br><span class="line"><span class="comment">或者</span></span><br><span class="line"><span class="comment">B 22</span></span><br><span class="line"><span class="comment">C 23</span></span><br><span class="line"><span class="comment">counter is  2</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><ul><li>Map 的遍历是无序的，因此若A在第一次循环，则可循环3次，若A不在第一次循环，则循环两次</li></ul><h4 id="7-break-的高级用法"><a href="#7-break-的高级用法" class="headerlink" title="7. break 的高级用法"></a>7. break 的高级用法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">/* local variable definition */</span></span><br><span class="line">a := <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* for loop execution */</span></span><br><span class="line">I:</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">a -= <span class="number">1</span></span><br><span class="line">fmt.Println(a)</span><br><span class="line"><span class="keyword">if</span> a &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">break</span> I <span class="comment">// 使得一次性退出两层循环</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-下面代码输出什么"><a href="#8-下面代码输出什么" class="headerlink" title="8. 下面代码输出什么"></a>8. 下面代码输出什么</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i := <span class="number">1</span></span><br><span class="line">    s := []<span class="keyword">string</span>&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>&#125;</span><br><span class="line">    i, s[i<span class="number">-1</span>] = <span class="number">2</span>, <span class="string">"Z"</span></span><br><span class="line">    fmt.Printf(<span class="string">"s: %v \n"</span>, s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">s: [Z,B,C]</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><ul><li>赋值顺序：先计算等号左边表达式取值，再考虑等号右边的赋值</li></ul><h4 id="9-下面代码输出什么"><a href="#9-下面代码输出什么" class="headerlink" title="9.下面代码输出什么"></a>9.下面代码输出什么</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ts := [<span class="number">2</span>]X&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i, t := <span class="keyword">range</span> ts[:] &#123;</span><br><span class="line">  <span class="keyword">switch</span> i &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    t.n = <span class="number">3</span></span><br><span class="line">    ts[<span class="number">1</span>].n = <span class="number">9</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    fmt.Println(ts[i].n, <span class="string">" "</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(ts) <span class="comment">// [&#123;0&#125; &#123;9&#125;]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ts := [<span class="number">2</span>]X&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> ts[:] &#123;</span><br><span class="line"><span class="keyword">switch</span> i &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">ts[<span class="number">1</span>].n = <span class="number">9</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">fmt.Println(ts[i].n, <span class="string">" "</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(ts) <span class="comment">// [&#123;0&#125; &#123;9&#125;]</span></span><br></pre></td></tr></table></figure><ul><li>切片操作生成新的切片，使用<code>range</code>返回参数循环变量均为变量副本，对其操作不会影响原切片</li><li>切片操作生成新的切片，但是共享底层数组，因此直接使用下标操作会同时生效</li></ul><h4 id="10-下面代码有什么问题"><a href="#10-下面代码有什么问题" class="headerlink" title="10. 下面代码有什么问题"></a>10. 下面代码有什么问题</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f, err := os.Open(<span class="string">"file"</span>)</span><br><span class="line">    <span class="keyword">defer</span> f.Close()<span class="comment">// 此处f可能为nil，导致defer中再次出现panic</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    b, err := ioutil.ReadAll(f)</span><br><span class="line">    <span class="built_in">println</span>(<span class="keyword">string</span>(b))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//修正代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f, err := os.Open(<span class="string">"file"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">    b, err := ioutil.ReadAll(f)</span><br><span class="line">    <span class="built_in">println</span>(<span class="keyword">string</span>(b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在函数使用场景下，应注意先判断<code>error</code>只有<code>error != nil</code>时，可认为返回值有效，然后进一步处理</li></ul><h4 id="11-下面代码有什么问题"><a href="#11-下面代码有什么问题" class="headerlink" title="11. 下面代码有什么问题"></a>11. 下面代码有什么问题</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"1"</span>)</span><br><span class="line">      wg.Done() </span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">    wg.Wait() <span class="comment">// panic here</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// panic: sync: WaitGroup is reused before previous Wait has returned</span></span><br></pre></td></tr></table></figure><ul><li>调用<code>Done()</code>后立刻调用<code>Add(1)</code>导致<code>Wait()</code>函数执行时，发现<code>wg</code>变量仍在被使用，误以为自己错误进入了<code>Wait()</code>函数而<code>panic</code></li><li>在使用<code>sync.WaitGroup</code>时，<code>Add(n)</code>就要配对n个<code>Done()</code>调用，否则会出现死锁</li></ul><h4 id="12-下面代码输出什么"><a href="#12-下面代码输出什么" class="headerlink" title="12. 下面代码输出什么"></a>12. 下面代码输出什么</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Slice []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSlice</span><span class="params">()</span> <span class="title">Slice</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make</span>(Slice, <span class="number">0</span>)</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Slice)</span> <span class="title">Add</span><span class="params">(elem <span class="keyword">int</span>)</span> *<span class="title">Slice</span></span> &#123;</span><br><span class="line">     *s = <span class="built_in">append</span>(*s, elem)</span><br><span class="line">    fmt.Print(elem)</span><br><span class="line">     <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := NewSlice()</span><br><span class="line">    <span class="keyword">defer</span> s.Add(<span class="number">1</span>).Add(<span class="number">2</span>)</span><br><span class="line">    s.Add(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output: 132</span></span><br></pre></td></tr></table></figure><ul><li><code>defer</code> 只会执行一级函数，对于循环调用，会提前计算到倒数第二级函数结果，仅在<code>defer</code>中执行最后一次调用</li></ul><h4 id="13-下面代码输出什么"><a href="#13-下面代码输出什么" class="headerlink" title="13. 下面代码输出什么"></a>13. 下面代码输出什么</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">alwaysFalse</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="keyword">switch</span> alwaysFalse()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">fmt.Println(<span class="string">"false"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">fmt.Println(<span class="string">"true"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>首先注意到，第六行大括号独占一行。因此可以参考<a href="https://gfw.go101.org/article/line-break-rules.html" target="_blank" rel="noopener">golang 代码断行规则</a></p></li><li><p>golang 在编译阶段，会在行尾是一下情况时，在其后插入分号</p><ul><li><p>标识符</p></li><li><p>整数、浮点数、虚部、码点、字符串字面表示形式</p><blockquote><p> 字面表示形式可以理解为变量在代码中的表现，例如值为15但字面表示形式可以是15、0xF、0b1111等多种字面表示形式</p></blockquote></li><li><p>break、continue、fallthrough、return</p></li><li>++、–</li><li>)、}、]</li><li>为了允许复杂语句完全显示在一个代码行中，分号可能被插在一个右小括号<code>)</code>或者右花括号<code>}</code>之前</li></ul></li><li><p>对于上述情况外的其他情况，分号需要自行插入</p></li><li><p>对于可能隐式插入分号的断句可以使用合法的<code>,</code>规避隐式分号的插入</p></li><li><p>在上述代码中，<code>alwaysFalse</code>函数只是被执行，但是没有被变量接收，等价于如下代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">alwaysFalse</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="keyword">switch</span> _ = alwaysFalse();&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">fmt.Println(<span class="string">"false"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">fmt.Println(<span class="string">"true"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码直接进入<code>case true</code>，若希望实现效果，应该改为如下形式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">alwaysFalse</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="keyword">switch</span> tmp := alwaysFalse()</span><br><span class="line">tmp &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">fmt.Println(<span class="string">"false"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">fmt.Println(<span class="string">"true"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仍然是个很奇怪的写法，使得代码可读性大大降低，非常不推荐</p></li><li><p>可以使用<code>go fmt</code>和<code>go vet</code>命令进行代码格式化，增加代码规范性，发现可能的逻辑错误</p></li></ul><h4 id="14-下面代码可以编译通过么"><a href="#14-下面代码可以编译通过么" class="headerlink" title="14. 下面代码可以编译通过么"></a>14. 下面代码可以编译通过么</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> x &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> A</span><br><span class="line">A:</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="keyword">goto</span> B</span><br><span class="line">B: <span class="comment">// 编译失败，tag后缺少语句</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">goto</span> C</span><br><span class="line">C:</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编译器会在7行和14行花括号前加入<code>;</code>使得tag后生成一个由<code>;</code>单独构成的空语句，从而使得<code>A</code>和<code>C</code>两个tag合法</li><li>可在13行后加入<code>;</code>使得语法编译通过</li></ul><h4 id="15-下面代码输出什么"><a href="#15-下面代码输出什么" class="headerlink" title="15. 下面代码输出什么"></a>15. 下面代码输出什么</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(strings.TrimRight(<span class="string">"ABBA"</span>, <span class="string">"BA"</span>)) <span class="comment">// ""</span></span><br><span class="line">  fmt.Println(strings.TrimRight(<span class="string">"ABDBABBBA"</span>, <span class="string">"BA"</span>)) <span class="comment">// "ABD"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>输出空字符串，<code>TrimRight</code>会将第二字符串中出现的全部字符从第一字符串右边开始匹配直到匹配不上为止</li><li><code>TrimSuffix</code>可以完成去除后缀的效果</li></ul><h4 id="16-下面代码输出什么"><a href="#16-下面代码输出什么" class="headerlink" title="16. 下面代码输出什么"></a>16. 下面代码输出什么</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"> x++ </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  init()</span><br><span class="line">  fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编译失败。<code>init</code>函数不能被调用</li><li><code>main()</code>函数不可带参数且不能有返回</li></ul><h4 id="17-下面代码输出什么"><a href="#17-下面代码输出什么" class="headerlink" title="17. 下面代码输出什么"></a>17. 下面代码输出什么</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee User</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span><span class="title">SetName</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(name)</span><br><span class="line">u.Name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  e := <span class="built_in">new</span>(Employee)</span><br><span class="line">e.SetName()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编译失败，<code>SetName</code>为User实现的函数，<code>Employee</code>是重新定义的类，需要重新实现<code>SetName</code>实例才可调用</li><li>修改方法<ol><li>重写<code>func (e *Employee)SetName(name string)</code>函数</li><li>将<code>User</code>作为<code>Employee</code>的匿名变量，隐式调用<code>User</code>的<code>SetName</code>函数</li><li>同时使用1和2修改，导致两个<code>SetName</code>的情况时，调用<code>User</code>的<code>SetName</code>需要显式调用</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;blockquote&gt;
&lt;p&gt;学习自&lt;a href=&quot;https://www.runoob.com/go/go-concurrent.html&quot; target=&quot;_blank&quot; 
      
    
    </summary>
    
      <category term="技术" scheme="https://thomstrong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Golang" scheme="https://thomstrong.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Java 基础复习</title>
    <link href="https://thomstrong.github.io/2019/07/15/first-java/"/>
    <id>https://thomstrong.github.io/2019/07/15/first-java/</id>
    <published>2019-07-15T02:54:08.000Z</published>
    <updated>2019-07-23T07:49:31.619Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><blockquote><p>参考<a href="https://www.liaoxuefeng.com/wiki/1252599548343744" target="_blank" rel="noopener">教程</a></p></blockquote><h3 id="一些基本知识"><a href="#一些基本知识" class="headerlink" title="一些基本知识"></a>一些基本知识</h3><h4 id="语言类型"><a href="#语言类型" class="headerlink" title="语言类型"></a>语言类型</h4><ul><li><p>Java介于编译型语言和解释型语言之间，将代码编译成一种“字节码”，针对不同平台编写虚拟机，不同平台的虚拟机负责加载字节码并执行，这样就实现了“一次编写，到处运行”的效果</p><blockquote><ul><li>编译型语言如C、C++，代码是直接编译成机器码执行，需要考虑跨平台问题</li><li>解释型语言如Python、Ruby，可以由解释器直接加载源码然后运行，代价是运行效率太低</li></ul></blockquote></li></ul><h4 id="EE-SE-ME"><a href="#EE-SE-ME" class="headerlink" title="EE/SE/ME"></a>EE/SE/ME</h4><ul><li>Java SE：Standard Edition，标准版，包含标准的JVM和标准库</li><li>Java EE：Enterprise Edition，在Java SE的基础上加上了大量的API和库，以便方便开发Web应用、数据库、消息服务等</li><li><p>Java ME：Micro Edition，针对嵌入式设备的“瘦身版”，Java SE的标准库无法在Java ME上使用，Java ME的虚拟机也是“瘦身版”</p></li><li><p>Java EE &gt; Java SE &gt; Java ME，Java EE的应用使用的虚拟机和Java SE完全相同，而Java SE的标准库无法在Java ME上使用</p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────────────────┐</span><br><span class="line">│Java EE                    │</span><br><span class="line">│    ┌────────────────────┐ │</span><br><span class="line">│    │Java SE             │ │</span><br><span class="line">│    │    ┌─────────────┐ │ │</span><br><span class="line">│    │    │   Java ME   │ │ │</span><br><span class="line">│    │    └─────────────┘ │ │</span><br><span class="line">│    └────────────────────┘ │</span><br><span class="line">└───────────────────────────┘</span><br></pre></td></tr></table></figure></li></ul><h4 id="JDK-JRE-JSR-JCP"><a href="#JDK-JRE-JSR-JCP" class="headerlink" title="JDK/JRE/JSR/JCP"></a>JDK/JRE/JSR/JCP</h4><ul><li><p>JDK：Java Development Kit，JDK除了包含JRE，还提供了编译器、调试器等开发工具</p></li><li><p>JRE：Java Runtime Environment，JRE就是运行Java字节码的虚拟机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> ┌─    ┌──────────────────────────────────┐</span><br><span class="line"> │     │     Compiler, debugger, etc.     │</span><br><span class="line"> │     └──────────────────────────────────┘</span><br><span class="line">JDK ┌─ ┌──────────────────────────────────┐</span><br><span class="line"> │  │  │                                  │</span><br><span class="line"> │ JRE │      JVM + Runtime Library       │</span><br><span class="line"> │  │  │                                  │</span><br><span class="line"> └─ └─ └──────────────────────────────────┘</span><br><span class="line">       ┌───────┐┌───────┐┌───────┐┌───────┐</span><br><span class="line">       │Windows││ Linux ││ macOS ││others │</span><br><span class="line">       └───────┘└───────┘└───────┘└───────┘</span><br></pre></td></tr></table></figure></li><li><p>JSR规范：Java Specification Request</p></li><li>JCP组织：Java Community Process</li></ul><h4 id="Jdk中的命令"><a href="#Jdk中的命令" class="headerlink" title="Jdk中的命令"></a>Jdk中的命令</h4><ul><li>java：这个可执行程序其实就是JVM，运行Java程序，就是启动JVM，然后让JVM执行指定的编译后的代码</li><li>javac：这是Java的编译器，它用于把Java源码文件（以<code>.java</code>后缀结尾）编译为Java字节码文件（以<code>.class</code>后缀结尾）</li><li>jar：用于把一组<code>.class</code>文件打包成一个<code>.jar</code>文件，便于发布</li><li>javadoc：用于从Java源码中自动提取注释并生成文档</li><li>jdb：Java调试器，用于开发阶段的运行调试</li></ul><h3 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h3><blockquote><p>Google代码规范：<a href="https://google.github.io/styleguide/javaguide.html" target="_blank" rel="noopener">Google Java Code Style</a></p><p>阿里巴巴代码规约IDE插件：<a href="https://github.com/alibaba/p3c/wiki" target="_blank" rel="noopener">alibaba/p3c</a></p></blockquote><h4 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h4><ul><li>一个<code>.java</code>文件只能包含一个<code>public</code>类，但可以包含多个非<code>public</code>类。如果有<code>public</code>类，文件名必须和<code>public</code>类的名字相同。</li><li>使用<code>javac</code>可以将<code>.java</code>源码编译成<code>.class</code>字节码</li><li>使用<code>java</code>可以运行一个已编译的Java程序，参数是<strong>类名</strong>，如<code>java HelloWorld</code>而不是<code>java HelloWorld.class</code> 或 <code>java HelloWorld.java</code></li></ul><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><ul><li>Java是面向对象的语言，一个程序的基本单位就是<code>class</code>，<code>class</code>是关键字</li><li>class命名使用大驼峰</li><li>Java入口程序规定的方法必须是静态方法，方法名必须为<code>main</code>，括号内的参数必须是String数组</li></ul><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><ul><li><p>整数类型：byte(1Byte)，short(2Byte)，int(4Byte)，long(8Byte)</p></li><li><p>浮点数类型：float(4Byte)，double(8Byte)</p></li><li><p>字符类型：char(2Byte)</p></li><li><p>布尔类型：boolean</p><blockquote><p>理论上存储布尔类型只需要1 bit，但JVM内部会把<code>boolean</code>表示为4字节整数</p></blockquote></li><li><p>定义变量的时候，如果加上<code>final</code>修饰符，这个变量就变成了常量。常量名通常全部大写</p></li><li>有些时候，类型的名字太长，写起来比较麻烦。如果想省略变量类型，可以使用<code>var</code>关键字<strong>(java 10+)</strong></li></ul><h4 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h4><ul><li>整数的除法对于除数为0时运行时将报错，但编译不会报错；浮点数除<code>0</code>时，不会报错，但会返回几个特殊值：<ul><li><code>NaN</code>，0.0/0，表示Not a Number</li><li><code>Infinity</code>，正数除以0，表示无穷大</li><li><code>-Infinity</code>，负数除以0，表示负无穷大</li></ul></li><li>优先级顺序（可通过加括号确保运算顺序不出错）<ul><li><code>()</code></li><li><code>!</code> <code>~</code> <code>++</code> <code>--</code></li><li><code>*</code> <code>/</code> <code>%</code></li><li><code>+</code> <code>-</code></li><li><code>&lt;&lt;</code> <code>&gt;&gt;</code> <code>&gt;&gt;&gt;</code></li><li><code>&amp;</code></li><li><code>|</code></li><li><code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code></li></ul></li><li>运算结果应以运算的成员中较高精度的为准，否则编译错误</li><li>强制转换应该考虑溢出的问题</li><li>整型数可以精确表示，浮点数不行</li><li><p>由于浮点数存在运算误差，所以通过判断两个浮点数之差的绝对值是否小于一个很小的数来判断两浮点数是否相等，例如<code>Math.abs(x - 0.1) &lt; 0.00001</code></p></li><li><p>浮点数强转<code>int</code>则舍去小数部分，若超出范围，则赋值为整数最大值</p></li><li>三元运算<code>b ? x : y</code>后面的类型必须相同</li></ul><h4 id="字符和字符串"><a href="#字符和字符串" class="headerlink" title="字符和字符串"></a>字符和字符串</h4><ul><li><p>Java在内存中总是使用Unicode表示字符</p></li><li><p>字符串是不可变的变量，变量名只是对应字符串的引用。基本类型的变量是“持有”某个数值，引用类型的变量是“指向”某个对象。</p></li></ul><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul><li>数组所有元素初始化为默认值，整型都是<code>0</code>，浮点型是<code>0.0</code>，布尔型是<code>false</code>；</li><li>数组一旦创建后，大小就不可改变。</li><li><code>Arrays.toString(list)</code>快速打印一维数组，<code>Arrays.deepToString()</code>打印多维数组</li></ul><h3 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><ul><li>如果我们自定义了一个构造方法，那么，编译器就<strong>不再</strong>自动创建默认构造方法</li><li>可以在无参构造方法的第一行使用<code>this(&quot;Unnamed&quot;);</code>的方式调用含参构造方法</li></ul><h4 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h4><ul><li>Java只允许一个class继承自一个类，因此，一个类有且仅有一个父类。只有<code>Object</code>特殊，它没有父类。</li><li>任何<code>class</code>的构造方法，第一行语句必须是调用父类的构造方法。如果没有明确地调用父类的构造方法，编译器会帮我们自动加一句<code>super();</code></li><li><code>protected</code>允许子类访问父类的字段和方法</li><li>子类<em>不会继承</em>任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的。</li><li><code>instanceof</code>操作符，可以先判断一个实例究竟是不是某种类型</li><li><code>overload</code>重载，指对同一个函数名通过控制参数不同重载为不同函数；方法名相同，并且返回值也相同，就是<code>Override</code>覆写；方法名相同，方法参数相同，但方法返回值不同，也是不同的方法。在Java程序中，出现这种情况，编译器会报错。</li><li><p>Java的实例方法调用是基于运行时的实际类型的动态调用，而非变量的声明类型。虽然声明时使用的是父类，实例化用的子类，调用方法时仍然会使用子类重载后（如果有）的方法。这种运行期才能动态决定调用的子类方法的特性称为<strong>多态</strong>。</p></li><li><p>函数参数中的三点<code>func(int… intList)</code>意为传入参数时可以使用<code>func(a,b,c)</code>去代替<code>func(new int[]{a, b, c})</code>的方式传入。</p></li><li>用<code>final</code>修饰的方法不能被<code>Override</code></li></ul><h4 id="面向抽象编程和接口"><a href="#面向抽象编程和接口" class="headerlink" title="面向抽象编程和接口"></a>面向抽象编程和接口</h4><ul><li><p>通过<code>abstract</code>定义的方法是抽象方法，它只有定义，没有实现。抽象方法定义了子类必须实现的接口规范</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>定义了抽象方法的class必须被定义为抽象类，从抽象类继承的子类必须实现抽象方法</p></li><li><p><code>interface</code>，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是<code>public abstract</code>的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name + <span class="string">" run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>一个<code>interface</code>可以继承自另一个<code>interface</code>。<code>interface</code>继承自<code>interface</code>使用<code>extends</code>，它相当于扩展了接口的方法</p></li><li><p>在接口中，可以定义<code>default</code>方法。实现类可以不必覆写<code>default</code>方法。<code>default</code>方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是<code>default</code>方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。(JDK&gt;=1.8)</p></li></ul><h4 id="静态字段和静态方法"><a href="#静态字段和静态方法" class="headerlink" title="静态字段和静态方法"></a>静态字段和静态方法</h4><ul><li>用<code>static</code>修饰的字段，称为静态字段。静态字段只有一个共享“空间”，所有实例都会共享该字段。使用<code>类名.静态字段</code>的方式访问静态字段。</li><li>使用<code>static</code>修饰类的方法函数则该方法为静态方法</li></ul><h4 id="包"><a href="#包" class="headerlink" title="包"></a>包</h4><ul><li>使用<code>package</code>关键字声明类所在的包名称，如<code>package thomstrong</code></li><li><p>位于同一个包的类，可以访问包作用域的字段和方法。不用<code>public</code>、<code>protected</code>、<code>private</code>修饰的字段和方法就是包作用域。例如，<code>Person</code>和<code>Main</code>在同一个包下，<code>Main</code>中就可以直接<code>new Person()</code>创建实例。</p></li><li><p>如果两个类不在同一个包下，则需要写出完整类名或通过<code>import</code>关键字进行引用</p></li><li><p>编译器查找类名方法</p><ul><li>如果是完整类名，就直接根据完整类名查找这个<code>class</code></li><li><p>如果是简单类名，按下面的顺序依次查找：</p><ul><li>查找当前<code>package</code>是否存在这个<code>class</code></li><li>查找<code>import</code>的包是否包含这个<code>class</code></li><li>查找<code>java.lang</code>包是否包含这个<code>class</code></li></ul></li><li><p>以上均为找到，编译报错</p></li></ul></li><li><p>class的时候，编译器会自动帮我们做两个import动作</p><ul><li>默认自动<code>import</code>当前<code>package</code>的其他<code>class</code></li><li>默认自动<code>import java.lang.*</code></li></ul></li><li><p>当有两个<code>class</code>名称相同时，其中一个可以使用import方法，另外一个只能写完整类名</p></li><li>为了避免名字冲突，我们需要确定唯一的包名。推荐的做法是使用<strong>倒置的域名</strong>来确保唯一性。例如：<ul><li>org.apache</li><li>org.apache.commons.log</li><li>com.liaoxuefeng.sample</li></ul></li></ul><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><ul><li>定义为<code>public</code>的<code>class</code>、<code>interface</code>可以被其他任何类访问</li><li>定义为<code>private</code>的<code>field</code>、<code>method</code>无法被其他类访问</li><li>定义为<code>protected</code>作用于继承关系。定义为<code>protected</code>的字段和方法可以被子类访问，以及子类的子类</li><li><code>package</code>作用域允许访问同一个<code>package</code>的没有<code>public</code>、<code>private</code>修饰的<code>class</code>，以及没有<code>public</code>、<code>protected</code>、<code>private</code>修饰的字段和方法。包没有父子关系，<code>com.apache</code>和<code>com.apache.abc</code>是不同的包</li><li>尽可能把局部变量的作用域缩小，尽可能延后声明局部变量</li><li><code>final</code>可以阻止<code>class</code>被继承、阻止方法被覆写、阻止变量被赋值</li></ul><h4 id="classpath-和-jar"><a href="#classpath-和-jar" class="headerlink" title="classpath 和 jar"></a>classpath 和 jar</h4><ul><li><p><code>classpath</code>是JVM用到的一个环境变量，它用来指示JVM如何搜索class</p></li><li><p>不要把任何Java核心库添加到classpath中，JVM根本不依赖classpath加载核心库</p></li><li><code>MANIFEST.MF</code>文件可以提供jar包的信息，如<code>Main-Class</code>，这样可以直接运行jar包</li><li>JVM自带的标准库rt.jar不要写到classpath中，写了反而会干扰JVM的正常运行</li></ul><h3 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h3><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><blockquote><p><code>String</code>内部是通过一个<code>char[]</code>数组表示的，<code>CharSequence</code>是<code>String</code>的父类</p></blockquote><ul><li><p>Java编译器在编译期，会自动把所有相同的字符串当作一个对象放入常量池，因此相同字符串赋值的变量会指向相同的对象</p></li><li><p>Java的<code>String</code>和<code>char</code>在内存中总是以Unicode编码表示</p></li><li><p>常用函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断字符串相等</span></span><br><span class="line"><span class="string">"hello"</span>.equals(<span class="string">"HELLO"</span>.toLowerCase()); <span class="comment">//true</span></span><br><span class="line"><span class="string">"Hello"</span>.equalsIgnoreCase(<span class="string">"HELLO"</span>); <span class="comment">//true</span></span><br><span class="line"><span class="comment">// 搜索子串</span></span><br><span class="line"><span class="string">"Hello"</span>.indexOf(<span class="string">"l"</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="string">"Hello"</span>.lastIndexOf(<span class="string">"l"</span>); <span class="comment">// 3</span></span><br><span class="line"><span class="string">"Hello"</span>.startsWith(<span class="string">"He"</span>); <span class="comment">// true</span></span><br><span class="line"><span class="string">"Hello"</span>.endsWith(<span class="string">"lo"</span>); <span class="comment">// true  </span></span><br><span class="line"><span class="comment">// 获取子串</span></span><br><span class="line"><span class="string">"Hello"</span>.substring(<span class="number">2</span>); <span class="comment">// "llo"</span></span><br><span class="line"><span class="string">"Hello"</span>.substring(<span class="number">2</span>, <span class="number">4</span>); <span class="string">"ll"</span></span><br><span class="line"><span class="comment">// 去除首位空格</span></span><br><span class="line"><span class="string">"  \tHello\r\n "</span>.trim(); <span class="comment">// "Hello"，去除了英文空格等空白符号</span></span><br><span class="line"><span class="comment">//java 11+</span></span><br><span class="line"><span class="string">"\u3000Hello\u3000"</span>.strip(); <span class="comment">// "Hello"，除了trim的功能还将类似中文的空格字符\u3000也移除</span></span><br><span class="line"><span class="string">" Hello "</span>.stripLeading(); <span class="comment">// "Hello "</span></span><br><span class="line"><span class="string">" Hello "</span>.stripTrailing(); <span class="comment">// " Hello"</span></span><br><span class="line"><span class="comment">// 判空</span></span><br><span class="line"><span class="string">""</span>.isEmpty(); <span class="comment">// true，因为字符串长度为0</span></span><br><span class="line"><span class="string">"  "</span>.isEmpty(); <span class="comment">// false，因为字符串长度不为0</span></span><br><span class="line"><span class="comment">// java 11+</span></span><br><span class="line"><span class="string">"  \n"</span>.isBlank(); <span class="comment">// true，因为只包含空白字符</span></span><br><span class="line"><span class="string">" Hello "</span>.isBlank(); <span class="comment">// false，因为包含非空白字符</span></span><br><span class="line"><span class="comment">// 替换子串</span></span><br><span class="line"><span class="string">"abc"</span>.replace(<span class="string">'a'</span>, <span class="string">'c'</span>); <span class="comment">// cbc</span></span><br><span class="line"><span class="string">"abc"</span>.replace(<span class="string">"ab"</span>, <span class="string">"c"</span>); <span class="comment">// cc</span></span><br><span class="line"><span class="string">"abc"</span>.replaceAll(<span class="string">"[abc]"</span>, <span class="string">"z"</span>); <span class="comment">//zzz</span></span><br><span class="line"><span class="comment">// 分割字符串</span></span><br><span class="line">String s = <span class="string">"A,B,C,D"</span>;</span><br><span class="line">String[] ss = s.split(<span class="string">"\\,"</span>); <span class="comment">// &#123;"A", "B", "C", "D"&#125;</span></span><br><span class="line"><span class="comment">// 字符串拼接</span></span><br><span class="line">String[] arr = &#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>&#125;;</span><br><span class="line">String s = String.join(<span class="string">"***"</span>, arr); <span class="comment">// "A***B***C"</span></span><br><span class="line"><span class="comment">// 类型转换</span></span><br><span class="line">String.valueOf(<span class="number">123</span>); <span class="comment">// "123"</span></span><br><span class="line">Integer.parseInt(<span class="string">"123"</span>); <span class="comment">// 123</span></span><br><span class="line">Integer.parseInt(<span class="string">"ff"</span>, <span class="number">16</span>); <span class="comment">// 按十六进制转换，255</span></span><br><span class="line">Boolean.parseBoolean(<span class="string">"FALSE"</span>); <span class="comment">// false</span></span><br><span class="line"><span class="string">"Hello"</span>.toCharArray();<span class="comment">// String -&gt; char[]</span></span><br><span class="line"><span class="keyword">new</span> String(cs); <span class="comment">// char[] -&gt; String</span></span><br><span class="line"><span class="comment">// 转码</span></span><br><span class="line"><span class="keyword">byte</span>[] b2 = <span class="string">"Hello"</span>.getBytes(<span class="string">"UTF-8"</span>); <span class="comment">// 按UTF-8编码转换</span></span><br><span class="line">String s2 = <span class="keyword">new</span> String(b2, StandardCharsets.UTF_8); <span class="comment">// 按UTF-8转换</span></span><br><span class="line"><span class="keyword">byte</span>[] b2 = <span class="string">"Hello"</span>.getBytes(<span class="string">"GBK"</span>); <span class="comment">// 按GBK编码转换</span></span><br><span class="line">String s1 = <span class="keyword">new</span> String(b2, <span class="string">"GBK"</span>); <span class="comment">// 按GBK转换</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="StringBuilder-StringJoiner"><a href="#StringBuilder-StringJoiner" class="headerlink" title="StringBuilder/ StringJoiner"></a>StringBuilder/ StringJoiner</h4><ul><li><p>使用循环加的方式拼接字符串时，需要频繁的创建新的字符串对象扔掉旧的字符串，浪费内存。因此使用<code>StringBuilder</code>类</p></li><li><p>常用函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    sb.append(<span class="string">','</span>);</span><br><span class="line">    sb.append(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sb.append(<span class="string">"Bob"</span>)</span><br><span class="line">  .append(<span class="string">"!"</span>)</span><br><span class="line">  .insert(<span class="number">0</span>, <span class="string">"Hello, "</span>);</span><br><span class="line"></span><br><span class="line">String s = sb.toString();</span><br><span class="line"></span><br><span class="line">sb.delete(<span class="number">0</span>, <span class="number">2</span>); <span class="comment">// 删除第一和第二个字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用joiner进行高效拼接，String.join()方法即使用stringJoiner实现</span></span><br><span class="line">StringJoiner stringJoiner = <span class="keyword">new</span> StringJoiner(<span class="string">","</span>, <span class="string">"hi~"</span>, <span class="string">"!"</span>); <span class="comment">//StringJoiner(delimiter, [prefix, suffix])</span></span><br><span class="line">stringJoiner.add(<span class="string">"ming"</span>).add(<span class="string">"hong"</span>).add(<span class="string">"gang"</span>);</span><br><span class="line">System.out.println(stringJoiner.toString()); <span class="comment">// hi~ming,hong,gang!</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="枚举类-enum"><a href="#枚举类-enum" class="headerlink" title="枚举类 enum"></a>枚举类 enum</h3><ul><li><p>使用<code>enum</code>关键字来定义枚举类型</p></li><li><p>枚举类型是一个<code>class</code>，不能与非枚举类进行比较或向类型转换</p></li><li><p>枚举类型变量也是引用类型变量，但是可以使用<code>==</code>去判断相等，且可以用在<code>switch</code>语句中</p></li><li><p>枚举类型无法被继承</p></li><li><p>常用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般定义</span></span><br><span class="line"><span class="keyword">enum</span> Weekday &#123;</span><br><span class="line">    SUN, MON, TUE, WED, THU, FRI, SAT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String s = Weekday.SUN.name(); <span class="comment">// "SUN"</span></span><br><span class="line"><span class="keyword">int</span> n = Weekday.MON.ordinal(); <span class="comment">// 返回MON的位置，1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带public方法的定义</span></span><br><span class="line"><span class="keyword">enum</span> Weekday &#123;</span><br><span class="line">    MON(<span class="number">1</span>), TUE(<span class="number">2</span>), WED(<span class="number">3</span>), THU(<span class="number">4</span>), FRI(<span class="number">5</span>), SAT(<span class="number">6</span>), SUN(<span class="number">0</span>); <span class="comment">// 使用下面声明的构造方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> dayValue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Weekday</span><span class="params">(<span class="keyword">int</span> dayValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dayValue = dayValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Weekday day = Weekday.SUN;</span><br><span class="line">System.out.println(day.dayValue); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h3><ul><li><p>基本类型不可赋值为null，而引用类型可以</p></li><li><p>直接把<code>int</code>变为<code>Integer</code>的赋值写法<code>Integer n = 100</code>，称为自动装箱（Auto Boxing），反过来，把<code>Integer</code>变为<code>int</code>的赋值写法<code>int i = n</code>，称为自动拆箱（Auto Unboxing）。自动装箱和自动拆箱只发生在编译阶段，目的是为了少写代码。</p></li><li><p>装箱和拆箱会影响代码的执行效率，因为编译后的<code>class</code>代码是严格区分基本类型和引用类型的。并且，自动拆箱执行时可能会报<code>NullPointerException</code></p></li><li><p>对于<code>Integer</code>对象，若值较小，由于缓存优化的原因，可能会使得 <code>==</code>判断为<code>true</code></p></li></ul><h3 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h3><ul><li>一种特殊的遵循一定编程原则的Java类，它通常用来实现一些比较常用的简单功能，并可以很容易的被重用或者是插入其他应用程序中去</li><li>Bean的编写规范包括Bean类的构造方法、定义属性和访问方法(<code>getter</code>/<code>setter</code>)编写规则</li></ul><h3 id="Java常用工具包"><a href="#Java常用工具包" class="headerlink" title="Java常用工具包"></a>Java常用工具包</h3><ul><li><p>Math：数学计算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.random(); <span class="comment">// 生成[0,1)间的随机数</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>Random：生成伪随机数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random rd = <span class="keyword">new</span> Random(); <span class="comment">// 不指定随机种子，以当前时间戳为种子，得到与运行时间相关的固定随机序列</span></span><br><span class="line">Random rd = <span class="keyword">new</span> Random(<span class="number">1234</span>); <span class="comment">// 指定随机种子，获得固定的随机序列</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>SecureRandom：生成安全的随机数</p><ul><li><p><code>SecureRandom</code>的安全性是通过操作系统提供的安全的随机种子来生成随机数。这个种子是通过CPU的热噪声、读写磁盘的字节、网络流量等各种随机事件产生的“熵”</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SecureRandom sr = <span class="keyword">new</span> SecureRandom();</span><br><span class="line">System.out.println(sr.nextInt(<span class="number">100</span>));</span><br><span class="line">SecureRandom.getInstanceStrong(); <span class="comment">// 获取高强度安全随机数生成器</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><ul><li><code>Throwable</code>是异常体系的根，它继承自<code>Object</code>。<code>Throwable</code>有两个体系：<code>Error</code>和<code>Exception</code>，<code>Error</code>表示严重的错误，程序对此一般无能为力</li></ul><ul><li>必须捕获的异常或者用<code>throws</code>声明，包括<code>Exception</code>及其子类，但不包括<code>RuntimeException</code>及其子类，这种类型的异常称为Checked Exception。</li><li>不需要捕获的异常，包括<code>Error</code>及其子类，<code>RuntimeException</code>及其子类。</li><li>可以用<code>try ... catch</code>捕获。把可能发生异常的语句放在<code>try { ... }</code>中，然后使用<code>catch</code>捕获对应的<code>Exception</code>及其子类。多个<code>catch</code>语句只有一个能被执行，因此编写代码时需要考虑好<code>catch</code>的顺序，将子类写在前面，父类写在后面。</li><li><code>finally</code>语句不是必须的，可写可不写；<code>finally</code>总是最后执行且无论是否发生异常，因此有<code>finally</code>存在<code>return</code>将以<code>finally</code>中的return为准。</li><li>当<code>catch</code>和<code>finally</code>都抛出了异常时，<code>catch</code>中的异常将会被屏蔽掉</li><li>通过<code>printStackTrace()</code>可以打印出方法的调用栈</li><li><code>BaseException</code>需要从一个适合的<code>Exception</code>派生，通常建议从<code>RuntimeException</code>派生</li><li>要执行<code>assert</code>语句，必须给Java虚拟机传递<code>-enableassertions</code>（可简写为<code>-ea</code>）参数启用断言。断言只应该用于开发和测试阶段。多数时候用在单元测试中。</li><li><code>Logger logger = Logger.getGlobal();</code>可以使用这样的方式声明java jdk 自带的logger，但是大多情况下不使用使用这种方法，更多使用<code>Log4j</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;blockquote&gt;
&lt;p&gt;参考&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/1252599548343744&quot; target=&quot;_bla
      
    
    </summary>
    
      <category term="技术" scheme="https://thomstrong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="https://thomstrong.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>2019猿辅导服务器端日常实习面经</title>
    <link href="https://thomstrong.github.io/2019/07/12/yuanfudao/"/>
    <id>https://thomstrong.github.io/2019/07/12/yuanfudao/</id>
    <published>2019-07-12T01:18:49.000Z</published>
    <updated>2019-07-15T03:02:08.363Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><blockquote><p>整体分为两面，</p><p>一面面试官是张梦南（之前没有关注最强大脑，后来才听说），主要基础知识和项目中基础知识的介绍，一道算法题；</p><p>二面面试官中年，感觉资历更老一些，主要问项目，一道算法题</p><p>整体氛围感觉还是很轻松的，答不上来的也都会简单提示然后最后会给出答案。</p></blockquote><h3 id="写在最前面"><a href="#写在最前面" class="headerlink" title="写在最前面"></a>写在最前面</h3><p>整体感受非常nice，对接的hr很照顾面试人的感受，因为怕迟到，早去了一小时左右，但hr很贴心的一直在考虑我这边等待时间太长，帮我提前找了面试官。公司没有仔细参观，但是整体环境感觉挺不错。</p><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><blockquote><p>发挥的比较不好，面试复习过的内容面试过程中大部分都想不起来或者很费劲才想起来，可能就是死记硬背带来的问题吧…</p></blockquote><ul><li><p>首先自我介绍，然后讲到简历中的实习经历，就顺着问了一些里面的具体内容</p></li><li><p>为什么想做后端？</p></li><li><p>数据库事务的隔离级别</p></li><li><p>数据库事务的ACID特性</p></li><li><p>写mysql语句</p><ul><li><p>1.查询user表中男性和女性年龄最大的两个人的名字 2.如何提高查询速度？</p><blockquote><p>select name from account where (sex, age) in (select sex,max(age) from account group by sex);</p><ul><li><p>这里给的一个参考答案，面试的时候写的是错的，但是可能大概意思是对的吧…因为太久没有直接写sql语句了，基本都是由框架提供的方法函数完成</p></li><li><p>提高效率上，考虑到group by方法，我提出了在sex上建索引的方式，但实际上因为性别只有两个，创建索引能够带来的收益也不是很大，甚至会变慢</p></li></ul></blockquote></li><li><p>查询年龄大于50岁的所有男性 2.如何提高查询速度</p><blockquote><p>select * from account where sex=’男’ and age&gt;50;</p><ul><li>这个sql比较简单，但是提高查询速度上还是需要进一步理解索引的适用场景。这里我回答的是在sex和age上建立复合索引，sex先，age后</li></ul></blockquote></li></ul></li><li><p>对NoSQL有了解么，为什么（有一个实习经历里）用了mongodb而不是用关系型数据库？</p><blockquote><p>回答是可能存在有些数据没有某些字段的情况（被反驳可以在那些字段使用null）和需要存储数据等类json结构的数据，只从表层上回答了一些不是最关键的原因。最后小声bb了个分布式存储，因为对当时数据库的选择原因的确没有多问，只是跟着做而已…</p><p><a href="https://thomstrong.github.io/2019/07/02/SQL-vs-NoSQL/#more">SQL vs NoSQL</a> </p></blockquote></li><li><p>对java了解多少，我们的后端主要是java开发</p><blockquote><p>简单的应用吧，能够照着原有代码学习，之后的想法也是转java</p></blockquote></li><li><p>…（基础和项目的问题大概就记得这么多吧）</p></li><li><p>算法题</p><blockquote><p>基础答得很不好很不顺利，到这里看着题面比较简单，有些急于表现自己，但是过程中有些迷茫的地方老是绕不过去，但是面试官很耐心的在引导。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">描述：给一个二叉树，然后给一个想要删除的节点值的list，从中删除这些节点。当被删除节点有孩子时，左右孩子分别变为根，返回删除过后所有的根节点</span><br><span class="line">示例：树</span><br><span class="line">        1</span><br><span class="line">     2     3</span><br><span class="line">   4      5  6     待删除节点[1,3]，返回节点[2,5,6]</span><br><span class="line">   </span><br><span class="line">思路：</span><br><span class="line">1. 递归，删除左子树中的所有待删节点，删除右子树中待删节点</span><br><span class="line">2. 讨论根节点，</span><br><span class="line">1）若根节点需要删除，则直接返回左子树根序列+右子树根序列</span><br><span class="line">2）若根节点不需要删除，分别查看左右子树处理后的根序列，</span><br><span class="line">2.1）如果没有左孩子，将左孩子置空</span><br><span class="line">2.2）如果没有右孩子，将右孩子置空</span><br><span class="line">    3.3）将根插入结果集返回</span><br></pre></td></tr></table></figure></li></ul><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><blockquote><p>相对顺利一些，之前的项目经历讲的顺利一些，算法题是一道很常规题，发挥正常</p></blockquote><ul><li>首先介绍一下自己之前的项目</li><li>在xxx线上实习中大概用多少时间在实习上？</li><li>你认为在xxx项目中，比较可能造成访问速度瓶颈的地方是什么</li><li>对于请求的瓶颈你是如何处理优化的</li><li><p>在数据请求上有没有做缓存之类的？什么场景下需要进行缓存？</p></li><li><p>（针对简历中提到的java spring）你对java spring 的了解，（建立中体现更多接触的是python语言）和对python一些框架的对比</p></li><li><p>…（项目相关问题到这里）</p></li><li><p>算法题</p><blockquote><p>一道算法与数据结构考试题，很基础</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">描述：根据二叉树的先序遍历和中序遍历，推导二叉树原始结构</span><br><span class="line">思路：先序遍历的第一个为树根，找到中序遍历对应的根后，左边的是左子树元素，右边是右子树元素，依次递归即可。</span><br></pre></td></tr></table></figure></li></ul><h3 id="hr面"><a href="#hr面" class="headerlink" title="hr面"></a>hr面</h3><ul><li>在先前的公司都是干什么工作</li><li>先前公司大概规模是多大？主要是做些什么？</li><li>一个产品对几个开发？</li><li>一周几天，入职时间等等常规问题</li></ul><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>欢迎发送简历到<a href="mailto:thomstrong.1996@gmail.com" target="_blank" rel="noopener">邮箱</a>内推</p><p>jd见：<a href="http://hr.yuanfudao.com/#/jobs?location=北京市&amp;_k=np0baw" target="_blank" rel="noopener">职位描述</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;blockquote&gt;
&lt;p&gt;整体分为两面，&lt;/p&gt;
&lt;p&gt;一面面试官是张梦南（之前没有关注最强大脑，后来才听说），主要基础知识和项目中基础知识的介绍，一道算法题；&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="技术" scheme="https://thomstrong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面经" scheme="https://thomstrong.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="https://thomstrong.github.io/2019/07/10/sort-algorithm/"/>
    <id>https://thomstrong.github.io/2019/07/10/sort-algorithm/</id>
    <published>2019-07-09T16:18:50.000Z</published>
    <updated>2020-01-31T17:36:20.014Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><blockquote><p>参考<a href="https://blog.csdn.net/justloveyou_/article/details/72730597" target="_blank" rel="noopener">博文 </a>/ 图片来自<a href="https://mp.weixin.qq.com/s/Qf416rfT4pwURpW3aDHuCg" target="_blank" rel="noopener">微信推送文章</a></p></blockquote><h3 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h3><ul><li>稳定性：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的<strong>相对次序保持不变</strong>，即在原序列中，<code>r[i] == r[j]</code>，且<code>r[i]</code>在<code>r[j]</code>之前，而在排序后的序列中，<code>r[i]</code>仍在<code>r[j]</code>之前，则称这种排序算法是稳定的；否则称为不稳定的</li><li>时间复杂度：排序过程中对单个数据的访问总次数</li><li>空间复杂度：排序过程中需要辅助的存储空间</li><li>内部排序/外部排序：排序过程中数据元素是否完全在内存</li></ul><h3 id="结论最前"><a href="#结论最前" class="headerlink" title="结论最前"></a>结论最前</h3><p><img src="/images/sort_summary.png" alt="排序算法总结"></p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><ul><li><p>算法：将第i个元素插入到前i-1个元素中适当的位置(选择插入位置时，因为前面元素已经有序，可以使用折半查找的方法)</p><blockquote><p>可以考虑扑克牌的排序，抽取后面的牌插入到前面有序的牌中</p></blockquote></li><li><p>性能分析：时间O(n^2^)，空间O(1)，稳定</p></li><li><p>图解</p><p><img src="/images/insert_sort.gif" alt="直接插入排序"></p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">    j = i - <span class="number">1</span></span><br><span class="line">    chosen_num = nums[i]</span><br><span class="line">    <span class="keyword">while</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">      <span class="keyword">if</span> nums[j] &gt; chosen_num:</span><br><span class="line">        nums[j + <span class="number">1</span>] = nums[j]</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      j -= <span class="number">1</span></span><br><span class="line">  nums[j + <span class="number">1</span>] = chosen_num</span><br></pre></td></tr></table></figure></li></ul><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><ul><li><p>算法</p><ul><li>首先设定以<code>gap</code>为距离对序列进行分组，对每个分组进行插入排序</li><li>缩小<code>gap</code>（一般缩小为上次的1/2～1/3附近）重新排序，循环，直到<code>gap</code>缩小为1</li><li><code>gap</code>为1的时候即为一次直接插入排序遍历</li></ul></li><li><p>性能分析：时间O(n^1.3~2^)，空间O(1)，不稳定</p></li><li><p>图解</p><p><img src="/images/shell_sort.gif" alt="希尔排序"></p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def shell_sort(nums) &#123;</span><br><span class="line">length = len(nums)</span><br><span class="line">    //区间</span><br><span class="line">  gap = <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> gap &lt; length:</span><br><span class="line">  gap = gap * <span class="number">3</span> + <span class="number">1</span> <span class="comment"># 确保gap最终能够是1</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(gap, length):</span><br><span class="line">    chosen_num = nums[i]</span><br><span class="line">    j = i - gap</span><br><span class="line">    //跨区间排序</span><br><span class="line">    <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> arr[j] &gt; tmp:</span><br><span class="line">  nums[j + gap] = nums[j]</span><br><span class="line">      j -= gap</span><br><span class="line">    nums[j + gap] = chosen_num</span><br><span class="line">  gap = gap / <span class="number">3</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h4><ul><li><p>算法：每次从待排序列中选择最小元素与待排序列首个元素交换后剔除首个元素，直到待排序列为空</p></li><li><p>性能分析：时间O(n^2^)，空间O(1)，不稳定</p></li><li><p>图解</p><p><img src="/images/select_sort.gif" alt="直接选择排序"></p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">    min_index = i</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(nums)):</span><br><span class="line">      <span class="keyword">if</span> nums[j] &lt; nums[min_index]:</span><br><span class="line">        min_index = j</span><br><span class="line">    nums[i], nums[min_index] = nums[min_index], nums[i]</span><br></pre></td></tr></table></figure></li></ul><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><blockquote><p>堆：这里的堆指的是由完全二叉树实现的二叉堆</p></blockquote><ul><li><p>算法：首先将所给元素排成大顶堆，然后每次取根节点，然后进行删除调整大顶堆，由此得到顺序序列</p></li><li><p>性能分析：时间O(nlogn)，空间O(1)，不稳定</p></li><li><p>图解</p><p><img src="/images/heap_sort.gif" alt="堆排序"></p></li><li><p>代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// golang</span></span><br><span class="line"><span class="comment">// 堆插入，生成大根堆结构</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HeapInsert</span><span class="params">(nums []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">childIndex := i</span><br><span class="line">parentIndex := (childIndex - <span class="number">1</span>) &gt;&gt; <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> childIndex &gt; <span class="number">0</span> &amp;&amp; nums[parentIndex] &lt; nums[childIndex] &#123; <span class="comment">// O(logN)</span></span><br><span class="line">nums[parentIndex], nums[childIndex] = nums[childIndex], nums[parentIndex]</span><br><span class="line">childIndex = parentIndex</span><br><span class="line">parentIndex = (childIndex - <span class="number">1</span>) &gt;&gt; <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 堆调整，将大根冒泡</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HeapAdjust</span><span class="params">(nums []<span class="keyword">int</span>, to <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> to == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">cur := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">leftChildI := cur&lt;&lt;<span class="number">1</span> + <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> leftChildI &gt; to &#123; <span class="comment">// nums[to] is the max num</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">rightChildI := leftChildI + <span class="number">1</span></span><br><span class="line">tobeChildI := leftChildI</span><br><span class="line"><span class="keyword">if</span> rightChildI &lt; to &amp;&amp; nums[rightChildI] &gt; nums[leftChildI] &#123;</span><br><span class="line">tobeChildI = rightChildI</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> nums[cur] &lt; nums[tobeChildI] &#123;</span><br><span class="line">nums[cur], nums[tobeChildI] = nums[tobeChildI], nums[cur]</span><br><span class="line">cur = tobeChildI</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HeapSort</span><span class="params">(nums []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">HeapInsert(nums)</span><br><span class="line"><span class="keyword">for</span> i := <span class="built_in">len</span>(nums) - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">nums[<span class="number">0</span>], nums[i] = nums[i], nums[<span class="number">0</span>]</span><br><span class="line">HeapAdjust(nums, i<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><ul><li><p>算法：通过从后往前的交换，将较小元素交换到待排序列最前端，每次“冒泡”可确定一个最小元素的位置</p></li><li><p>性能分析：时间O(n^2^)，空间O(1)，稳定</p></li><li><p>图解</p><p><img src="/images/bubble_sort.gif" alt="冒泡排序"></p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">  n = len(nums)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    j = n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j &gt; i:</span><br><span class="line">      <span class="keyword">if</span> nums[j] &lt; nums[j - <span class="number">1</span>]:</span><br><span class="line">        nums[j], nums[j - <span class="number">1</span>] = nums[j - <span class="number">1</span>], nums[j]</span><br><span class="line">      j -= <span class="number">1</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><ul><li><p>算法</p><ul><li>核心思想为分治法，从序列中选出一个基准值，其他依次和基准做比较，比基准大的放右边，小的放左边</li><li>然后分别对左右两边再次使用快速排序</li><li>单边扫描<ul><li>我们随意抽取一个数作为基准值，同时设定一个标记 mark 代表左边序列最右侧的下标位置，当然初始为 0 </li><li>接下来遍历数组，如果元素大于基准值，无操作，继续遍历，如果元素小于基准值，则把 mark + 1 ，再将 mark 所在位置的元素和遍历到的元素交换位置</li><li>mark 这个位置存储的是比基准值小的数据的最后一个，当遍历结束后，将基准值与 mark 所在元素交换位置即可</li></ul></li></ul></li><li><p>性能分析：时间O(nlogn)，空间O(logn)，不稳定</p></li><li><p>图解</p><p><img src="/images/quick_sort.gif" alt="快速排序"></p></li><li><p>代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 划分，将数组划分为大于基准值，等于基准值，小于基准值三个部分</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(nums []<span class="keyword">int</span>, from, to <span class="keyword">int</span>)</span> <span class="params">(midl, midr <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">left := from - <span class="number">1</span></span><br><span class="line">right := to</span><br><span class="line">cur := from</span><br><span class="line"><span class="keyword">for</span> cur &lt; right &#123;</span><br><span class="line"><span class="keyword">if</span> nums[cur] &lt; nums[to] &#123;</span><br><span class="line">nums[cur], nums[left+<span class="number">1</span>] = nums[left+<span class="number">1</span>], nums[cur]</span><br><span class="line">left += <span class="number">1</span></span><br><span class="line">cur += <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[cur] &gt; nums[to] &#123;</span><br><span class="line">nums[cur], nums[right<span class="number">-1</span>] = nums[right<span class="number">-1</span>], nums[cur]</span><br><span class="line">right -= <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cur += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">nums[to], nums[right] = nums[right], nums[to]</span><br><span class="line">right += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> left + <span class="number">1</span>, right - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 随机基准值快排</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">QuickSort</span><span class="params">(nums []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line">pivot := rand.Int63n(<span class="keyword">int64</span>(<span class="built_in">len</span>(nums)))</span><br><span class="line">nums[pivot], nums[<span class="built_in">len</span>(nums)<span class="number">-1</span>] = nums[<span class="built_in">len</span>(nums)<span class="number">-1</span>], nums[pivot]</span><br><span class="line">quickSort(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 快排递归结构</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSort</span><span class="params">(nums []<span class="keyword">int</span>, from, to <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> from &gt;= to &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">midLeft, midRight := partition(nums, from, to)</span><br><span class="line">quickSort(nums, from, midLeft<span class="number">-1</span>)</span><br><span class="line">quickSort(nums, midRight+<span class="number">1</span>, to)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><ul><li><p>算法：将待排序列分为两部分，对左右两部分分别进行归并排序，然后将两个有序序列合并为一个有序序列</p></li><li><p>性能分析：时间O(nlogn)，空间O(n)，稳定</p></li><li><p>图解</p><p><img src="/images/merge_sort.gif" alt="归并排序"></p></li><li><p>代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// golang</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(nums1, nums2 []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">i, j := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">res := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="built_in">len</span>(nums1)+<span class="built_in">len</span>(nums2))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i &lt; <span class="built_in">len</span>(nums1) &amp;&amp; j &lt; <span class="built_in">len</span>(nums2) &#123;</span><br><span class="line"><span class="keyword">if</span> nums1[i] &lt; nums2[j] &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, nums1[i])</span><br><span class="line">i++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, nums2[j])</span><br><span class="line">j++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> i &lt; <span class="built_in">len</span>(nums1) &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, nums1[i:]...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> j &lt; <span class="built_in">len</span>(nums2) &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, nums2[j:]...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MergeSort</span><span class="params">(nums []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br><span class="line">mid := <span class="built_in">len</span>(nums) / <span class="number">2</span></span><br><span class="line">leftPart := MergeSort(nums[:mid])</span><br><span class="line">rightPart := MergeSort(nums[mid:])</span><br><span class="line"><span class="keyword">return</span> merge(leftPart, rightPart)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="分类排序"><a href="#分类排序" class="headerlink" title="分类排序"></a>分类排序</h3><h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><ul><li><p>算法：对于待排序列首先选择其最大和最小值，创建一个计数区，计算在最大和最小值之间所有数字出现的次数，最后以计数桶顺序还原有序序列</p></li><li><p>性能分析：时间O(n)，空间O(max-min)，不稳定</p></li><li><p>图解</p><p><img src="/images/count_sort.gif" alt="计数排序"></p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># todo</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><ul><li><p>算法</p><ul><li>将要排的数据分到多个有序的桶里</li><li>每个桶里的数据再单独排序，再把每个桶的数据依次取出，即可完成排序</li></ul></li><li><p>性能分析：时间根据桶的粒度会有不同变化，空间：桶的数目</p></li><li><p>图解</p><p><img src="/images/bucket_sort.gif" alt="桶排序"></p></li></ul><h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><ul><li><p>算法</p><ul><li>按照位数，分别对每位进行比较，放入对应的桶内，然后将桶内元素以先进先出的方式按桶序取出</li><li>如此经过d次（d为最大位数）排序后即可得到顺序</li><li>本算法需要待排序列有基数，并且基数可排序</li></ul></li><li><p>性能分析：时间：O(d*n)，空间O(d*n)，稳定</p></li><li><p>图解</p><p><img src="/images/base_sort.gif" alt="基数排序"></p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># todo</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;blockquote&gt;
&lt;p&gt;参考&lt;a href=&quot;https://blog.csdn.net/justloveyou_/article/details/72730597&quot; ta
      
    
    </summary>
    
      <category term="技术" scheme="https://thomstrong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="算法" scheme="https://thomstrong.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>操作系统知识点</title>
    <link href="https://thomstrong.github.io/2019/07/07/Operation-System/"/>
    <id>https://thomstrong.github.io/2019/07/07/Operation-System/</id>
    <published>2019-07-07T08:02:41.000Z</published>
    <updated>2019-07-15T03:01:53.030Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><blockquote><p>参考<a href="https://blog.csdn.net/justloveyou_/article/details/78304294" target="_blank" rel="noopener">博客</a></p></blockquote><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><ul><li>进程是对运行时程序的封装，是系统进行资源调度和分配的基本单位，实现操作系统并发</li><li><p>线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性（对并发的用户操作做出实时响应），实现进程内部并发</p></li><li><p>一个程序至少有一个进程，一个进程至少有一个线程，线程依赖于进程</p></li><li><p>进程在执行过程中有独立的内存单元，而多个线程共享进程的内存</p></li><li><p>多线程优势</p><ul><li>解耦合，简化程序开发：将不同种类任务分配专门线程，形成串行假象</li><li>提高资源利用率：对于多CPU来说，多个线程可以调度到多个CPU上运行，提高系统吞吐率</li></ul></li><li><p>多线程风险</p><ul><li>安全问题：当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么这个类就是线程安全的</li><li>活跃性问题：死锁、饥饿</li><li>性能问题：吞吐率过低、资源消耗过高。当线程调度器临时挂起活跃线程并转而运行另一个线程时，就会频繁出现上下文切换操作(Context Switch)，这种操作会导致 CPU 时间更多的花在线程调度上而非线程的运行上。</li></ul></li></ul><h3 id="进程间通信-IPC"><a href="#进程间通信-IPC" class="headerlink" title="进程间通信 IPC"></a>进程间通信 IPC</h3><ul><li>管道及命名管道<ul><li>管道：半双工通信方式，数据只能单向流动（父进程关闭fd[0]，子进程关闭fd[1]，父进程写，子进程读），且只能在具有亲缘关系（父子进程）的进程间使用。</li><li>高级管道：将另一个程序当作一个新的进程在当前程序进程中启动，则它算是当前程序的子进程</li><li>命名管道 (named pipe) ：命名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</li><li>消息队列：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li><li>信号量通信：计数器，控制多个程序共享资源的访问</li><li>信号：通知接收进程某个事件已经发生</li><li>共享内存：最快的通信方式，映射一段能被其他进程访问的内存，由一个进程创建，多个进程访问。通常与信号量配合使用，来实现进程间的同步和通信</li><li>套接字 (socket)：可用于不同机器间的进程通信，可简单归纳为命名、绑定、监听、连接、数据交互、断开连接这几个步骤</li></ul></li></ul><h3 id="线程同步方式"><a href="#线程同步方式" class="headerlink" title="线程同步方式"></a>线程同步方式</h3><ul><li>互斥锁 mutex：通过对共享资源进行加锁和解锁的操作，标记资源是否可用，无锁资源阻塞，知道互斥量被解锁</li><li>条件变量：自动阻塞某个线程，直到特殊情况发生为止。条件变量通常和互斥锁一起使用。条件变量使线程可以睡眠等待某种条件出现。条件变量是利用线程间共享的全局变量进行同步的机制，包括“等待条件成立而挂起”和“另一个线程使条件成立”两个动作。</li><li>信号量 sem：同一时刻允许多个线程访问同一资源，但是通过信号量控制最大线程数量，通过一个整型S和一个队列表现<ul><li>PV操作：不可被打断的操作系统原语，P检查信号量是否可用，V释放信号量，主要用于完成互斥控制和同步</li></ul></li></ul><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul><li>在两个或者多个<strong>并发</strong>进程中，进程间产生了互相等待对方资源释放的情况。通俗的讲，就是两个或多个进程无限期的阻塞、相互等待的一种状态。</li></ul><h4 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h4><ul><li>互斥：至少有一个资源一次只能有一个进程使用</li><li><p>占有并等待：进程至少占有一个资源，且正在等待另一个被占有的资源释放</p></li><li><p>非抢占：资源不能被抢占，只能等到占有者完成当前任务后才能占有</p></li><li>循环等待：若干进程间形成头尾相接的环形资源等待关系</li></ul><h4 id="处理策略"><a href="#处理策略" class="headerlink" title="处理策略"></a>处理策略</h4><blockquote><p> 预防死锁、避免死锁、检测死锁、解除死锁 、鸵鸟策略</p></blockquote><ul><li>预防死锁：确保四个必要条件至少有一个不成立就能预防死锁发生<ul><li>打破互斥条件：资源的互斥与否经常是由其本身决定的，因此通常不适用这种办法</li><li>打破占有并等待：预先占有所有资源，若不能完全占有则暂时挂起不执行，但是资源往往是动态分配的，不可预知，而且这样的策略会大大降低资源利用率和并发性</li><li>打破非抢占条件：进程在申请新资源得不到满足时，必须释放当前占有资源，以供给其他进程使用。实现起来较为困难，且降低了系统性能</li><li>打破循环等待：实行资源有序分配，对所有资源排序编号，只有在申请到小号资源的情况下才能申请大号的资源，这样就避免了环路的产生，预防死锁</li></ul></li><li>死锁避免<ul><li>进程启动拒绝：如果进程的请求会导致死锁，则不启动进程</li><li>资源分配拒绝：如果进程增加的资源请求会导致死锁，则不允许分配</li><li>安全状态：系统能按照某种进程顺序，为每个进程分配资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利完成</li><li>银行家算法：根据当前资源分配状态，试探性分配所需资源后，检查系统是否仍处于安全状态，是则分配，否则撤销试探性分配，令进程等待</li></ul></li><li><p>死锁检测：资源分配图</p></li><li><p>死锁解除</p><ul><li>资源抢占：从一个或多个死锁进程那里抢占一个或多个资源，此处需要避免饥饿问题（某个进程总是被抢占资源导致无法继续）</li><li>终止进程：一次性终止所有死锁进程或逐个终止死锁进程直至死锁解除</li></ul></li></ul><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><ul><li>就绪状态：获得处理机以外所有所需资源，等待分配处理机资源</li><li>运行状态：占用处理机资源运行，处于此状态的进程数要小于CPU数</li><li>阻塞状态：进程等待某种条件，在满足前无法执行</li><li>状态转换<ul><li>就绪-&gt;运行：进程调度程序为就绪进程分配了处理机</li><li>执行-&gt;就绪：进程分配的时间片用完</li><li>执行-&gt;阻塞：进程等待某种事件发生（IO请求等）无法继续执行，编程阻塞状态</li><li>阻塞-&gt;就绪：所等待的事件已经发生，变成就绪状态</li></ul></li></ul><p><img src="/images/process_status.jpg" alt="进程状态"></p><h3 id="Python中的多线程"><a href="#Python中的多线程" class="headerlink" title="Python中的多线程"></a>Python中的多线程</h3><ul><li><p>Python多线程编程<strong>常用threading模块</strong>。启动一个多线程需要创建一个Thread对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t = Thread(target=countdown, args=(<span class="number">10</span>,), daemon=<span class="literal">True</span>)  <span class="comment"># 后台线程</span></span><br><span class="line">t.start()　     <span class="comment"># 启动线程</span></span><br><span class="line">t.is_alive()    <span class="comment"># 查询线程对象的状态，返回布尔值</span></span><br><span class="line">t.join()        <span class="comment"># 将线程加入到当前线程，并等待其终止</span></span><br></pre></td></tr></table></figure></li><li><p>GIL是CPython特性，同一时刻只能运行一个线程，不能利用多核资源。Cpython的多线程适用于I/O密集型问题，计算密集型问题可使用<strong>多进程</strong>编程。</p></li><li>线程同步原语有Event / Condition / Semaphore / Barrier。<strong>Event用于常用语通知全部线程，condition和Semapher常用于通知一定数量的线程， Barrier用于多个线程必须完成某些步骤再一起执行。</strong>Lock / Rlock / Event / Condition / Semaphore <strong>支持上下文管理协议</strong>（with语句，好用）。</li><li>线程间通信可以用queue模块中的Queue队列，<strong>get()和put()已加锁，是线程安全的</strong></li></ul><h3 id="进程调度策略"><a href="#进程调度策略" class="headerlink" title="进程调度策略"></a>进程调度策略</h3><ul><li>FCFS 先来先服务：先请求CPU的进程先分配CPU</li><li>SJF 最短作业优先调度：从备选作业队列中选出一个或若干个估计运行时间最短的作业优先调度，一直运行至结束或因发生事件阻塞放弃处理机</li><li>FPF 高优先权优先调度：照顾优先级较高的作业优先调度。<ul><li>抢占式：当有优先级更高的进程出现时，停止当前进程，将处理机分配给优先级更高进程。适合对性能要求较高的批处理和分时系统</li><li>非抢占式：当进程占有处理机时，只能运行至结束或因发生事件阻塞放弃处理机。用于某些对实时性要求不严的实时系统</li><li>优先级倒置问题：由于一个高优先级和一个低优先级进程之间的相互等待资源的情况，导致中优先级抢先于高优先级进程运行。<ul><li>解决办法<ul><li>设置优先级上限：为临界区设置一个优先级上限，企图进入临界区的进程优先级需要低于这个上限</li><li>优先级继承：当高优先级进程等待低优先级进程资源时，低优先级进程暂时继承高优先级进程优先级，直到资源被释放后恢复低优先级</li><li>临界区禁止中断：系统优先级分为可抢占优先级和中断禁止优先级，将运行于临界区的进程通过中断禁止保护起来，防止在访问互斥数据时被高优先级任务抢占处理机</li></ul></li></ul></li></ul></li><li>高响应比优先调度：响应比 = （等待时间 + 服务时间）/ 服务时间，对长作业的运行得不到保证，但是避免了最短作业优先调度中长作业饥饿的问题。在调度之前需要计算响应比，增加系统开销</li><li>时间片轮转法<ul><li>将所有就绪进程按照原先的服务原则排成一个队列，每次调度时，把CPU分配给队首进程，并执行一个时间片</li><li>时间片用完，计时器发出中断请求，调度程序把进程送到就绪队列队尾，然后将处理机分配给就绪队列队首进程</li><li>由此循环，系统能够在给定时间内响应所有用户的请求</li></ul></li><li>多级反馈队列：多级反馈队列对长短进程均有照顾，可满足各种类型进程的需要<ul><li>设置一个优先级从高到低的n个队列，优先级越高，时间片约短</li><li>当有新进程进入时，放入最高优先级队列，在一个时间片内，若执行完成，则跳出队列；若不能执行完成，放入下一级队列队尾</li><li>只有当前面i-1个队列为空时，才能执行第i个队列；若在第i个队列的一个时间片内不能执行完成，则落入i+1队列队尾；第n个队列使用时间片轮转法进行调度</li><li>当有新进程需要调度时，立即把正在运行的进程放回当前队列的队尾，然后把处理机分给高优先级进程。当再度运行到当前队列的该进程时，仅分配上次还未完成的时间片，不再分配该队列对应的完整时间片。</li></ul></li></ul><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><ul><li>FIFO先进先出：按照队列顺序，先进先出</li><li>LRU 最近最少使用：按照最近一次的使用时间</li><li>LFU 最少使用：按照截至目前使用的总次数</li><li>OPT 最优置换：理论的最优，理论；就是要保证置换出去的是不再被使用的页，或者是在实际内存中最晚使用的算法</li></ul><h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><ul><li>时间上的局部性：最近被访问的页在不久的将来还会被访问；</li><li>空间上的局部性：内存中被访问的页周围的页也很可能被访问。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;blockquote&gt;
&lt;p&gt;参考&lt;a href=&quot;https://blog.csdn.net/justloveyou_/article/details/78304294&quot; ta
      
    
    </summary>
    
      <category term="技术" scheme="https://thomstrong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="OS" scheme="https://thomstrong.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>Mysql数据库</title>
    <link href="https://thomstrong.github.io/2019/07/04/Mysql-Database/"/>
    <id>https://thomstrong.github.io/2019/07/04/Mysql-Database/</id>
    <published>2019-07-04T15:23:24.000Z</published>
    <updated>2019-07-15T03:01:36.662Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><blockquote><p>关系型数据库——MySQL部分概念</p></blockquote><h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><blockquote><p>个人感觉很像是用SQL语句封装出的函数</p></blockquote><ul><li>一些预编译的SQL语句，执行效率较高</li><li>在一定程度上保障数据安全</li></ul><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。</p><ul><li>只暴露部分字段给访问者，所以就建一个虚表，就是视图。</li><li>查询的数据来源于不同的表，而查询者希望以统一的方式查询，这样也可以建立一个视图，把多个表查询结果联合起来，查询者只需要直接从视图中获取数据，不必考虑数据来源于不同表所带来的差异</li></ul><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><ul><li>是对数据库表中一个或多个列的值进行排序的结构，帮助提高数据访问速度的数据库对象</li><li>索引加快了检索速度，但是降低了插入、删除、更新等维护任务的速度，大部分的更新操作同时需要更新索引</li><li>索引可以避免全表扫描，多数查询可仅扫描少量索引页及数据页</li><li>对于非聚集索引，有些查询甚至可以不访问数据页</li><li>聚集索引可以避免数据插入操作集中于表的最后一个数据页</li><li>某些情况下索引还可以避免排序操作</li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>大大加快检索速度;</li><li>创建唯一性索引，保证数据库表中每一行数据的唯一性;</li><li>加速表和表之间的连接;</li><li>在使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间。<ul><li>大大减少服务器需要扫描的数据量</li><li>帮助服务器避免排序和临时表</li><li>将所及I/O变为顺序I/O</li></ul></li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>索引需要占用数据表以外的物理存储空间</li><li>创建索引和维护索引要花费一定的时间</li><li>当对表进行更新操作时，索引需要被重建，这样降低了数据的维护速度。</li></ul><h4 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h4><ul><li>一条索引记录中包含的基本信息包括：键值（即你定义索引时指定的所有字段的值）+逻辑指针（指向数据页或者另一索引页）</li><li>当为空表创建索引时，数据库系统将分配一个索引页，在插入前保持空状态；当有数据插入时加入一行索引记录；当根结点满时，进行分裂：<ul><li>创建两个儿子节点</li><li>将当前根结点近似分为两半，分别写入儿子节点</li><li>将根结点加上指针指向新的两个儿子节点</li></ul></li><li>数据被删除导致索引中只包含一条索引记录时，该记录可能会被移至临近的索引页中，索引合并</li></ul><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>聚集索引：索引的逻辑顺序和数据的物理存储顺序相同<ul><li>应用场景：列经常被分组排序/搜索范围数据/主键列/外键列/仅有小数目的不同值</li><li>每个表中只能有一个聚集索引</li></ul></li><li>非聚集索引：索引的逻辑顺序和数据的物理存储顺序不同<ul><li>应用场景：列经常被分组排序/频繁更新列/主键列/外键列/大数目的不同值</li></ul></li><li>区别<ul><li>聚集索引是一种稀疏索引，数据页上一级的索引页存储的是页指针，而不是行指针。而对于非聚集索引，则是密集索引，在数据页的上一级索引页它为每一个数据行存储一条索引记录。</li><li>聚集索引的叶子结点是数据节点，非聚集索引的叶子结点并非数据结点</li></ul></li></ul><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li>不要索引数据量不大的表，对于小表来讲，表扫描的成本并不高。</li><li>主键并非都是聚合索引，使用了聚合索引的主键查询速度更快</li><li>建立适当的聚合索引，才能更好的提高查询的效率</li><li>一个复合索引包含A,B,C,D四列，则A为“引导列”；复合索引的引导列应该是查询最频繁的列</li><li>索引有助于提高检索性能，但过多或不当的索引也会导致系统低效。因为用户在表中每加进一个索引，数据库就要做更多的工作。过多的索引甚至会导致索引碎片。所以说，我们要建立一个“适当”的索引体系，特别是对聚合索引的创建，更应精益求精，才能使数据库性能更好的发挥</li><li>不要设置过多的索引，在没有聚集索引的表中，最大可以设置249个非聚集索引，过多的索引首先会带来更大的磁盘空间，而且在数据发生修改时，对索引的维护是特别消耗性能的</li><li>索引通常查询数据比全表扫描要快，但需要空间来存储，也需要定期维护。不必要的索引反而会使查询反应时间变慢.使用索引查询不一定能提高查询性能</li></ul><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><ul><li>并发控制的基本单位</li><li>一个操作序列，要么都执行，要么都不执行，结束时能保持数据一致性</li><li>定义事务的三条语句<ul><li>BEGIN TRANSACTION </li><li>COMMIT </li><li>ROLLBACK</li></ul></li><li>用户在事务（transaction）内可以声明（declare）被称为保存点（savepoint）的标记。保存点将一个大事务划分为较小的片断。</li></ul><h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><ul><li>触发器是一中特殊的存储过程，主要是通过事件来触发而被执行的。</li><li>它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。</li><li>可以联级运算。如，某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。</li><li>一个数据表可以有多个触发器，但一个触发器只能对应一个表</li></ul><h3 id="drop、delete与truncate"><a href="#drop、delete与truncate" class="headerlink" title="drop、delete与truncate"></a><strong>drop、delete</strong>与truncate</h3><ul><li>不再需要一张表及其数据的时候，用<strong>drop</strong></li><li>想删除部分数据行时候，用<strong>delete</strong>，并且带上where子句</li><li>保留表而删除所有数据的时候用<strong>truncate</strong>, 再插入时自增长id又从1开始 </li><li>当表被<strong>TRUNCATE</strong> 后，这个表和索引所占用的空间会恢复到初始大小，而<strong>DELETE</strong>操作不会减少表或索引所占用的空间。<strong>DROP</strong>语句将表所占用的空间全释放掉。</li><li>速度上，drop &gt; truncate &gt; delete</li><li>delete语句为DML（data maintain Language),这个操作会被放到 rollback segment中,事务提交后才生效。如果有相应的 tigger,执行的时候将被触发。</li><li>truncate、drop是DLL（data define language),操作立即生效，原数据不放到 rollback segment中，<strong>不能回滚</strong>。(如果一不小心把一个表truncate掉，也是可以恢复的，只是不能通过rollback来恢复)</li><li>对于外键（foreignkey ）约束引用的表，不能使用 truncate table，而应使用不带 where 子句的 delete 语句。</li><li>truncatetable不能用于参与了索引视图的表。</li><li>drop语句将删除表的结构所依赖的约束，触发器，索引，依赖于该表的存储过程/函数将保留,但是变为invalid状态。</li></ul><h3 id="超键、候选键、主键、外键"><a href="#超键、候选键、主键、外键" class="headerlink" title="超键、候选键、主键、外键"></a>超键、候选键、主键、外键</h3><ul><li>超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</li><li>候选键：是最小超键，即没有冗余元素（对数据唯一性不起作用的列元素）的超键。</li><li>主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。</li><li>外键：在一个表中存在的另一个表的主键称此表的外键。</li></ul><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Student( </span><br><span class="line"><span class="keyword">ID</span> <span class="built_in">NUMBER</span> PRIMARY <span class="keyword">KEY</span>, </span><br><span class="line"><span class="keyword">NAME</span> VARCHAR2(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>);//建表 </span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_name <span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">Select</span> * <span class="keyword">FROM</span> Table_name;//建视图 </span><br><span class="line"></span><br><span class="line"><span class="keyword">Create</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> index_name <span class="keyword">ON</span> TableName(col_name);//建索引 </span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tablename &#123;column1,column2,…&#125; <span class="keyword">values</span>(exp1,exp2,…);//插入 </span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Viewname &#123;column1,column2,…&#125; <span class="keyword">values</span>(exp1,exp2,…);//插入视图实际影响表 </span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> tablename <span class="keyword">SET</span> <span class="keyword">name</span>=<span class="string">'zang 3'</span> condition;//更新数据 </span><br><span class="line"></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Tablename <span class="keyword">WHERE</span> condition;//删除 </span><br><span class="line"></span><br><span class="line"><span class="keyword">GRANT</span> (<span class="keyword">Select</span>,<span class="keyword">delete</span>,…) <span class="keyword">ON</span> (对象) <span class="keyword">TO</span> USER_NAME [<span class="keyword">WITH</span> <span class="keyword">GRANT</span> <span class="keyword">OPTION</span>];//授权 </span><br><span class="line"></span><br><span class="line"><span class="keyword">REVOKE</span> (权限表) <span class="keyword">ON</span>(对象) <span class="keyword">FROM</span> USER_NAME [<span class="keyword">WITH</span> <span class="keyword">REVOKE</span> <span class="keyword">OPTION</span>] //撤权</span><br></pre></td></tr></table></figure><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><ul><li><a href="https://thomstrong.github.io/2019/07/02/SQL-vs-NoSQL/">SQL vs NoSQL</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;blockquote&gt;
&lt;p&gt;关系型数据库——MySQL部分概念&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;存储过程&quot;&gt;&lt;a href=&quot;#存储过程&quot; class=&quot;h
      
    
    </summary>
    
      <category term="技术" scheme="https://thomstrong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="数据库" scheme="https://thomstrong.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Docker知识点</title>
    <link href="https://thomstrong.github.io/2019/07/04/Docker/"/>
    <id>https://thomstrong.github.io/2019/07/04/Docker/</id>
    <published>2019-07-04T01:13:25.000Z</published>
    <updated>2019-07-15T03:01:12.342Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><blockquote><p>参考<a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" target="_blank" rel="noopener">博文</a></p></blockquote><h1 id="知识铺垫"><a href="#知识铺垫" class="headerlink" title="知识铺垫"></a>知识铺垫</h1><h4 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h4><blockquote><p> 在操作系统中运行其他操作系统，对于底层来说，虚拟机是一个<strong>文件</strong></p></blockquote><ul><li>优势在于可通过还原虚拟机镜像/快照的方式还原原始环境</li><li>资源占用多、冗余步骤多、启动慢三个劣势</li></ul><h4 id="Linux容器"><a href="#Linux容器" class="headerlink" title="Linux容器"></a>Linux容器</h4><blockquote><p>不是模拟完整操作系统，而是对进程进行隔离</p></blockquote><ul><li>优势：启动快（一个容器相当于一个底层的进程）、占用资源少（只占用需要的资源，且可以共享资源）、体积小（只包含有用的组件）</li></ul><h4 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h4><blockquote><p>Linux 容器的封装，提供简单易用的容器使用接口</p></blockquote><ul><li>将应用程序与其依赖打包为一个文件，省去了环境配置带来的问题</li></ul><h1 id="Docker-1"><a href="#Docker-1" class="headerlink" title="Docker"></a>Docker</h1><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><ul><li>提供一次性的环境</li><li>提供弹性的云服务：随开随关，动态扩缩容</li><li>组件微服务架构：通过在一台机器上启动多个容器模拟微服务架构</li></ul><hr><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="image-镜像"><a href="#image-镜像" class="headerlink" title="image/镜像"></a>image/镜像</h4><ul><li>应用及其依赖打包在image文件里</li><li>可以看作是容器的模板，只有通过image才能生成容器</li><li><p>image是二进制文件，通常一个image是继承另一个image，再加上一些个性化设置而生成</p></li><li><p>命令</p><ul><li><code>docker image ls</code> </li><li><code>docker image rm [imageName or imageId]</code> or<code>docker rmi [imageName or imageId]</code></li><li><code>docker image pull [imageName]</code></li></ul></li><li><p>image一般不建议重复造轮</p></li></ul><h4 id="Container-容器"><a href="#Container-容器" class="headerlink" title="Container/容器"></a>Container/容器</h4><ul><li>image 文件生成的容器实例，本身也是一个文件，称为容器文件</li><li>命令<ul><li><code>docker container run [imageName]</code> # 该命令有自动抓取image文件的功能，如果本地没有指定的image文件，就会从仓库自动抓取</li><li><code>docker container run -it [imageName] bash</code> # 将运行的容器映射到终端中<ul><li><code>-p 8000:3000</code>参数：容器的 3000 端口映射到本机的 8000 端口。</li><li><code>-it</code>参数：容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。</li><li><code>koa-demo:0.0.1</code>：image 文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）。</li><li><code>/bin/bash</code>：容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。</li></ul></li><li><code>docker container kill [containerId]</code> # 终止容器运行</li><li><code>docker container rm</code>or <code>docker rm</code> </li></ul></li></ul><h4 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h4><ul><li><p>文本文件，用来配置image</p></li><li><p>.dockerignore # 加入不需要打包入image的文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.git</span><br><span class="line">node_modules</span><br><span class="line">npm-debug.log</span><br></pre></td></tr></table></figure></li><li><p>Dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">8.4</span> <span class="comment"># 继承自官方node image</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /app <span class="comment"># 将当前目录下所有文件（除了.dockerignore排除的路径）复制到image文件的/app下</span></span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app <span class="comment"># 之后的工作路径为/app</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm install --registry=https://registry.npm.taobao.org <span class="comment"># 安装node依赖</span></span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3000</span> <span class="comment"># 将容器的3000端口暴露出来，允许外部连接</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> node demos/01.js <span class="comment"># 容器启动后执行 node demos/01.js这条命令</span></span></span><br><span class="line"><span class="comment"># RUN命令在 image 文件的构建阶段执行，执行结果都会打包进入 image 文件；CMD命令则是在容器启动后执行。另外，一个 Dockerfile 可以包含多个RUN命令，但是只能有一个CMD命令。</span></span><br><span class="line"><span class="comment"># 指定了CMD命令以后，docker container run命令就不能附加命令了（比如前面的/bin/bash），否则它会覆盖CMD命令。</span></span><br></pre></td></tr></table></figure></li><li><p>build/打包 image</p><ul><li><code>docker image build -t koa-demo .</code> # 使用当前目录下的dockerfile打包image，名称为koa-demo</li></ul></li><li><p>生成容器</p><ul><li><code>docker container run --rm -p 8000:3000 -it [imageName] [someCmd]</code></li></ul></li></ul><h3 id="一些命令"><a href="#一些命令" class="headerlink" title="一些命令"></a>一些命令</h3><ul><li><code>docker container start [containerId or containerName]</code> or <code>docker start [containerId or containerName]</code>  # 启动一个已生成的容器</li><li><code>docker container stop</code></li><li><code>docker container logs</code> # 查看容器的标准输出</li><li><code>docker container exec -it [containerID or containerName] /bin/bash</code> # 将容器的shell映射到本地终端</li><li><code>docker container cp [containID]:[/path/to/file] .</code> # 将容器<code>/path/to/file</code>路径对应的文件复制到当前目录</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;blockquote&gt;
&lt;p&gt;参考&lt;a href=&quot;http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html&quot; ta
      
    
    </summary>
    
      <category term="技术" scheme="https://thomstrong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="虚拟化" scheme="https://thomstrong.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>SQL vs NoSQL总结</title>
    <link href="https://thomstrong.github.io/2019/07/02/SQL-vs-NoSQL/"/>
    <id>https://thomstrong.github.io/2019/07/02/SQL-vs-NoSQL/</id>
    <published>2019-07-02T08:02:57.000Z</published>
    <updated>2019-07-15T03:01:04.248Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="SQL-vs-NoSQL"><a href="#SQL-vs-NoSQL" class="headerlink" title="SQL vs NoSQL"></a>SQL vs NoSQL</h1><blockquote><p><a href="https://www.xplenty.com/blog/the-sql-vs-nosql-difference/" target="_blank" rel="noopener">参考blog</a></p></blockquote><h3 id="SQL（关系型数据库）"><a href="#SQL（关系型数据库）" class="headerlink" title="SQL（关系型数据库）"></a>SQL（关系型数据库）</h3><ul><li>使用结构化查询语句（Structured Query Language)来定义和管理数据</li><li>通用且使用广泛，能够安全适用于复杂查询密集的环境</li><li>使用之前需要进行数据结构定义，所有数据遵循相同结构，结构的变化较难应付</li><li>MySql，Oracle，Sqlite，Postgres和MS-SQL</li></ul><h3 id="NoSQL（非关系数据库-分布式数据库）"><a href="#NoSQL（非关系数据库-分布式数据库）" class="headerlink" title="NoSQL（非关系数据库/分布式数据库）"></a>NoSQL（非关系数据库/分布式数据库）</h3><ul><li>非结构化数据动态模式，数据以多种方式存储，可以面向列、面向文档、基于图或者K-V模式存储</li><li>没有标准接口来执行复杂查询</li><li>数据文档无需进行预先定义和结构声明，每个文档可以拥有不同的结构，数据域能随意拓展</li><li>MongoDB，BigTable，Redis，RavenDb，Cassandra，Hbase，Neo4j和CouchDb</li></ul><hr><h3 id="拓展性"><a href="#拓展性" class="headerlink" title="拓展性"></a>拓展性</h3><ul><li>SQL具备垂直拓展性，可通过增加CPU/RAM/SSD来提升负载能力</li><li>NoSQL具备水平拓展性，可通过增加更多服务器提升负载能力</li></ul><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><ul><li>SQL数据库基于表存储</li><li>NoSQL数据库基于文档/k-v对/图/宽列存储</li></ul><h3 id="数据存储类型"><a href="#数据存储类型" class="headerlink" title="数据存储类型"></a>数据存储类型</h3><ul><li>SQL不支持分布式数据存储</li><li>NoSQL能更好的适应分布式数据存储，因其使用了k-v对这样类似Json数据的数据存储方式，对于大型数据集的存储有更好的表现。Hbase就是一个很好的例子</li></ul><h3 id="事务应用"><a href="#事务应用" class="headerlink" title="事务应用"></a>事务应用</h3><blockquote><ul><li><p>一个事务是一连串的操作组成，增删改查的集合</p></li><li><p>特性ACID：</p><ul><li>原子性（Atomicity）：要么完整执行，要么不执行</li><li>一致性（Consistency）：执行前后，数据保持完整和逻辑一致（银行存款例子），原子性和持久性是事务一致性的充分条件</li><li>隔离性（Isolation）：多个并发事务是独立的，上下文彼此隔离，互不干扰，使用锁机制进行数据线程安全控制。四种隔离级别<ul><li>读未提交，其隔离级别最低，允许脏读。换句话说就是，如果一个事务正在处理某一数据，并对其进行了更新，但是同时没有提交事务，允许另一个事务也可以访问</li><li>读已提交，和读未提交的区别就是。读未提交可以读取到别人没有提交的数据，但是读已提交只能读取到别人提交后的值，事务进行的中间值不会读取到</li><li>可重复读，简单来说就是事务处理过程中多次读取同一个数据的时候，这个值不会发生改变，其值都和第一次查询到的数据是一致的</li><li>串行化，是最严格的隔离级别，他要求所有的事务都被串行执行，既事务只能一个接一个的进行处理，不能并发执行</li></ul></li><li>持久性（Durability）：在提交后已提交的数据应该能过永久保存，在系统发生异常后仍能回到异常发生前的状态</li></ul></li></ul></blockquote><ul><li>SQL数据库最适合重量级事务类型应用程序，因为它更稳定，且承诺了数据的原子性和完整性</li><li>NoSQL也可以在事务中应用，但是在高负载和复杂事务的应用环境下不能有更好的表现</li></ul><h3 id="外部支持"><a href="#外部支持" class="headerlink" title="外部支持"></a>外部支持</h3><ul><li>SQL数据库有更丰富的提供商和解决方案作为支持</li><li>NoSQL目前仍然依赖于社区</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;SQL-vs-NoSQL&quot;&gt;&lt;a href=&quot;#SQL-vs-NoSQL&quot; class=&quot;headerlink&quot; title=&quot;SQL vs NoSQL&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="技术" scheme="https://thomstrong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="数据库" scheme="https://thomstrong.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>网络协议部分复习</title>
    <link href="https://thomstrong.github.io/2019/07/01/Network-Protocal/"/>
    <id>https://thomstrong.github.io/2019/07/01/Network-Protocal/</id>
    <published>2019-07-01T08:01:06.000Z</published>
    <updated>2019-07-15T03:00:56.481Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h1><h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h3><p>OSI 中的层                          功能                                                                     TCP/IP协议族<br>应用层            文件传输，电子邮件，文件服务，虚拟终端       TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet<br>表示层            数据格式化，代码转换，数据加密                                  没有协议<br>会话层            解除或建立与别的接点的联系                                       没有协议<br>传输层            提供端对端的接口                                                    TCP，UDP （RTP）<br>网络层            为数据包选择路由                                                    IP，ICMP，RIP，OSPF，BGP，IGMP<br>数据链路层    传输有地址的帧以及错误检测功能                         SLIP，CSLIP，PPP，ARP，RARP，MTU<br>物理层            以二进制数据形式在物理媒体上传输数据                    ISO2110，IEEE802，IEEE802.2</p><h3 id="TCP-IP五层模型的协议"><a href="#TCP-IP五层模型的协议" class="headerlink" title="TCP/IP五层模型的协议"></a>TCP/IP五层模型的协议</h3><p>应用层<br>传输层：四层交换机、也有工作在四层的路由器</p><p>网络层：路由器、三层交换机</p><p>数据链路层：网桥（现已很少使用）、以太网交换机（二层交换机）、网卡（其实网卡是一半工作在物理层、一半工作在数据链路层）</p><p>物理层：中继器、集线器、还有我们通常说的双绞线也工作在物理层</p><h3 id="RTP协议"><a href="#RTP协议" class="headerlink" title="RTP协议"></a>RTP协议</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>RTP全名是Real-time Transport Protocol（实时传输协议）。它是IETF提出的一个标准，对应的RFC文档为RFC3550（RFC1889为其过期版本）。RFC3550不仅定义了RTP，而且定义了配套的相关协议RTCP（Real-time Transport Control Protocol，即实时传输控制协议）。RTP用来为IP网上的语音、图像、传真等多种需要实时传输的多媒体数据提供<strong>端到端</strong>的实时传输服务。RTP为Internet上端到端的实时传输提供时间信息和流同步，但并不保证服务质量，<strong>服务质量由RTCP来提供</strong>。</p><ul><li>RTP功能：用来为IP网上的语音、图像、传真等多种需要实时传输的多媒体数据提供<strong>端到端</strong>的实时传输服务</li><li>RTCP功能：服务质量的监视与反馈、媒体间的同步，以及多播组中成员的标识。在RTP会话期间，各参与者<strong>周期性地传送RTCP包</strong>。RTCP包中含有已发送的数据包的数量、丢失的数据包的数量等<strong>统计资料</strong>，因此，各参与者可以利用这些信息动态地改变传输速率，甚至改变有效载荷类型。</li><li>RTP和RTCP配合使用，它们能以有效的反馈和最小的开销使传输效率最佳化，因而特别适合传送网上的实时数据。</li></ul><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ul><li>简单的多播音频会议</li><li>音频和视频会议</li><li>翻译器和混合器</li></ul><h4 id="流媒体"><a href="#流媒体" class="headerlink" title="流媒体"></a>流媒体</h4><p>流媒体是指Internet上使用流式传输技术的连续时基媒体。当前在Internet上传输音频和视频等信息主要有两种方式：下载和流式传输两种方式。流式传输是实现流媒体的关键技术。</p><ul><li>要实现流式传输，就是要从降低延迟和恢复数据包时序入手。在发送端，为降低延迟，往往对传输数据进行预处理（降低质量和高效压缩）。在接收端为了恢复时序，采用了接收缓冲；而为了实现媒体的流畅播放，则采用了播放缓冲。</li><li>使用接收缓冲，可以将接收到的数据包缓存起来，然后根据数据包的封装信息（如包序号和时戳等），将乱序的包重新排序，最后将重新排序了的数据包放入播放缓冲播放。</li></ul><h4 id="会话过程"><a href="#会话过程" class="headerlink" title="会话过程"></a>会话过程</h4><p>当应用程序建立一个RTP会话时，应用程序将确定一对目的传输地址。目的传输地址由一个网络地址和一对端口组成，有两个端口：一个给RTP包，一个给RTCP包，使得RTP/RTCP数据能够正确发送。RTP数据发向偶数的UDP端口，而对应的控制信号RTCP数据发向相邻的奇数UDP端口（偶数的UDP端口＋1），这样就构成一个UDP端口对。 RTP的发送过程如下，接收过程则相反。</p><ul><li><p>RTP协议从上层接收流媒体信息码流（如H.263），封装成RTP数据包；RTCP从上层接收控制信息，封装成RTCP控制包。</p></li><li><p>RTP将RTP 数据包发往UDP端口对中偶数端口；RTCP将RTCP控制包发往UDP端口对中的接收端口。</p></li></ul><h3 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul><li>TCP，全称Transfer Control Protocol，中文名为传输控制协议，它工作在OSI的传输层，提供面向连接的可靠传输服务。</li><li>TCP的工作主要是建立连接，然后从应用层程序中接收数据并进行传输。TCP采用虚电路连接方式进行工作，在发送数据前它需要在发送方和接收方建立一个连接，数据在发送出去后，发送方会等待接收方给出一个确认性的应答，否则发送方将认为此数据丢失，并重新发送此数据。</li></ul><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ul><li>TCP连接建立：TCP的连接建立过程又称为TCP<strong>三次握手</strong>。首先发送方主机向接收方主机发起一个建立连接的同步（SYN）请求；接收方主机在收到这个请求后向送方主机回复一个同步/确认（SYN/ACK）应答；发送方主机收到此包后再向接收方主机发送一个确认（ACK），此时TCP连接成功建立</li><li>TCP连接关闭：发送方主机和目的主机建立TCP连接并完成数据传输后，会发送一个将结束标记置1的数据包，以关闭这个TCP连接，并同时释放该连接占用的缓冲区空间；</li><li>TCP重置：TCP允许在传输的过程中突然中断连接，这称为TCP重置；</li><li>TCP数据排序和确认：TCP是一种可靠传输的协议，它在传输的过程中使用序列号和确认号来跟踪数据的接收情况；</li><li>TCP重传：在TCP的传输过程中，如果在重传超时时间内没有收到接收方主机对某数据包的确认回复，发送方主机就认为此数据包丢失，并再次发送这个数据包给接收方，这称为TCP重传；</li><li>TCP延迟确认：TCP并不总是在接收到数据后立即对其进行确认，它允许主机在接收数据的同时发送自己的确认信息给对方。</li><li>TCP数据保护（校验和）：TCP是可靠传输的协议，它提供校验和计算来实现数据在传输过程中的完整性。</li></ul><h3 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><ul><li>UDP协议是英文UserDatagramProtocol的缩写，即用户数据报协议，主要用来支持那些需要在计算机之间传输数据的网络应用。包括网络视频会议系统在内的众多的客户/服务器模式的网络应用都需要使用UDP协议。</li><li>UDP协议的主要作用是将网络数据流量压缩成数据报的形式。一个典型的数据报就是一个二进制数据的传输单位。每一个数据报的前8个字节用来包含报头信息，剩余字节则用来包含具体的传输数据。</li></ul><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ul><li>RTP位于UDP之上，UDP虽然没有TCP那么可靠，并且无法保证实时业务的服务质量，需要RTCP实时监控数据传输和服务质量，但是，由于UDP的传输时延低于TCP，能与视频和音频很好匹配。因此，在实际应用中，RTP/RTCP/UDP用于音频/视频媒体，而TCP用于数据和控制信令的传输。</li><li>UDP和TCP协议的主要区别是两者在如何实现信息的可靠传递方面不同。TCP协议中包含了专门的传递保证机制，当数据接收方收到发送方传来的信息时，会自动向发送方发出确认消息；发送方只有在接收到该确认消息之后才继续传送其它信息，否则将一直等待直到收到确认信息为止。</li><li>TCP比UDP多了建立连接的时间。相对UDP而言，TCP具有更高的安全性和可靠性。TCP协议传输的大小不限制，一旦连接被建立，双方可以按照一定的格式传输大量的数据，而UDP是一个不可靠的协议，大小有限制，每次不能超过64K。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;网络协议&quot;&gt;&lt;a href=&quot;#网络协议&quot; class=&quot;headerlink&quot; title=&quot;网络协议&quot;&gt;&lt;/a&gt;网络协议&lt;/h1&gt;&lt;h3 id=&quot;OSI七层模型
      
    
    </summary>
    
      <category term="技术" scheme="https://thomstrong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="网络" scheme="https://thomstrong.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Redis知识点</title>
    <link href="https://thomstrong.github.io/2019/06/21/Redis/"/>
    <id>https://thomstrong.github.io/2019/06/21/Redis/</id>
    <published>2019-06-21T07:32:20.000Z</published>
    <updated>2019-07-15T03:01:18.697Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Redis知识点汇总"><a href="#Redis知识点汇总" class="headerlink" title="Redis知识点汇总"></a>Redis知识点汇总</h1><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>C 语言写成的，开源的 key-value 数据库</li><li>和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set 使用score排序)和hash（哈希类型）</li><li>这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。</li><li>与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步</li></ul><h3 id="对比memcached"><a href="#对比memcached" class="headerlink" title="对比memcached"></a>对比memcached</h3><p><img src="/images/redis_vs_memcached.jpg" alt="redis_vs_memcached"></p><ul><li>Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。memcache支持简单的数据类型，String。</li><li>Redis支持数据的备份，即master-slave模式的数据备份。</li><li>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而Memecache把数据全部存在内存之中</li><li>redis的速度比memcached快很多</li><li><p>Memcached是多线程，非阻塞IO复用的网络模型；Redis使用单线程的IO复用模型。</p></li><li><p><strong>终极策略：</strong> 使用Redis的String类型做的事，都可以用Memcached替换，以此换取更好的性能提升； 除此以外，优先考虑Redis</p></li></ul><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>(1) <strong>速度快</strong>，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)</p><p>(2)<strong>支持丰富数据类型</strong>，支持string，list，set，sorted set，hash</p><p>(3) <strong>支持事务</strong> ：redis对事务是部分支持的，如果是在入队时报错，那么都不会执行；在非入队时报错，那么成功的就会成功执行。</p><p>(4) <strong>丰富的特性</strong>：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ul><li>字符串操作： SET/GET</li><li>哈希类型操作：HMSET/ HGETALL/ HSET</li><li>列表（链表）：LPUSH/ RPUSH/ LPOP/ RPOP/ LRANGE</li><li>集合：SADD/ SMEMBERS</li><li>有序集合（ZSET）：ZADD/ ZRANGE</li><li>HyperLogLog（集合基数统计）:PFADD/ PFCOUNT/ PFMERGE</li><li>2.8+ 扫描操作：SCAN/ SSCAN/ HSCAN/ ZSCAN</li><li>发布订阅<ul><li>发布订阅模式，两个客户端之间通过SUBSCRIBE/ PULISH交换消息</li><li>命令：PUBLISH/ SUBSCRIBE/ PUBSUB</li></ul></li><li>事务<ul><li>从开始到执行会进入以下步骤：开始事务—进入队列—执行事务</li><li>事务可以认为是一个批量执行的脚本，内部命令是原子的，但事务本身并非原子。中间的命令失败不会导致其之前命令回滚，也不会导致其之后命令放弃执行</li><li>命令：<ul><li>MULTI（标记事务开始）</li><li>EXEC（开始执行事务）</li><li>DISCARD（放弃执行事务块）</li></ul></li></ul></li><li>脚本：EVAL script numkeys key [key …] arg [arg …]</li><li>备份与恢复<ul><li>备份：<code>SAVE</code>命令存储数据到dump.rdb，<code>CONFIG GET dir</code>查看rdb文件存储位置，将文件备份</li><li>恢复：只需将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可</li></ul></li><li>性能测试：<code>redis-benchmark -n 10000  -q</code></li></ul><h3 id="keys-和-SCAN"><a href="#keys-和-SCAN" class="headerlink" title="keys 和 SCAN"></a>keys 和 SCAN</h3><ul><li>keys {pattern} 获取所有符合pattern 的key<ul><li>没有offset和limit参数，会返回所有的key</li><li>复杂度O(n)， 当n较大时导致redis服务卡顿</li><li>由于redis是单线程的，会阻塞redis后续的命令</li></ul></li><li>scan {cursor} [MATCH pattern] [COUNT count]<ul><li>复杂度虽然也是 O(n)，但是它是通过游标分步进行的，不会阻塞线程;</li><li>提供 count 参数，可以控制每次返回结果的最大条数，count 只是对增量式迭代命令的一种提示(hint)，返回的结果可多可少;</li><li>同 keys 一样，它也提供模式匹配功能;</li><li>服务器不需要为游标保存状态，游标的唯一状态就是 scan 返回给客户端的游标整数;</li><li>返回的结果可能会有重复，需要<strong>客户端去重复</strong>，这点非常重要;</li><li>遍历的过程中如果有数据修改，改动后的数据能不能遍历到是不确定的;</li><li>单次返回的结果是空的并不意味着遍历结束，而要看返回的游标值是否为零</li></ul></li></ul><h3 id="一些规范"><a href="#一些规范" class="headerlink" title="一些规范"></a>一些规范</h3><blockquote><p>参考<a href="https://mp.weixin.qq.com/s/E2ZPXTE7lXfHFH2bMRnj0g" target="_blank" rel="noopener">推送</a></p></blockquote><ul><li><p>Key 名称设计：</p><ul><li><p>在尽量保持可读性的前提下，缩短key的长度</p><p><code>user:{uid}:friends:messages:{mid} 简化为 u:{uid}:fr:m:{mid}。</code></p></li></ul></li><li><p>value 设计：</p><ul><li>拒绝bigkey，string类型控制在10KB以内，hash、list、set、zset元素个数不要超过5000。</li><li>如果你观察到 Redis 的内存大起大落，这极有可能是因为大 key 导致的，这时候你就需要定位出具体是哪个 key，<code>redis-cli --bigkeys -i 0.1 # 每隔100条scan就会休眠0.1s</code>命令可以用来找到。</li><li>非字符串的bigkey，不要使用del删除，使用hscan、sscan、zscan方式渐进式删除，同时要注意防止bigkey过期时间自动删除问题(例如一个200万的zset设置1小时过期，会触发del操作，造成阻塞，而且该操作不会不出现在慢查询中(latency可查))，查找方法和删除方法</li><li>选择适合的数据类型</li></ul></li><li><p>建议使用expire设置过期时间(条件允许可以打散过期时间，防止集中过期)，不过期的数据重点关注idletime。</p></li><li><p>避免一些在n比较大时的O(n)操作，禁用一些危险命令，可在conf文件中使用<code>rename-command flushdb flushddbb</code>命令对危险命令进行重命名</p></li><li><p>使用如原生的<code>mget</code> <code>mset</code>或非原生的<code>pipline</code>这种批量命令来提高效率，</p></li><li><p>不建议过多使用事务功能</p></li><li><p>避免多个应用使用一个redis实例，不想干业务拆分，公共数据做服务化</p></li><li><p>根据自身业务类型，选好maxmemory-policy(最大内存淘汰策略)，设置好过期时间。</p><p>默认策略是volatile-lru，即超过最大内存后，在过期键中使用lru算法进行key的剔除，保证不过期数据不被删除，但是可能会出现OOM问题。</p><p><strong>其他策略如下</strong>：</p><ul><li>allkeys-lru：根据LRU算法删除键，不管数据有没有设置超时属性，直到腾出足够空间为止。</li><li>allkeys-random：随机删除所有键，直到腾出足够空间为止。</li><li>volatile-random:随机删除过期键，直到腾出足够空间为止。</li><li>volatile-ttl：根据键值对象的ttl属性，删除最近将要过期数据。如果没有，回退到noeviction策略。</li><li>noeviction：不会剔除任何数据，拒绝所有写入操作并返回客户端错误信息”(error) OOM command not allowed when used memory”，此时Redis只响应读操作。</li></ul></li></ul><h3 id="Jedis下删除bigkeys的一些代码示例"><a href="#Jedis下删除bigkeys的一些代码示例" class="headerlink" title="Jedis下删除bigkeys的一些代码示例"></a>Jedis下删除bigkeys的一些代码示例</h3><ul><li>Hash删除: hscan + hdel</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delBigHash</span><span class="params">(String host, <span class="keyword">int</span> port, String password, String bigHashKey)</span> </span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(host, port);</span><br><span class="line">    <span class="keyword">if</span> (password != <span class="keyword">null</span> &amp;&amp; !<span class="string">""</span>.equals(password)) &#123;</span><br><span class="line">        jedis.auth(password);</span><br><span class="line">    &#125;</span><br><span class="line">    ScanParams scanParams = <span class="keyword">new</span> ScanParams().count(<span class="number">100</span>);</span><br><span class="line">    String cursor = <span class="string">"0"</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ScanResult&lt;Entry&lt;String, String&gt;&gt; scanResult = jedis.hscan(bigHashKey, cursor, scanParams);</span><br><span class="line">        List&lt;Entry&lt;String, String&gt;&gt; entryList = scanResult.getResult();</span><br><span class="line">        <span class="keyword">if</span> (entryList != <span class="keyword">null</span> &amp;&amp; !entryList.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Entry&lt;String, String&gt; entry : entryList) &#123;</span><br><span class="line">                jedis.hdel(bigHashKey, entry.getKey());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cursor = scanResult.getStringCursor();</span><br><span class="line">    &#125; <span class="keyword">while</span> (!<span class="string">"0"</span>.equals(cursor));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除bigkey</span></span><br><span class="line">    jedis.del(bigHashKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>List删除: ltrim</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delBigList</span><span class="params">(String host, <span class="keyword">int</span> port, String password, String bigListKey)</span> </span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(host, port);</span><br><span class="line">    <span class="keyword">if</span> (password != <span class="keyword">null</span> &amp;&amp; !<span class="string">""</span>.equals(password)) &#123;</span><br><span class="line">        jedis.auth(password);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> llen = jedis.llen(bigListKey);</span><br><span class="line">    <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">while</span> (counter &lt; llen) &#123;</span><br><span class="line">        <span class="comment">//每次从左侧截掉100个</span></span><br><span class="line">        jedis.ltrim(bigListKey, left, llen);</span><br><span class="line">        counter += left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最终删除key</span></span><br><span class="line">    jedis.del(bigListKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Set删除: sscan + srem</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delBigSet</span><span class="params">(String host, <span class="keyword">int</span> port, String password, String bigSetKey)</span> </span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(host, port);</span><br><span class="line">    <span class="keyword">if</span> (password != <span class="keyword">null</span> &amp;&amp; !<span class="string">""</span>.equals(password)) &#123;</span><br><span class="line">        jedis.auth(password);</span><br><span class="line">    &#125;</span><br><span class="line">    ScanParams scanParams = <span class="keyword">new</span> ScanParams().count(<span class="number">100</span>);</span><br><span class="line">    String cursor = <span class="string">"0"</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ScanResult&lt;String&gt; scanResult = jedis.sscan(bigSetKey, cursor, scanParams);</span><br><span class="line">        List&lt;String&gt; memberList = scanResult.getResult();</span><br><span class="line">        <span class="keyword">if</span> (memberList != <span class="keyword">null</span> &amp;&amp; !memberList.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String member : memberList) &#123;</span><br><span class="line">                jedis.srem(bigSetKey, member);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cursor = scanResult.getStringCursor();</span><br><span class="line">    &#125; <span class="keyword">while</span> (!<span class="string">"0"</span>.equals(cursor));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除bigkey</span></span><br><span class="line">    jedis.del(bigSetKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>SortedSet删除: zscan + zrem</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delBigZset</span><span class="params">(String host, <span class="keyword">int</span> port, String password, String bigZsetKey)</span> </span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(host, port);</span><br><span class="line">    <span class="keyword">if</span> (password != <span class="keyword">null</span> &amp;&amp; !<span class="string">""</span>.equals(password)) &#123;</span><br><span class="line">        jedis.auth(password);</span><br><span class="line">    &#125;</span><br><span class="line">    ScanParams scanParams = <span class="keyword">new</span> ScanParams().count(<span class="number">100</span>);</span><br><span class="line">    String cursor = <span class="string">"0"</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ScanResult&lt;Tuple&gt; scanResult = jedis.zscan(bigZsetKey, cursor, scanParams);</span><br><span class="line">        List&lt;Tuple&gt; tupleList = scanResult.getResult();</span><br><span class="line">        <span class="keyword">if</span> (tupleList != <span class="keyword">null</span> &amp;&amp; !tupleList.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Tuple tuple : tupleList) &#123;</span><br><span class="line">                jedis.zrem(bigZsetKey, tuple.getElement());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cursor = scanResult.getStringCursor();</span><br><span class="line">    &#125; <span class="keyword">while</span> (!<span class="string">"0"</span>.equals(cursor));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除bigkey</span></span><br><span class="line">    jedis.del(bigZsetKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;Redis知识点汇总&quot;&gt;&lt;a href=&quot;#Redis知识点汇总&quot; class=&quot;headerlink&quot; title=&quot;Redis知识点汇总&quot;&gt;&lt;/a&gt;Redis知
      
    
    </summary>
    
      <category term="技术" scheme="https://thomstrong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="缓存" scheme="https://thomstrong.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Memcached 知识点</title>
    <link href="https://thomstrong.github.io/2019/06/20/Memcached/"/>
    <id>https://thomstrong.github.io/2019/06/20/Memcached/</id>
    <published>2019-06-20T07:30:29.000Z</published>
    <updated>2019-07-15T03:01:26.121Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Memcached知识点"><a href="#Memcached知识点" class="headerlink" title="Memcached知识点"></a>Memcached知识点</h1><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Memcached是一个免费开源的，高性能的，具有分布式对象的缓存系统，它可以用来保存一些经常存取的对象或数据，保存的数据像一张巨大的<strong>HASH表</strong>，该表以Key-value对的方式存在<strong>内存</strong>中。</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ul><li><p>检查客户端请求是否在memcached中</p></li><li><p>若有则直接返回</p></li><li><p>若无则从数据库查询后返回，并存储到memcached中</p></li><li><p>数据库更新需要同时更新memcached，保证一致性</p></li><li><p>memcached内存用完后会使用LRU策略加上到期失效策略，首先替换到期失效数据，之后替换最近未使用过的数据</p><blockquote><p>缓存置换算法（页面置换算法）FIFO/ LFU/ LRU</p><ol><li>FIFO 先进先出，最先进入缓存的最先替换掉</li><li>LFU 最近最少使用，替换掉最近一段时间使用次数最少的数据</li><li>LRU 最近最久未使用使用，替换掉最近一段时间没使用过的，以最近一次使用时间为基准，替换最远的数据空间</li></ol></blockquote></li></ul><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul><li><p>协议简单：基于文本行的协议，直接通过telnet在memcached服务器上可进行存取数据操作</p><blockquote><p>Telnet 远程连接服务，作用于tcp/ip协议的应用层</p></blockquote></li><li><p>基于libevent事件处理：libevent是一套利用C开发的程序库，由事件驱动，跨平台，支持并发编程</p></li><li>内置的内存管理方式：所有数据存于内存，LRU算法替换，数据易失</li><li>分布式：分布式取决于memcache客户端，memcached服务器之间互不通信，数据独立存储</li></ul><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><blockquote><p>服务启动方法<code>/usr/local/memcached/bin/memcached –p 11211 –d –u root –P /tmp/memcached.pid</code></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">telnet 127.0.0.1 11211 # 远程连接memcached</span><br><span class="line">stats items # 获取所有items的序号，例如items:29:hits_to_warm</span><br><span class="line">stats cachedump 29 0 # 获取编号29的item的key，返回如:1:/api/courses/tags/?；0表示返回所有slab中的item；若指定返回1个则使用stats cachedump 29 1</span><br><span class="line"></span><br><span class="line">get :1:/api/courses/tags/? # 获取key对应的值，多个键空格分割</span><br><span class="line"></span><br><span class="line">set cai 0 900 9 # 设置/更新key为cai的值为caicaicai，过期时间为900ms，以下输入的数据占9字节</span><br><span class="line">caicaicai # 存储成功返回STORED，失败返回ERROR</span><br><span class="line"></span><br><span class="line">add cai 0 900 9 # 设置key为cai的值为caicaicai，过期时间为900ms，以下输入的数据占9字节</span><br><span class="line">caicaicai # 存储成功返回STORED，失败或key存在返回NOT_STORED</span><br><span class="line"></span><br><span class="line"><span class="meta"> #</span> replace 用于直接替换</span><br><span class="line"><span class="meta"> #</span> append 用于直接在key对应的数据后面追加数据</span><br><span class="line"><span class="meta"> #</span> prepend 用于直接在key对应的数据前面追加数据</span><br><span class="line"> cas cai 0 900 3 14 # 14为gets获取到的token，CAS 通过先检查token后再设置/更新值，避免数据不一致</span><br><span class="line"> aaa # 成功返回STORED；保存错误/语法错误返回ERROR；EXISTS说明token过期/不合法；NOT_FOUND该key不存在</span><br><span class="line"></span><br><span class="line"> gets cai # 返回带有token的value</span><br><span class="line"></span><br><span class="line">incr key increment_value # 自增key对应的value，必须是32位无符号整数</span><br><span class="line">decr key increment_value # 自减key对应的value，必须是32位无符号整数</span><br><span class="line"></span><br><span class="line">stats # 输出统计信息</span><br></pre></td></tr></table></figure><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ul><li>内存分配：Slab allocation机制分配和管理，先按照预定的大小，将分配的内存分割成特定长度的内存块chunck，然后再把相同的内存块分成组slab，根据值的大小去匹配slab大小，找就近的slab存放</li><li>缓存策略：失效策略 + LRU；不会监控存入的key/value是否过期，而是获取key时去查看记录的时间戳，检查key/value是否过期</li><li>分布式算法：memcached本身不存在分布式，而是客户端进行分布式选择memcached服务器进行分布式存储，因此只考虑服务器选择算法<ul><li>余数算法：求得key的整数散列值，然后根据服务器台数求的余数进行服务器选择；但是服务器的增减都会导致缓存失效</li><li>散列算法：首先将服务器散列值映射到0～2^32^编号的圆上，然后找到从key的散列值开始的第一个圆点作为目标服务器；当从中间插入服务器时，只有第一个服务器逆时针算的第一个服务器会受影响；减少服务器时，只有所减少服务器的逆时针方向第一个服务器之间的数据会受影响</li></ul></li></ul><h3 id="可视化工具"><a href="#可视化工具" class="headerlink" title="可视化工具"></a>可视化工具</h3><p><a href="https://github.com/junstor/memadmin" target="_blank" rel="noopener">Memadmin</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;Memcached知识点&quot;&gt;&lt;a href=&quot;#Memcached知识点&quot; class=&quot;headerlink&quot; title=&quot;Memcached知识点&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="技术" scheme="https://thomstrong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="缓存" scheme="https://thomstrong.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>数智教育数据可视化创新大赛总结</title>
    <link href="https://thomstrong.github.io/2019/06/20/Tianchi-DataAnalysis/"/>
    <id>https://thomstrong.github.io/2019/06/20/Tianchi-DataAnalysis/</id>
    <published>2019-06-20T03:34:19.000Z</published>
    <updated>2019-07-15T03:00:33.444Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="数智教育数据可视化创新大赛总结"><a href="#数智教育数据可视化创新大赛总结" class="headerlink" title="数智教育数据可视化创新大赛总结"></a>数智教育数据可视化创新大赛总结</h1><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><blockquote><p>使用Django Rest Framework中规中矩的api，memcached简单配置</p></blockquote><ul><li><p>环境搭建</p><ul><li>使用virtualenv创建虚拟环境，防止环境污染</li><li>pip install 可以使用国内镜像源，pip install -i <a href="http://xxx.com/yyy/" target="_blank" rel="noopener">http://xxx.com/yyy/</a><ul><li>阿里云 <a href="http://mirrors.aliyun.com/pypi/simple/" target="_blank" rel="noopener">http://mirrors.aliyun.com/pypi/simple/</a></li><li>中国科技大学 <a href="https://pypi.mirrors.ustc.edu.cn/simple/" target="_blank" rel="noopener">https://pypi.mirrors.ustc.edu.cn/simple/</a></li><li>豆瓣(douban) <a href="http://pypi.douban.com/simple/" target="_blank" rel="noopener">http://pypi.douban.com/simple/</a></li><li>清华大学 <a href="https://pypi.tuna.tsinghua.edu.cn/simple/" target="_blank" rel="noopener">https://pypi.tuna.tsinghua.edu.cn/simple/</a></li><li>中国科学技术大学 <a href="http://pypi.mirrors.ustc.edu.cn/simple/" target="_blank" rel="noopener">http://pypi.mirrors.ustc.edu.cn/simple/</a></li></ul></li></ul></li><li><p>数据库配置</p><ul><li><p>考虑数据整体不会有太大变动，可能需要从本地开发环境直接迁移到线上服务器，所以使用docker搭载postgres的方法，上线后可直接将docker镜像进行恢复然后迁移数据</p></li><li><p>docker 镜像备份方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. docker save [container_name] &gt; bak.tar <span class="comment"># save as tar</span></span><br><span class="line">2. docker load -i ./bak.tar <span class="comment"># 恢复container</span></span><br><span class="line">3. 进入postgre创建database然后执行如下</span><br><span class="line">4. cat your_dump.sql | docker <span class="built_in">exec</span> -i your-db-container psql -U tianchiuser tianchidb</span><br></pre></td></tr></table></figure></li></ul></li><li><p>数据迁移</p><ul><li><p>使用runpython在migration中运行自定义脚本</p><ul><li>编写<code>def fun(apps, schema_editor)</code>函数，通过<code>apps.get_model()</code>获取数据模型</li><li>在operations中加入 <code>migrations.RunPython(fun, reverse_code=migrations.RunPython.noop)</code></li><li><code>reverse_code=migrations.RunPython.noop</code>使用reverse_code去定义回滚时使用的方法，此处会忽略runpython产生的任何修改，直接回滚</li></ul></li><li><p>回滚migration <a href="https://simpleisbetterthancomplex.com/tutorial/2016/07/26/how-to-reset-migrations.html" target="_blank" rel="noopener">参考链接</a></p><ul><li><code>python manage.py migrate [app_name] [migration_name]</code>将某个app的migrations回滚到某个migration文件为止</li><li>合并migration树<ol><li>./manage.py migrate —fake [app_name] zero 回滚全部migrate，但是保留数据</li><li>删除所有migration文件</li><li>./manage.py makemigrations 重新生成migration文件</li><li>./manage.py migrate —fake-initial 重新应用合并的migration 文件</li></ol></li><li><code>python manage.py showmigrations</code>可以查看当前已应用的migration</li></ul></li><li><p>Postgres 中创建用户</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">psql</span><br><span class="line">postgres<span class="comment"># CREATE USER xxxx1 WITH PASSWORD 'xxxx';</span></span><br><span class="line">postgres<span class="comment"># CREATE DATABASE xxxx2;</span></span><br><span class="line">postgres<span class="comment"># GRANT ALL PRIVILEGES ON DATABASE xxxx2 to xxxx1;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>缓存配置(memcached) <a href="http://chibisov.github.io/drf-extensions/docs/#cache-response" target="_blank" rel="noopener">参考文档</a></p><ul><li><p>settings配置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">CACHES = &#123;</span><br><span class="line">    <span class="string">'default'</span>: &#123;</span><br><span class="line">        <span class="string">'BACKEND'</span>: <span class="string">'django.core.cache.backends.memcached.MemcachedCache'</span>,</span><br><span class="line">        <span class="string">'LOCATION'</span>: <span class="string">'127.0.0.1:11211'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">INSTALLED_APPS = [</span><br><span class="line">    ...,</span><br><span class="line">    <span class="string">'django_extensions'</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">REST_FRAMEWORK_EXTENSIONS = &#123;</span><br><span class="line">    <span class="string">'DEFAULT_CACHE_KEY_FUNC'</span>: <span class="string">'utils.cache_funcs.calculate_cache_key'</span></span><br><span class="line">&#125; <span class="comment"># 使用自定义的calculate_cache_key函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过请求的url进行缓存</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_cache_key</span><span class="params">(view_instance, view_method,</span></span></span><br><span class="line"><span class="function"><span class="params">                        request, args, kwargs)</span>:</span></span><br><span class="line">    url = <span class="string">'&#123;&#125;?'</span>.format(request.path)</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> request.query_params:</span><br><span class="line">        url += <span class="string">'&#123;&#125;=&#123;&#125;&amp;'</span>.format(key, request.query_params[key])</span><br><span class="line">    <span class="keyword">return</span> url</span><br></pre></td></tr></table></figure></li><li><p>使用rest_framework_extensions提供的<code>@cache_response([x seconds]])</code>装饰器进行view的缓存</p></li></ul></li></ul><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><blockquote><p>使用 Ant Design Pro脚手架，Umi &amp; Dva</p></blockquote><ul><li><p>Umi 要点</p><ul><li>umi 里约定 mock 文件夹下的文件或者 page(s) 文件夹下的 _mock 文件即 mock 文件</li><li>对于整个系统来说，请求接口是复杂并且繁多的，为了处理大量模拟请求的场景，我们通常把每一个数据模型抽象成一个文件，统一放在 <code>mock</code> 的文件夹中，然后他们会自动被引入。</li><li>当本地开发完毕之后，修改config.js中的proxy配置</li><li>umi with dva<ul><li>按目录约定注册 model，无需手动 <code>app.model</code></li><li>文件名即 namespace，可以省去 <code>model</code> 导出的 <code>namespace</code> key</li><li>无需手写 <code>router.js</code>，交给 umi 处理，支持 <code>model</code> 和 <code>component</code> 的按需加载</li><li>内置 query-string 处理，无需再手动解码和编码</li><li>内置 dva-loading 和 dva-immer，其中 dva-immer 需通过配置开启</li><li>开箱即用，无需安装额外依赖，比如 dva、dva-loading、dva-immer、path-to-regexp、object-assign、react、react-dom 等</li></ul></li></ul></li><li><p>Dva</p><ul><li><p>State：一个对象，保存整个应用状态</p></li><li><p>View：React 组件构成的视图层</p></li><li><p>Action：一个对象，描述事件</p></li><li><p>connect 方法：一个函数，绑定 State 到 View，用于建立state 和 props的映射</p></li><li><p>dispatch 方法：一个函数，发送 Action 到 State，被 connect 的 Component 会自动在 props 中拥有 dispatch 方法。</p></li><li><p>model 对象属性</p><ul><li><p>namespace: 当前 Model 的名称。整个应用的 State，由多个小的 Model 的 State 以 namespace 为 key 合成</p></li><li><p>state: 该 Model 当前的状态。数据保存在这里，直接决定了视图层的输出</p></li><li><p>reducers: Action 处理器，处理同步动作，用来算出最新的 State</p></li><li><p>effects：Action 处理器，处理异步动</p><ul><li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">addAfter1Second</span>(<span class="params">action, &#123; put, call &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> call(delay, <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: <span class="string">'add'</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Effect 是一个 Generator 函数，内部使用 yield 关键字，标识每一步的操作（不管是异步或同步）。</p></li><li><p>call：执行异步函数</p></li><li><p>put：发出一个 Action，类似于 dispatch</p></li></ul></li></ul></li></ul></li><li><p>DOM 和 BOM</p><ul><li><p>window对象对应着浏览器窗口本身，这个对象的属性和方法通常被称为BOM</p></li><li><p>D（文档）可以理解为整个Web加载的网页文档，O（对象）可以理解为类似window对象只来的东西，可以调用属性和方法，这里我们说的是document对象，M（模型）可以理解为网页文档的树形结构，DOM树由节点构成</p></li><li><p>Window对象包含属性：document、location、navigator、screen、history、frames</p><p>Document根节点包含子节点：forms、location、anchors、images、links</p></li><li><p>BOM的核心是window，而window对象又具有双重角色，它既是通过js访问浏览器窗口的一个接口，又是一个Global（全局）对象</p></li><li><p>document对象：实际上是window对象的属性，document == window.document为true，是唯一一个既属于BOM又属于DOM的对象</p></li></ul></li><li><p>Suspense 相关 <a href="https://zhuanlan.zhihu.com/p/58979795" target="_blank" rel="noopener">参考文章</a></p><ul><li><p>懒加载<code>const ScoreLineChart = React.lazy(() =&gt; import(&#39;./ScoreLineChart&#39;));</code></p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;/div&gt;&#125;&gt;</span><br><span class="line">    &lt;ScoreLineChart /&gt;</span><br><span class="line">&lt;/Suspense&gt;</span><br></pre></td></tr></table></figure></li><li><p>使用懒加载的组件必须放入suspense中</p></li><li><p>未使用懒加载的组件不能放入suspense中，否则可能导致所挂载的dom没有渲染出来而导致报错</p></li></ul></li><li><p><code>constructor.name</code>不要用于做为判断的条件，因为webpack后会翻译为其他名字</p></li></ul><h3 id="部署-webpack"><a href="#部署-webpack" class="headerlink" title="部署 webpack"></a>部署 <a href="https://webpack.js.org/" target="_blank" rel="noopener">webpack</a></h3><blockquote><p>Umi build + nginx + docker实现</p></blockquote><ul><li><p>基于docker的打包和发布真的是很方便的，虽然在项目中使用的深度还不是很深，仅用了一些皮毛</p></li><li><p>webpack 打包时可用hush防止缓存不刷新带来的报错 <a href="https://www.cnblogs.com/ihardcoder/p/5623411.html" target="_blank" rel="noopener">参考链接</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].bundle.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>cdn 加速还是很有用的 <a href="https://unpkg.com/" target="_blank" rel="noopener">免费cdn加速</a></p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>官方文档要仔细阅读</li><li>不要重复造轮子</li><li><p>皮毛只能解决问题，但不能理解问题</p></li><li><p>代码规范还是要注重一下..虽然本次比赛比较赶没有任何规范</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;数智教育数据可视化创新大赛总结&quot;&gt;&lt;a href=&quot;#数智教育数据可视化创新大赛总结&quot; class=&quot;headerlink&quot; title=&quot;数智教育数据可视化创新大
      
    
    </summary>
    
      <category term="技术" scheme="https://thomstrong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="比赛" scheme="https://thomstrong.github.io/tags/%E6%AF%94%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>2019 Byte Camp-工程赛道面试经历</title>
    <link href="https://thomstrong.github.io/2019/06/17/2019-Byte-Camp/"/>
    <id>https://thomstrong.github.io/2019/06/17/2019-Byte-Camp/</id>
    <published>2019-06-17T07:25:59.000Z</published>
    <updated>2019-07-15T02:59:44.422Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="2019-Byte-Camp-工程赛道面试经历"><a href="#2019-Byte-Camp-工程赛道面试经历" class="headerlink" title="2019 Byte Camp-工程赛道面试经历"></a>2019 Byte Camp-工程赛道面试经历</h1><blockquote><p>面试官 30-40岁，主要从事后端</p></blockquote><ol><li><p>自我介绍</p></li><li><p>通过介绍中提及实习经历/实践经历提问</p><ul><li><p>线上实习如何分配时间</p></li><li><p>xx实习中使用的技术栈是什么？为什么用postgres？</p></li><li><p>React 是什么？大体介绍一下</p></li><li><p>你对rest api的认识</p><blockquote><p>针对资源</p><p>使用get/post/put/delete方法</p></blockquote></li><li><p>python 的装饰器是什么</p><blockquote><p>在不改变原函数功能的情况下增加额外功能</p></blockquote></li><li><p>数据库中group by 是什么（只回答了使用方法，原理未提及，需要重新理解）</p><blockquote><p>原理：使用松散索引/紧凑索引/临时表的方法在排序后分组</p></blockquote></li></ul></li><li><p>基础知识问答</p><ul><li><p>Linux进程相关，进程存储空间的分类，进程状态分类</p><blockquote><p>三状态模型：</p><ul><li>就绪ready：获得了处理机以外的所有资源，一旦得到处理机即可运行</li><li>运行running：进程在处理机上运行时</li><li>阻塞waiting：等待或者睡眠状态，等待某一事件发生中</li></ul></blockquote></li><li><p>tcp 三次握手过程，第一次握手发送报文名称，哪些flag置位<a href="https://blog.csdn.net/qq_33982721/article/details/78493967" target="_blank" rel="noopener">参考博客</a></p><blockquote><p>三次握手：避免失效请求报文错误建立了连接，导致server一直等待，浪费资源</p><ul><li>客户端syn seq=x</li><li>服务器 syn seq=y, ack=x+1</li><li>客户端ack=y+1</li></ul><p>四次挥手：tcp全双工模式，需要确定双方均无数据发送才可断开连接</p><ul><li>主机1 fin seq=x ack=y，x-1是主机1前面发送的最后一个字节的序号</li><li>主机2 ack=x+1</li><li>主机2 fin seq=y，y-1是主机2前面发送的最后一个字节序号</li><li>主机1 ack=y+1</li></ul><p>ack序号含义：希望收到第x个字节开始的报文段，且成功收到了前面x-1个报文</p></blockquote></li><li><p>二叉树，什么是完全二叉树，如何判别完全二叉树，设计算法</p><blockquote><p>可以使用栈的方式，按层遍历；如果本层存在有左无右的情况，那么下次遍历必须都是叶子结点；如果存在有右无左的情况，直接false</p></blockquote></li></ul></li><li><p>算法题</p><blockquote><p>给一个升序数组，判断这个数组每个元素平方后不同数字的个数</p></blockquote><ul><li>平方数没用，直接判断绝对值</li><li>使用头尾指针的方式向中间收缩</li><li>需考虑数组中连续相同数的情况</li></ul></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>基础知识复习完全不充分</li><li>描述自己见解时语言不清晰</li></ol><h3 id="附图"><a href="#附图" class="headerlink" title="附图"></a>附图</h3><ul><li>三次握手过程</li></ul><p><img src="/images/connection-establish.jpg" alt="三次握手"></p><ul><li>四次挥手过程</li></ul><p><img src="/images/connection-close.jpg" alt="三次握手"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;2019-Byte-Camp-工程赛道面试经历&quot;&gt;&lt;a href=&quot;#2019-Byte-Camp-工程赛道面试经历&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="技术" scheme="https://thomstrong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面经" scheme="https://thomstrong.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
</feed>
