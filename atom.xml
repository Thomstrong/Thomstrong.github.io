<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Thomstrong&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://thomstrong.github.io/"/>
  <updated>2021-08-29T14:33:01.808Z</updated>
  <id>https://thomstrong.github.io/</id>
  
  <author>
    <name>Thomstrong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>磨刀探索</title>
    <link href="https://thomstrong.github.io/2021/08/29/renew-knife/"/>
    <id>https://thomstrong.github.io/2021/08/29/renew-knife/</id>
    <published>2021-08-29T13:50:22.000Z</published>
    <updated>2021-08-29T14:33:01.808Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><blockquote><p>参考 <a href="https://www.kfcshop.com.tw/article.php?id=63" target="_blank" rel="noopener">https://www.kfcshop.com.tw/article.php?id=63</a></p></blockquote><h3 id="什么是锋利"><a href="#什么是锋利" class="headerlink" title="什么是锋利"></a>什么是锋利</h3><p>在显微镜下锋利的刀刃呈现笔直、齐整的直线，而钝刀的刀锋则呈现弯曲、坑洼的曲线</p><h3 id="为什么不用磨刀器"><a href="#为什么不用磨刀器" class="headerlink" title="为什么不用磨刀器"></a>为什么不用磨刀器</h3><ol><li>简易磨刀器，通常是由两个交错的石头组成，它磨出的纹路与刀刃平行，一方面这样的刀锋缺乏割力；另一方面，只将刀锋回归直线，也难以保持锋利。除了省事，没啥好处</li><li>磨刀石，似乎是介于发烧友和懒人之间的一种选择</li><li>定角磨刀器，需要一定技术，同时可以磨出锋利的刀刃</li><li>磨刀棒，日常维持锋利的利器</li></ol><h3 id="磨刀石选择"><a href="#磨刀石选择" class="headerlink" title="磨刀石选择"></a>磨刀石选择</h3><h4 id="材料"><a href="#材料" class="headerlink" title="材料"></a>材料</h4><ul><li>人工合成<ul><li>阿大耐石、绿碳油石，较软，容易磨损，但是磨的快</li><li>人造红宝石、人造白刚玉，较硬，超耐磨，但是磨的慢</li></ul></li><li>天然油石<ul><li>砂岩或泥岩</li></ul></li></ul><h4 id="目数"><a href="#目数" class="headerlink" title="目数"></a>目数</h4><ul><li>目数越高越细腻，磨出的刀刃越光滑</li><li>菜刀一般800目左右、普通品牌即可</li></ul><h3 id="磨刀步骤"><a href="#磨刀步骤" class="headerlink" title="磨刀步骤"></a>磨刀步骤</h3><ol><li><p>浸泡磨刀石，充分浸泡磨刀石大约半小时，使其吸收水分，防止磨刀过程过热导致刀刃损坏</p></li><li><p>准备一盆水在边上，过程中可以不定时洒水降温和保持润滑</p></li><li><p>磨刀石先使用粗面磨后使用细面磨。可以使用铅笔在磨刀石上划线以观察自己的磨刀进度</p></li><li><p>姿势，确保力度均匀</p><ul><li><p>刀背比刀刃略高硬币厚度（可根据刀锋角度自行调整），高度要适中，过高虽然可以使得刀刃很锋利，但是刀刃也容易崩</p></li><li><p>手腕保持平稳不移动</p><p><img src="/images/renew_knife_finger.jpeg" alt></p></li></ul></li><li><p>分段打磨，垂直刀刃，刀刃分区域进行打磨，确保刀口全部打磨到</p></li><li><p>全刃打磨，将刀从刀尖往刀枕方向打磨</p></li><li><p>打磨过程中磨刀石会出现包浆，是正常状态</p></li><li><p>打磨至产生毛边，即可换面磨刀</p><p><img src="/images/renew_knife_burrs.jpeg" alt></p></li><li><p>可以使用指甲检测刀口是否会滑，会滑则代表不够锋利</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;blockquote&gt;
&lt;p&gt;参考 &lt;a href=&quot;https://www.kfcshop.com.tw/article.php?id=63&quot; target=&quot;_blank&quot; 
      
    
    </summary>
    
    
      <category term="生活" scheme="https://thomstrong.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>五笔输入法学习</title>
    <link href="https://thomstrong.github.io/2021/04/14/try-five-pen/"/>
    <id>https://thomstrong.github.io/2021/04/14/try-five-pen/</id>
    <published>2021-04-14T12:27:22.000Z</published>
    <updated>2021-04-17T07:58:17.612Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><ul><li>智能拼音打字测速：76字/分钟，加快打字速度，尝试新技能</li></ul><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul><li><p>字根：组成汉字的部首和笔画</p></li><li><p>编码：组成汉字的字根对应的按键名称序列，最多为4位</p></li><li><p>重码字：编码重复的汉字</p></li><li><p>识别码：又称末笔字型交叉识别码，用于识别编码本应重复的汉字，减少重码字</p><ul><li>方法：末笔对应区号+汉字结构代码，组成区位号，对应键盘字母</li><li>示例：叭，末位为捺4，左右型1，则末位识别码为41对应的字母Y</li></ul></li><li><p>汉字字形：</p><ul><li><p>左右型：对（双合）、稚（三合）、键（多合）</p></li><li><p>上下型：类（双合）、素（三合）、斋（多合）</p></li><li><p>杂合型：太（单体）、周（内体） 、这（包围）</p><blockquote><p>两字根没有明显边界或相交组成的汉字、单笔和字根相连的汉字、带点的结构、带走之底的结构</p></blockquote></li></ul></li><li><p>笔画（键盘）分区：横区gfdsa、竖区hjklm、撇区trewq、点区yuiop、折区nbvcx</p></li><li><p>笔画代码：横1、竖2、撇3、捺4、折5</p></li><li><p>汉字字形代码：左右型1、上下型2、杂合型3</p></li><li><p>代码组合：笔画代码+字形代码，如21表示以竖起笔的左右型汉字</p></li><li><p>键名汉字：在五笔输入法键盘中从A-Y，每个按键对应了一个字，这个字则为键名</p></li><li><p>成字字根：字根中可以单独成字的字根</p></li><li><p>汉字与字根之间的关系</p><ul><li>单：单字根结构即字根本身即汉字，包括键名汉字、成字字根和五个笔画</li><li>散：多字根组成，字根之间有明显分界</li><li>连：<strong>字根与单笔划</strong>、字根与点组成的汉字</li><li>交：字根与字根交叉重叠而成</li></ul></li><li><p>五笔拆字原则</p><ul><li>书写顺序：从左到右、从上到下、先横后竖、先撇后捺、从里到外、先中间后两遍、先进门后关门</li><li>取大优先：使用尽量少的字根形成汉字</li><li>兼顾直观：兼顾拆分的直观性，不要强行拆分，将笔画拆分直两个字根中（丰 -&gt; 三 + 丨√     二 + 十 x）</li><li>能散不连、能连不交：按照散-&gt;连-&gt;交的优先级拆分汉字（天 -&gt; 一 + 大 √     二 + 人 x）</li></ul></li><li><p>区位号：</p><ul><li>区号：即笔画代码编号</li><li>位号：位号，根据按键位置编号，根据手指键位顺序排列</li><li>区位号：将区号和位号连接，如横区第一位G11、折区第二位B</li></ul></li><li><p>简码字：通过输入简单编码即可获得汉字，根据简化程度分为一级简码、二级简码、三级简码</p><ul><li>一级简码：直接对应键盘25位的25个汉字</li><li>二级简码、三级简码：按照字根顺序输入，在未全部输入编码前即可提前成字</li></ul></li><li><p>码元：98版概念，其含义对标字根，但是整体分布更加科学</p></li></ul><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><ul><li>简码字：一级简码字，直接输入简码对应的按键，即可直接获得</li><li>普通汉字输入法<ul><li>少于4个字根的汉字：输入全部编码，若汉字未出现，补打末位识别码</li><li>等于4个字根的汉字：完整输入字根</li><li>多于4个字根的汉字：输入前三个字根编码和最后一个字的字根编码</li></ul></li><li>词组输入方法：<ul><li>两字词组：2+2，分别输入两个字的前两个字根</li><li>三字词组：1+1+2，分别输入前两个字的第一个编码和第三个字的前两字根</li><li>四字或更多词组：1+1+1+1，分别输入前三个字的第一字根和最后一个字的字根</li></ul></li><li>偏旁输入方法：输入偏旁所在按键 -&gt; 按笔画输入第一笔、第二笔和最后一笔，组成汉字编码</li><li>键名汉字输入方法：重复按四次键名汉字对应按键</li><li>笔划输入方法：输入笔画对应键两次，再输入“L”键两次，如横为:”ggll”</li></ul><h1 id="五笔字根键位图及口诀"><a href="#五笔字根键位图及口诀" class="headerlink" title="五笔字根键位图及口诀"></a>五笔字根键位图及口诀</h1><p><img src="/images/five-pen-key-map.jpeg" alt></p><h1 id="一级简码字键盘映射"><a href="#一级简码字键盘映射" class="headerlink" title="一级简码字键盘映射"></a>一级简码字键盘映射</h1><p><img src="/images/simple-code-keymap.jpeg" alt></p><h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ul><li><a href="https://dazi.kukuw.com/keyboard.html" target="_blank" rel="noopener">在线打字练习</a></li><li><a href="https://www.bilibili.com/video/BV1aW41157U3?p=8" target="_blank" rel="noopener">五笔输入法教程</a>（由「Word联盟」在Bilibili发布）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; title=&quot;目标&quot;&gt;&lt;/a&gt;目标&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;智能拼音打字测速：76字/分
      
    
    </summary>
    
    
      <category term="技术" scheme="https://thomstrong.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>第一份工作确定啦</title>
    <link href="https://thomstrong.github.io/2020/11/26/got-my-first-job/"/>
    <id>https://thomstrong.github.io/2020/11/26/got-my-first-job/</id>
    <published>2020-11-26T02:52:06.000Z</published>
    <updated>2020-11-26T16:12:18.985Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="无论如何"><a href="#无论如何" class="headerlink" title="无论如何"></a>无论如何</h1><p>我的秋招结束了。</p><p>其实早在一周之前就已交出卖身契，早在一个月之前就已经确定未来的东家。只是最近一段时间以来的懒惰和各种事情纷至沓来，也给了自己一些拖延的借口。</p><h1 id="回想"><a href="#回想" class="headerlink" title="回想"></a>回想</h1><p>我的求职之路应该早在三年前就已经开始着手准备。</p><p>跟了老王干活一年，越发发现自己是廉价劳动力，出于手头项目的枯燥和没有工资内心的不服，开始了第一次求职之旅。先是与Pony一番交谈 ，发现自己不能胜任；最终敲定RichAI，一个当时不足20人的创业公司。回想起来，当时的日子，自信到有点自负、无忧带来快乐、自助带来肥胖。感谢RichAI所有的人，给我首席实习生的「荣誉称号」现在回想，可能倒不是技术首席，而是时间首席。也是因为Rich之旅，第一次知道外面大家都在用什么。</p><p>迫于开学离职，为了不被无情压榨，来到九章算法开启远程实习外快之旅。完全自由的工作时间，完全自由的工作地点。也有一两次加班，也有不知道怎么整的挠头。此前誓不做前端的我开启全栈工作。看到了大二就开始领导一个团队的大佬、看到了他们对技术的追求、看到了去了又来的同事，当然直至最终也没和大家见面。也是在九章这里，收获全栈经验，奇怪的技能又增加了。</p><p>在之后，小H对自己没法实习和对我们未来找工作的考虑，我们又开始搞比赛了。这次似乎是要动真格的了。我带着我偷来的全栈经验、她带着似乎是天生的数据分析设计直觉，我们冲到决赛、冲到杭州，一次比赛也是一次旅程。</p><p>而比赛结束后，闲不下来，听闻导师出国访学的消息，又开始捣鼓实习。偷偷摸摸开始一小段悠闲、快乐、富裕的时光。七月底，加入猿辅导，每次幸运的实习求职通过，让我不禁有些得意；而在其中悠哉悠哉的时光又令我有些担心。没有什么习得但那时是富有且悠闲的。</p><p>同样，又是一次偶然的机会，虽然面试情况很糟糕，但还是通过了字节夏令营的面试考验。本来只是一次尝试、玩玩而已，谁又曾想原来世界这么大。字节的夏令营无数的巧合与幸运，幸运的通过、幸运的分到了较少人的一组、幸运的踩在了自己的长处、幸运的发挥还不错、幸运的收获了实习offer。</p><p>开始字节漫长而短暂的实习。短暂于疫情使中间的欢快少了许多；漫长在于无数大佬的围绕，还没来及摸到技术的高墙就遗憾离开。在这里无疑我是开心的、放松的，但或许是没有晋升之类的业务压力？但大家都是开心的～应该也不会差到哪去吧。总之，我喜欢这里，喜欢大家相处的氛围、喜欢大佬带我一路前进的感觉。而又是一次幸运，随着春招接近尾声，屡屡碰壁之后选择放弃之际，接到阿里面试通知，又一次幸运的通过了。带着或多或少说不清楚的习得和再次回来的信念，我开启下一段实习之旅。</p><p>阿里让人又爱又恨。爱其名声之大、可能之多；恨其流言蜚语和片面的亲身感受给我带来的阴影。无助、崩溃、逃避一系列负面的词语充斥着这段实习。不过，或许从结果看来，这一切从获得的方面，也都是值得的吧。也更多发现了自己的不足和不被自己认可的能力和价值。</p><p>再后来，一切就此结束。抱住对字节美好的幻想，我最终选择投奔阿里。现实亦是如此。谢谢过往所有各位老师、哥啊姐啊、同学、师兄师姐对我的关照。我总觉得你们对我的认可总是超越我自己。承蒙厚爱。</p><p>对过往，学到一句话，苟富贵，莫相忘。</p><h1 id="对未来"><a href="#对未来" class="headerlink" title="对未来"></a>对未来</h1><p>先说一句，请多关照。希望自己一步一个脚印，走出一条特别的路。从不怕爱拼才会赢。既然机会已经在眼前，何不大胆追逐。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>承蒙厚爱。拿睿企的花盆，捧起九章的土，洒下天池的养料，施好猿力的肥，种下字节的种子。今天开始，一心向阿里取水。回来浇灌开出别样的花。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;无论如何&quot;&gt;&lt;a href=&quot;#无论如何&quot; class=&quot;headerlink&quot; title=&quot;无论如何&quot;&gt;&lt;/a&gt;无论如何&lt;/h1&gt;&lt;p&gt;我的秋招结束了。&lt;/p&gt;
      
    
    </summary>
    
      <category term="总结" scheme="https://thomstrong.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="秋招" scheme="https://thomstrong.github.io/tags/%E7%A7%8B%E6%8B%9B/"/>
    
  </entry>
  
  <entry>
    <title>秋招复习剪辑</title>
    <link href="https://thomstrong.github.io/2020/09/28/review-basic-knowledge/"/>
    <id>https://thomstrong.github.io/2020/09/28/review-basic-knowledge/</id>
    <published>2020-09-28T03:34:51.000Z</published>
    <updated>2020-11-16T02:53:09.682Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3><ul><li>or条件查询可能失效，可以使用union代替</li><li>字符串类型用引号括起来，否则失效</li><li>like非前缀匹配会引起失效</li><li>索引列使用mysql内置函数</li><li>索引列运算</li><li><p>索引字段使用!=、&lt;&gt;、not in、is null、is not null可能导致失效</p></li><li><p>左连接或右连接查询关联字段编码不一致</p></li><li>mysql优化器预估全表扫描快于索引查询</li></ul><h3 id="不适合索引场景"><a href="#不适合索引场景" class="headerlink" title="不适合索引场景"></a>不适合索引场景</h3><ul><li>数据量少（插入耗时增加？）</li><li>写多读少</li><li>区分度低的字段（如性别）</li></ul><h3 id="索引底层规则"><a href="#索引底层规则" class="headerlink" title="索引底层规则"></a>索引底层规则</h3><ul><li>覆盖索引（直接从索引一次性可查到数据）</li><li>回表（二级索引不能查到会回聚集索引中再查以得到最终数据）</li><li>索引条件下推优化（Using index condition）<ul><li>目的：减少IO次数</li><li>特殊：在根据索引获取数据时，通过下推条件判断是读取表中数据，还是读下一个索引，减少MySQL Server返回数据量</li><li>适用于：整表扫描场景，InnoDB只适用于二级索引</li><li>不适用于：引用子查询条件不能下推、调用存储过程不能下推、触发条件不能下推</li><li>配置：默认开启，属于存储引擎的优化手段，可通过<code>SET optimizer_switch = &#39;index_condition_pushdown=off&#39;;</code>配置开关</li></ul></li></ul><h3 id="索引数据结构"><a href="#索引数据结构" class="headerlink" title="索引数据结构"></a>索引数据结构</h3><h4 id="为什么是B-树而不是"><a href="#为什么是B-树而不是" class="headerlink" title="为什么是B+树而不是"></a>为什么是B+树而不是</h4><ul><li>一般二叉树<ul><li>二叉树特殊化为链表，每次查询都是全表扫描</li></ul></li><li>平衡二叉树<ul><li>平衡二叉树可存储数据较少，一个节点只存一个键值和数据，而B数可以存更多数据</li></ul></li><li>B树而是B+树<ul><li>B树非叶子节点也有数据，读取一个磁盘块包含的节点更多，减少IO查询速度也更快</li><li>B+树同层节点按序，且用双向链表连接，叶子节点内部数据用单向链表连接，使得排序、范围查找、去重查找变得更简单</li></ul></li></ul><h3 id="聚集索引和非聚集索引"><a href="#聚集索引和非聚集索引" class="headerlink" title="聚集索引和非聚集索引"></a>聚集索引和非聚集索引</h3><ul><li>一个表中只能有一个聚集索引，和多个非聚集索引</li><li>聚集索引索引键值的逻辑顺序对应了物理顺序，非聚集索引逻辑换顺序与物理顺序不同</li><li>如何选择</li></ul><table><thead><tr><th>动作</th><th>使用聚集</th><th>使用非聚集</th></tr></thead><tbody><tr><td>列经常分组排序</td><td>可</td><td>可</td></tr><tr><td>返回范围数据</td><td>可</td><td>不可</td></tr><tr><td>一个或极少数不同值</td><td>不可</td><td>不可</td></tr><tr><td>小数目不同值</td><td>可</td><td>不可</td></tr><tr><td>大数目不同值</td><td>不可</td><td>可</td></tr><tr><td>频繁更新列</td><td>不可</td><td>可</td></tr><tr><td>外键列</td><td>可</td><td>可</td></tr><tr><td>主键列</td><td>可</td><td>可</td></tr><tr><td>频繁修改索引列</td><td>不可</td><td>可</td></tr></tbody></table><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>按粒度分：表锁、页锁、行锁<ul><li>表锁：粒度最大、开销小、加锁快</li><li>页锁：BDB支持的锁机制，无人使用</li><li>行锁：对索引加锁，粒度最小锁，开销大、加锁慢，会出现死锁，冲突概率低，并发性能高<ul><li>记录锁：锁住单行记录的索引</li><li>间隙锁：锁住查询范围，防止幻读</li><li>临键锁：扩充锁住前后范围，防止幻读</li></ul></li></ul></li><li>使用方式：共享锁、排它锁</li><li>思想分：乐观锁、悲观锁</li></ul><h3 id="乐观锁和悲观锁（思想）"><a href="#乐观锁和悲观锁（思想）" class="headerlink" title="乐观锁和悲观锁（思想）"></a>乐观锁和悲观锁（思想）</h3><ul><li>悲观锁：直接加锁，阻塞其他线程修改</li><li>乐观锁：不上锁，更新的时候检查判定字段是否有被修改。CAS</li><li>强行加锁，如果指定索引列则加行锁，否则加表锁</li></ul><h3 id="Next-Key-Lock"><a href="#Next-Key-Lock" class="headerlink" title="Next Key Lock"></a>Next Key Lock</h3><blockquote><p>Record Lock 和 Gap Lock 的结合，记住！是为了解决幻读</p></blockquote><ul><li>对非主键索引查询，记录的上下记录区间加锁，如对记录1,2,3,5,8查询3则会锁住(2,3]U[3,5)记录区间</li><li>对主键索引，不会产生幻读，因此只加普通行锁</li></ul><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul><li>程序出现高并发时，尽量对表串行化操作或锁升级，一次性获取全部资源</li><li>设置<code>innodb_lock_wait_timeout</code>变量，使得锁等待超时回滚</li><li>打开<code>innodb_deadlock_detect</code>变量，当发现死锁时，自动回滚其中一个事务</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><strong>锁竞争查询</strong>：<code>show status like table_lock</code>可以查看锁竞争状态，waited越大代表锁竞争越严重</li><li><strong>并发插入</strong>：通过<code>concurrent_insert</code>变量调整并发插入配置，0不支持、1只要没有删除即插入表尾、2无论是否有删除都插入表尾</li></ul><h2 id="查询优化方法"><a href="#查询优化方法" class="headerlink" title="查询优化方法"></a>查询优化方法</h2><ul><li>加索引</li><li>仅返回需要的字段</li><li>offset &amp; limit</li><li>sql结构优化</li><li>分库分表<ul><li>水平分表：一个库中的数据拆分为多个表（hash、range）</li><li>垂直分表：按照业务拆分；按照字段活性，拆分主表和扩展表</li><li>事务需要使用分布式事务</li></ul></li><li>读写分离</li></ul><h4 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h4><ul><li>explain</li><li>慢查询日志（–log-slow-queries启动项和long_query_time ）</li></ul><h2 id="分布式主键方案"><a href="#分布式主键方案" class="headerlink" title="分布式主键方案"></a>分布式主键方案</h2><ul><li>数据库自增序列或字段</li><li>UUID</li><li>Redis生成ID</li></ul><h2 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h2><h3 id="InnoDB和MyISAM区别"><a href="#InnoDB和MyISAM区别" class="headerlink" title="InnoDB和MyISAM区别"></a>InnoDB和MyISAM区别</h3><ul><li>InnoDB独有<ul><li>事务</li><li>外键</li><li>MVCC多版本并发控制</li></ul></li><li>MyISAM独有<ul><li>全文索引（InnoDB5.7后支持）</li><li>变量保存表总行数，select count(*) from table更快</li></ul></li><li>区别<ul><li>InnoDB支持表、行锁，MyISAM只支持表锁，InnoDB使用索引默认为行锁，不使用则为表锁</li><li>InnoDB必须有主键，MyISAM可以没有主键</li><li>InnoDB表需要更多内存和存储，MyISAM可被压缩</li><li>InnoDB按主键大小有序插入，MyISAM按插入顺序保存</li></ul></li></ul><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="MySQL事务特性"><a href="#MySQL事务特性" class="headerlink" title="MySQL事务特性"></a>MySQL事务特性</h3><ul><li>原子性<ul><li>定义：事务作为整体，要么全部执行要么全部不执行</li><li>机制保障：undo log恢复事务执行之前的状态</li></ul></li><li>一致性<ul><li>定义：事务开始之前和结束之后的数据不会被破坏，典型案例：转账</li><li>机制保障：回滚、恢复、并发隔离</li></ul></li><li>隔离性<ul><li>定义：多事务并发访问时，事务之间是相互隔离的</li><li>机制保障：锁、MVCC</li></ul></li><li>持久性<ul><li>定义：事务完成后，所有更改应该均保存到数据库中</li><li>机制保障：redo log崩溃恢复</li></ul></li></ul><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><h4 id="事务并发带来的问题"><a href="#事务并发带来的问题" class="headerlink" title="事务并发带来的问题"></a>事务并发带来的问题</h4><blockquote><p>不同隔离级别导致的问题</p></blockquote><ul><li>脏读：事务A读取到了事务B未提交的数据</li><li>不可重复读：事务A受到事务B影响前后两次读取同一条数据不同</li><li>幻读：事务A受事务B影响，前后两次读取同一批数据不同</li></ul><h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><blockquote><p>带来上述问题</p></blockquote><ul><li>读未提交：事务可以读取到其他事务未提交数据，导致脏读<ul><li>读不加锁，写阻塞其他事务写，不阻塞读</li></ul></li><li>读已提交：事务只能读取到其他事务中已经提交的数据，可能导致不可重复读<ul><li>每次读取数据前，生成新的ReadView</li></ul></li><li><p>可重复读：事务开始时会将select的数据打一份快照，保证同一个事务内select不受其他事务update/delete影响（系统默认隔离级别）</p><ul><li>仅在第一次读取时生成一个ReadView</li></ul></li><li><p>串行化：防止事务并发</p><ul><li>读加共享锁，写加互斥锁</li></ul></li></ul><h3 id="MVCC-多版本并发控制"><a href="#MVCC-多版本并发控制" class="headerlink" title="MVCC 多版本并发控制"></a>MVCC 多版本并发控制</h3><ul><li>依赖于隐式字段、undo日志、快照读&amp;当前读、Read View<ul><li>每行记录存在隐藏列，记录事务ID、指向undo日志的指针、单调递增的RowID（无主键和非NULL唯一键）</li><li>undo日志：事务未提交时修改数据操作的反向操作存到undo日志。数据的undo日志指针会将不同事务产生的多个版本用指针串连</li><li>快照读：不加锁读，读取记录数据当前可见版本</li><li>当前读：显式加锁读读取记录最新版本</li><li>Read View：事务执行快照时产生的读视图，保存当时留存的事务ID列表，通过判断数据的记录事务ID决定数据是否可见<ul><li>当前ID小于当前最小事务ID，说明数据在当前留存事务前已经提交，可见</li><li>当前ID大于事务最大事务ID，说明数据版本是在ReadView生成后才生成，数据不可见</li><li>生成数据版本的事务ID在事务ID列表中，说明事务只生成了数据版本，但是未提交，不可见；如果不在事务ID列表中，生成数据版本已提交，可见。</li></ul></li></ul></li></ul><h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><ul><li>在使用exists和in时，遵循小表驱动大表原则</li></ul><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><blockquote><p>CPU调度进程，因此也称CPU调度算法</p></blockquote><h4 id="进程五状态模型"><a href="#进程五状态模型" class="headerlink" title="进程五状态模型"></a>进程五状态模型</h4><ul><li>就绪：已经获得所有所需资源，等待分配处理机资源</li><li>运行：占用处理机资源</li><li>阻塞：等待所需资源得到满足</li><li>新建：进程创建但未被提交，等待获取资源</li><li>终止：进程运行完毕</li></ul><h4 id="CPU调度时机"><a href="#CPU调度时机" class="headerlink" title="CPU调度时机"></a>CPU调度时机</h4><ul><li>运行状态到阻塞状态 =&gt; 非抢占式</li><li>运行状态到就绪状态 =&gt; 抢占式</li><li>阻塞状态到就绪状态 =&gt; 抢占式</li><li>运行状态到终止状态  =&gt; 非抢占式</li></ul><h4 id="抢占式调度和非抢占式调度"><a href="#抢占式调度和非抢占式调度" class="headerlink" title="抢占式调度和非抢占式调度"></a>抢占式调度和非抢占式调度</h4><ul><li>抢占式调度：当前进程被动放弃处理机，如时间片用完、有更紧急的事情需要处理（IO中断）、有更高优先级进程进入队列</li><li>非抢占式调度：当前进程主动放弃处理机，如进程正常终止、进程运行中异常终止、近程主动请求阻塞（等待IO）</li></ul><h4 id="不会发生进程调度"><a href="#不会发生进程调度" class="headerlink" title="不会发生进程调度"></a>不会发生进程调度</h4><ul><li>处理中断时</li><li>进程在操作系统内核临界区时</li><li>进行原子操作时</li></ul><h4 id="调度算法-1"><a href="#调度算法-1" class="headerlink" title="调度算法"></a>调度算法</h4><h5 id="批处理系统调度算法"><a href="#批处理系统调度算法" class="headerlink" title="批处理系统调度算法"></a>批处理系统调度算法</h5><blockquote><p>关注公平性、平均周转时间、平均等待时间等理性指标，不考虑任务的紧急程度</p></blockquote><ul><li><p>FCFS 先来先服务</p><ul><li>特点：非抢占式，先到先服务</li><li>优点：对各个作业公平，算法简单，不会产生进程饿死</li><li>缺点：对CPU密集作业有利，对IO密集作业不利。CPU密集型需要占用更多CPU时间，导致IO密集型需要更多的等待时间</li></ul></li><li><p>SJF 短作业优先</p><ul><li>特点：短作业优先，非抢占式（抢占式场景为SRTN  最短剩余时间优先算法）</li><li>优点：短作业可以更快被调度，拥有最短平均等待时间和平均周转时间</li><li>缺点：长作业可能被饿死，工程实现上较难</li></ul></li><li><p>HRRN 高响应比优先</p><blockquote><p>响应比 = （ 等待时间+实际运行时间 ）/ 实际运行时间 = 等待时间 / 实际运行时间 + 1 </p></blockquote><ul><li>特点：综合FCFS和SJF算法，当运行时间相同，响应比越高等待时间越长越应该被调度类似FCFS；当等待时间相同，响应比越高运行时间越短越应该被调度类似SJF</li></ul></li></ul><h5 id="交互系统调度算法"><a href="#交互系统调度算法" class="headerlink" title="交互系统调度算法"></a>交互系统调度算法</h5><blockquote><p>更注重响应时间、公平性、平衡性</p></blockquote><ul><li>RR 时间片轮转法<ul><li>特点：所有任务轮转使用固定时间片运行，抢占式调度</li><li>优点：公平、响应快</li><li>缺点：时间片把握，太长退化成FCFS，太短导致上下文切换时间过高</li></ul></li><li>HPF 最高优先级调度<ul><li>特点：根据任务优先级抢占式/非抢占式调度</li><li>优点：考虑任务优先级情况</li><li>缺点：任务可能会饿死</li></ul></li><li>多级反馈队列<ul><li>特点：<ul><li>多级执行队列，不同队列执行时间片递增</li><li>队列内部FCFS，一个时间片没有执行完则进入下一级队列</li><li>已经是最后一级队列则放入队尾</li><li>时间片越短队列级别越高，总是先抢占式调度高级别队列任务</li></ul></li><li>优点：融合了FCFS的公平性、SFJ对短作业的照顾、RR对进程的响应速度</li><li>缺点：存在进程饿死的场景</li></ul></li></ul><h3 id="内存页面置换"><a href="#内存页面置换" class="headerlink" title="内存页面置换"></a>内存页面置换</h3><h4 id="缺页中断"><a href="#缺页中断" class="headerlink" title="缺页中断"></a>缺页中断</h4><ul><li>CPU执行Load M指令会访问M对应的页表</li><li>当页表标记有效时，直接访问内存；标记无效时，发送缺页中断</li><li>缺页中断后，查找磁盘对应数据，写入物理内存</li><li>写入物理内存时，若找到空闲页，则直接写入，若未找到，则需要替换已存在的物理内存页，若是脏页则需要将对应的页写回盘，页表项标记无效</li></ul><h4 id="置换算法"><a href="#置换算法" class="headerlink" title="置换算法"></a>置换算法</h4><ul><li>OPT 最佳页面置换<ul><li>算法：置换下次访问时间最长的页</li><li>优点：最低程度较少缺页</li><li>缺点：工程无法实现，程序访问页面是无法准确预知下一次访问时间的</li></ul></li><li>FIFO 先进先出<ul><li>算法：替换驻留时间最长的页</li><li>优点：实现简单</li><li>缺点：性能较低</li></ul></li><li>LRU 最久未使用<ul><li>算法：替换最长时间没有被访问的页（双向链表，访问置队尾，替换队头）</li><li>优点：性能相对FIFO有所提高，且工程上可以实现</li><li>缺点：实现相对复杂，开销较大</li></ul></li><li>时钟页面置换算法<ul><li>算法：<ul><li>构造环形队列，页面访问位初始化为0，初始指向0号页面</li><li>若被访问，将访问位置1</li><li>需要替换时，从当前指向节点开始，替换第一个访问位为0的页面，并将沿途为访问位为1的页面改为0</li></ul></li><li>优点：结合了LRU和FIFO的特点，每次替换近期未使用的较早进入队列的页面，减少替换页面时的开销</li></ul></li><li>LFU 最不常使用算法<ul><li>算法：替换最不经常使用的页面，对页表项添加计数器，替换最小的页面</li><li>缺点：对于短期内高频访问而之后不再访问的页面无法正确置换，同时计数器硬件成本较高</li></ul></li></ul><h3 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h3><h4 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h4><ul><li>算法：按照请求顺序先来先服务</li><li>特点：实现简单，但是效率无法保证</li></ul><h4 id="最短寻道时间优先"><a href="#最短寻道时间优先" class="headerlink" title="最短寻道时间优先"></a>最短寻道时间优先</h4><ul><li>算法：总是找离磁头最近的磁道优先访问</li><li>特点：效率有所提高，但是可能存在请求饿死</li></ul><h4 id="扫描算法"><a href="#扫描算法" class="headerlink" title="扫描算法"></a>扫描算法</h4><ul><li>算法：也叫电梯算法，先朝某个方向移动至顶端再返回</li><li>特点：效率有一定提升，但是每个磁道的响应频率存在差异</li><li>循环扫描算法：每次朝同一个方向到达另一端顶点后，返回头部，中间不接收任何请求</li></ul><h4 id="LOOK-amp-C-LOOK算法"><a href="#LOOK-amp-C-LOOK算法" class="headerlink" title="LOOK &amp; C-LOOK算法"></a>LOOK &amp; C-LOOK算法</h4><ul><li>算法：类似扫描算法，但是不到达端点，而是到达最远端请求磁道后即返回</li></ul><h2 id="进程互斥与同步"><a href="#进程互斥与同步" class="headerlink" title="进程互斥与同步"></a>进程互斥与同步</h2><h3 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h3><ul><li>并发进程的共享资源</li><li>同一时间内只支持一个进程访问</li></ul><h3 id="资源访问分区"><a href="#资源访问分区" class="headerlink" title="资源访问分区"></a>资源访问分区</h3><ul><li>进入区：检查是否可以进入临界区</li><li>临界区：访问共享资源</li><li>退出区：重置临界区占用标识</li><li>剩余区：其他逻辑</li></ul><h3 id="进程互斥原则"><a href="#进程互斥原则" class="headerlink" title="进程互斥原则"></a>进程互斥原则</h3><ul><li>空闲让进：临界区空闲时应该让想要进去临界区的进程立刻进来</li><li>忙则等待：如果已经有资源进入临界区，则其他进程只能等待</li><li>有限等待：保证等待进入临界区的进程等待时间是有限的，不能一直等下去</li><li>让权等待：当进程不能进入自己的临界区时，应该释放CPU资源，防止进程“忙等”</li></ul><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><ul><li>机制：通过P/V原语操作标记资源数量的变量，原语有不可中断的性质，实现多进程互斥访问</li><li>数值型信号量：数值标记资源 + while循环等待</li><li>记录型信号量：数值标记资源 + 进程等待队列，资源不足时阻塞进程，防止忙等</li></ul><h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><h4 id="使用信号量控制进程同步"><a href="#使用信号量控制进程同步" class="headerlink" title="使用信号量控制进程同步"></a>使用信号量控制进程同步</h4><ul><li>信号量初始化为0</li><li>在后操作之前使用P原语阻塞进程</li><li>当“前操作”执行完毕后，调用V原语，增加资源，唤醒“后操作”进程。前VP后</li></ul><h3 id="典型例题"><a href="#典型例题" class="headerlink" title="典型例题"></a>典型例题</h3><h4 id="生产者消费者"><a href="#生产者消费者" class="headerlink" title="生产者消费者"></a>生产者消费者</h4><ul><li>互斥规则：缓存区要么放要么取</li><li>同步规则：只有缓存区有东西才可以取 ；只有缓存区有空位才可以放；</li><li>伪代码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">producer() &#123;consumer() &#123;</span><br><span class="line">生产商品    P(full)</span><br><span class="line">P(empty)   P(mutex)</span><br><span class="line">P(mutex)  取商品</span><br><span class="line">商品放入缓存  V(mutex)</span><br><span class="line">V(mutex)  V(empty)</span><br><span class="line">V(full)  使用产品</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="橘子苹果问题"><a href="#橘子苹果问题" class="headerlink" title="橘子苹果问题"></a>橘子苹果问题</h4><ul><li>互斥规则：盘子要么放水果要么取水果</li><li><p>同步规则：盘中有橘子儿子才取；盘中有苹果女儿才取；盘中无水果父母才放</p></li><li><p>伪代码</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Dad() &#123;Mom() &#123;</span><br><span class="line">P(empty)P(empty)</span><br><span class="line">放苹果  放橘子</span><br><span class="line">V(apple)V(orage)</span><br><span class="line">&#125;&#125;</span><br><span class="line"></span><br><span class="line">Daughter() &#123;Son() &#123;</span><br><span class="line">P(apple)P(orange)</span><br><span class="line">取苹果    取橘子</span><br><span class="line">V(empty)V(empty)</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h3><ul><li>互斥规则：读写互斥，读读不互斥</li><li>同步规则：无</li><li>伪代码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Writer() &#123;Reader() &#123;</span><br><span class="line">P(w)P(w)// 确保读写公平，防止写进程饿死</span><br><span class="line">P(rw)P(mutex)// 锁住count，防止阻塞其他读进程</span><br><span class="line">写文件  if (count == 0) &#123;</span><br><span class="line">V(rw)P(rw)// 首个读进程阻塞写操作</span><br><span class="line">V(w)&#125;</span><br><span class="line">conunt += 1</span><br><span class="line">&#125;V(mutex)</span><br><span class="line">V(w)</span><br><span class="line">读文件</span><br><span class="line">P(mutex)</span><br><span class="line">count --</span><br><span class="line">if (count == 0) &#123;</span><br><span class="line">V(rw)</span><br><span class="line">&#125;</span><br><span class="line">V(mutex)</span><br></pre></td></tr></table></figure><h3 id="哲学家吃饭问题"><a href="#哲学家吃饭问题" class="headerlink" title="哲学家吃饭问题"></a>哲学家吃饭问题</h3><ul><li>互斥规则：筷子只能被一位哲学家使用</li><li>同步规则：只有等身边的哲学家吃完自己才能开始吃</li><li>伪代码（略）<ul><li>方法1：一次申请全部资源，使得拿筷子是原子操作</li><li>方法2：奇数号哲学家先拿左手筷子，偶数号哲学家先拿右手筷子</li><li>方法3：只有n-1人能够参与筷子争夺</li></ul></li></ul><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h3 id="OSI七层模型和TCP-IP四层模型"><a href="#OSI七层模型和TCP-IP四层模型" class="headerlink" title="OSI七层模型和TCP/IP四层模型"></a>OSI七层模型和TCP/IP四层模型</h3><blockquote><p>ref: <a href="https://zhuanlan.zhihu.com/p/32059190" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32059190</a></p></blockquote><table><thead><tr><th>四层</th><th>七层</th><th>应用层</th><th>功能</th><th>TCP/IP协议族</th></tr></thead><tbody><tr><td>4</td><td>7</td><td>应用层</td><td>为应用程序提供网络服务</td><td>Http、Telnet、Ftp、Email、DNS</td></tr><tr><td>4</td><td>6</td><td>表示层</td><td>数据格式转化</td><td>无</td></tr><tr><td>4</td><td>5</td><td>会话层</td><td>解除或建立与其他端点连接</td><td>无</td></tr><tr><td>3</td><td>4</td><td>传输层</td><td>提供端对端接口</td><td>TCP、UDP（RTP）</td></tr><tr><td>2</td><td>3</td><td>网络层</td><td>数据包路由选择</td><td>IP、ICMP、ARP、RARP、BOOTP</td></tr><tr><td>1</td><td>2</td><td>链路层</td><td>传输有地址帧、错误检测</td><td>SLIP、CSLIP、PPP、</td></tr><tr><td>1</td><td>1</td><td>物理层</td><td>二进制形式传输</td><td>IEEE 802.1A</td></tr></tbody></table><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><ol><li><p>慢启动</p><ul><li><p>连接建好后初始化窗口大小 cwnd = 10</p></li><li><p>当收到一个ACK，cwnd += 1，经过一个RTT，cwnd翻倍，指数增加</p></li><li><p>当cwnd &gt;= ssthresh时，进入拥塞避免算法</p></li></ul></li><li><p>拥塞避免</p><ul><li>经过一个RTT，发送方拥塞窗口cwnd += 1</li></ul></li><li><p>快速重传</p><ul><li>主要用于丢包检测</li></ul></li><li><p>快速恢复</p><ul><li>当检测到丢包时，触发快速重传，进入降窗状态，将cwnd降到一个合理值</li></ul></li></ol><h1 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h1><h2 id="缓存系统"><a href="#缓存系统" class="headerlink" title="缓存系统"></a>缓存系统</h2><h3 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h3><ul><li>一致性：存储和缓存中的数据的一致性问题</li><li>缓存击穿：查询在缓存中未命中，透传DB查询，大量击穿导致DB拒绝服务</li><li>缓存雪崩：数据过期时间近似，大量数据同时过期或冷数据瞬间涌入大量请求导致DB压力过大拒绝服务</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;数据库&quot;&gt;&lt;a href=&quot;#数据库&quot; class=&quot;headerlink&quot; title=&quot;数据库&quot;&gt;&lt;/a&gt;数据库&lt;/h1&gt;&lt;h2 id=&quot;索引&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="技术" scheme="https://thomstrong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="基础知识" scheme="https://thomstrong.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>第一次制作泡芙有感</title>
    <link href="https://thomstrong.github.io/2020/03/14/first-paofu/"/>
    <id>https://thomstrong.github.io/2020/03/14/first-paofu/</id>
    <published>2020-03-14T13:34:51.000Z</published>
    <updated>2020-03-26T17:49:06.699Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>​        每天吃完饭都要刷会儿b站～前两天看到了泡芙的制作方法～再想想公司曾经的下午茶～那个泡芙～那个唇齿留香～决定周末也来搞一搞。因为有无须各种粉的配方～于是只购买了奶油～今天便开始动手了～配方如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">黄油 50g</span><br><span class="line">糖一勺盐小半勺</span><br><span class="line">牛奶120ml</span><br><span class="line">鸡蛋1个</span><br><span class="line">富强粉粉80g</span><br><span class="line">裱花袋/保鲜袋 若干</span><br></pre></td></tr></table></figure><p>步骤如下：</p><ol><li>混合黄油、牛奶、糖、盐，小火烧微开</li><li>倒入面粉，碾至细腻，关键是要把面粉<strong>烫熟</strong>，后续才能产生空心（关键点1）</li><li>细腻面团放凉备用</li><li>打鸡蛋，逐渐放入凉面团中，搅拌至能拉出倒三角（关键点2，实不相瞒，我没见过）</li><li>裱花袋或保鲜袋挤到烘焙油纸上，一定不要抠，每个小团多挤一些，否则空心不会很大并且外表会很焦（别问我咋知道）</li></ol><p>最后，成品如下：</p><p><img src="/images/paofu.jpg" alt="别人做的"></p><p>哦，那是别人做的</p><p><img src="/images/my_paofu.JPG" alt></p><p>由于没有很漂亮的空心，于是就不继续浪费奶油啦😅</p><p>是不是突然发现，没有挤奶油的步骤？</p><p>下次一定。</p><p>由此，也有一些感悟～比如底层原理很重要～比如自己的思考很重要。其实在混合面粉的步骤就已经开始摸不着头脑了～为啥我的是这样？再加点水是不是就和up主一样了？</p><p>期待未来和更好的泡芙再相遇～glhf</p><h3 id="第二次实践"><a href="#第二次实践" class="headerlink" title="第二次实践"></a>第二次实践</h3><blockquote><p> 20.3.21 配方不变，更换裱花神器～由于过于自信～最终失败</p></blockquote><p>虽然失败，但是成色上比上一次好多了。也因为失败了此次依然当作空心饼干吃，没有灌奶油步骤。</p><p><img src="/images/paofu_200321.png" alt></p><p><strong>总结</strong>：1. 面浆太干，倒三角不明显就急于挤，可以先烤一个出来看看效果，蛋液量就可以作为未来的参考了 2. 挤面浆时压得太低导致面浆金炉前就较为紧凑，中空效果不明显</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;​        每天吃完饭都要刷会儿b站～前两天看到了泡芙的制作方法～再想想公司曾经的下午茶～那个泡芙～那个唇齿留香～决定周末也来搞一搞。因为有无须各种粉的配方～于是只购买
      
    
    </summary>
    
      <category term="生活" scheme="https://thomstrong.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="饕餮" scheme="https://thomstrong.github.io/tags/%E9%A5%95%E9%A4%AE/"/>
    
  </entry>
  
  <entry>
    <title>Golang 源码解析系列学习</title>
    <link href="https://thomstrong.github.io/2020/03/12/golang-source-code/"/>
    <id>https://thomstrong.github.io/2020/03/12/golang-source-code/</id>
    <published>2020-03-12T15:36:23.000Z</published>
    <updated>2020-04-19T05:01:47.448Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><blockquote><p>本文参考 公众号：Go语言中文网 微信号: studygolang 系列文章记录</p></blockquote><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="基本原理概述"><a href="#基本原理概述" class="headerlink" title="基本原理概述"></a>基本原理概述</h3><p><img src="../images/go_source_code_map.png" alt></p><ol><li><p>Map 底层是通过hash table存储，每个元素是一个<code>bmap</code>(下称为bucket)</p></li><li><p>每个bucket的是一个容量为<code>bucketCnt=8</code>的链表，用于解决冲突</p></li><li><p>将key进行hash，获取到的数对应的二进制，低B位用于确定桶序号，高8位用于确定桶中的Tophash(用于标记key所在Cell)</p><ul><li>若低B位冲突，则入桶后，计算Tophash放入桶链表的第一个空位中</li><li>若桶溢出，则通过桶的最后一个overflow指针指向overflow bucket</li><li>桶中存放kv的格式是kkk…vvv。将k和v分别存放；这样可以避免在使用kvkvkv组合交替存放时，需要填充一些位数(padding)来补齐数据以便查找的空间浪费</li></ul></li><li><p>B通过负载因子(loadFactor)和map可容纳kv数量(count)决定，不超过15</p><ul><li><p>count &lt;= loadFactor * 2^B^</p></li><li><p>bucktCount = 2^B^ </p></li><li>loadFactor 内置为6.5，</li></ul></li><li><p>loadFactor=6.5？若桶恰好全满时负载因子为8 （每个桶的8个位置全占满，则kv数量为桶的8倍），那么6.5就可以表时现在的负载状态已经进入有点拥挤状态，碰撞频发，性能可能开始下降，因此需要调整<code>B</code>的大小；loadFactor太大，会导致桶溢出严重，性能下降；loadFactor太小又会导致整个桶过于稀疏，不仅浪费，在极端情况下还可能导致查询效率退化为线型。</p></li><li><p>kv的查找，基本遵循上述原则，当查询出现桶号一样且Tophash相同，会进一步比较key；若在本bucket没找到，且overflow不为空则会去overflow bucket中找</p></li><li><p>为不破坏bucket不含指针的理念，overflow指针通过hmap.extra.[]overflow汇集所有bucket的overflow指针，初始化为2^B-4^个(B &gt;=4时)</p></li><li><p>原生Map在读写删前会检查是否有并发写删在进行，因此不支持并发操作</p></li><li><p>在写Map时，会先计算插入桶的位置，并且检查，如果需要扩容，则会先进行扩容，然后重新计算插入的位置；最终确定可写再写kv</p></li><li><p>若可写入但是没有位置了，需要申请overflow buket和当前buket”串联”用于存放新key</p></li><li>写Map时可能导致扩容，扩容的先决条件是负载超过负载因子（kv数大于桶数的6.5倍）<strong>或者</strong>overflow桶过多（overflow桶的估计值大于等于桶的个数）</li><li>Map的过程是对bucket搬迁的过程，首先通过B++来完成bucket扩容，并将老bucket<strong>s</strong>挂入hmap对应指针，新bucket<strong>s</strong>分配内存。而后，在每次写和删除kv时尝试对未完成的搬迁工程进行，每次最多搬迁2个bucket</li><li>Map的遍历因为上述的底层存储形式（bucket =&gt; cell）和搬迁的存在导致遍历的存在无序<strong>可能</strong>；而又为了让用户意识到无序性的存在，在遍历Map时，起始bucket会是随机的，使得即使Map是个”常量”也是无序遍历，<strong>最终</strong>导致Map的无序遍历。</li><li>对Map的删除，只会将topHash清零，供未来使用，不会将已有的Cell往前怼（考虑效率怼不符合逻辑），因此如果进行一波大批量不超过负载因子的插入，再进行一大波删除，overflow会始终存在，使得kv存储的很分散。这就是为什么前面扩容也需要对overflow桶个数进行考虑。</li><li>基于上述过程，也就可以发现，在读写map时需要经过hash、查找、读写的流程，而这一套流程当出现并发场景时，就可能导致如协程A准备查找没有准备写入；A写入前B也进行查找，也没有，也进行写入，这就导致了数据覆盖。</li></ol><h2 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h2><ol><li>一个Slice结构体中包含一个指向底层数组的指针、<code>len int</code>、<code>cap int</code>，因此规定占24字节（64位机器）</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">array unsafe.Pointer <span class="comment">// 指向底层数组的指针</span></span><br><span class="line"><span class="built_in">len</span>   <span class="keyword">int</span> <span class="comment">// 当前slice长度</span></span><br><span class="line"><span class="built_in">cap</span>   <span class="keyword">int</span> <span class="comment">// slice分配的底层数组大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建Slice</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeslice</span><span class="params">(et *_type, <span class="built_in">len</span>, <span class="built_in">cap</span> <span class="keyword">int</span>)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line"> <span class="comment">// 1. 计算slice申请的空间cap，初步判断是否会超过内存限制</span></span><br><span class="line">mem, overflow := math.MulUintptr(et.size, <span class="keyword">uintptr</span>(<span class="built_in">cap</span>))</span><br><span class="line">  <span class="comment">// 2. 如果超过可分配空间限制或者len、cap指定的不合理准备抛异常</span></span><br><span class="line"><span class="keyword">if</span> overflow || mem &gt; maxAlloc || <span class="built_in">len</span> &lt; <span class="number">0</span> || <span class="built_in">len</span> &gt; <span class="built_in">cap</span> &#123;</span><br><span class="line">    <span class="comment">// 2.1 解释了一下如果len不合理，则优先抛出len异常，因为cap是一个隐含的属性，因此优先抛出len更易理解一些</span></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> Produce a 'len out of range' error instead of a</span></span><br><span class="line"><span class="comment">// 'cap out of range' error when someone does make([]T, bignumber).</span></span><br><span class="line"><span class="comment">// 'cap out of range' is true too, but since the cap is only being</span></span><br><span class="line"><span class="comment">// supplied implicitly, saying len is clearer.</span></span><br><span class="line"><span class="comment">// See golang.org/issue/4085.</span></span><br><span class="line">mem, overflow := math.MulUintptr(et.size, <span class="keyword">uintptr</span>(<span class="built_in">len</span>))</span><br><span class="line"><span class="keyword">if</span> overflow || mem &gt; maxAlloc || <span class="built_in">len</span> &lt; <span class="number">0</span> &#123;</span><br><span class="line">panicmakeslicelen()</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 2.2 如果len合理而cap不合理则抛出cap异常</span></span><br><span class="line">panicmakeslicecap()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3. 一切正常，分配空间。</span></span><br><span class="line">  <span class="comment">// 若分配空间在32KB一下，会从per-P cache的freelist申请，可以理解为本地cache</span></span><br><span class="line">  <span class="comment">// 大于32KB情况下，会直接向heap申请空间</span></span><br><span class="line"><span class="keyword">return</span> mallocgc(mem, et, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>添加元素</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// append函数发生扩容时主要底层实现是growslice函数，需要将元素类型、老的slice和append后所需的新最小容量cap传入</span></span><br><span class="line"><span class="comment">// 返回是一个新的slice，容量至少为传入的cap</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growslice</span><span class="params">(et *_type, old slice, <span class="built_in">cap</span> <span class="keyword">int</span>)</span> <span class="title">slice</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 新cap的计算规则，最开始假定容量不变</span></span><br><span class="line">  <span class="comment">// 先计算理论新容量cap的大小，内存块对齐后会有进一步变化</span></span><br><span class="line">  newcap := old.<span class="built_in">cap</span></span><br><span class="line">doublecap := newcap + newcap</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">    <span class="comment">// 如果新的容量cap是原先的两倍以上，那么直接扩容为新容量</span></span><br><span class="line">newcap = <span class="built_in">cap</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> old.<span class="built_in">len</span> &lt; <span class="number">1024</span> &#123;</span><br><span class="line">      <span class="comment">// append前的slice长度在1024以下，容量翻倍增长</span></span><br><span class="line">newcap = doublecap</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// append前的slice长度在1024以上，则新容量使用1.25^n速率趋近所需容量</span></span><br><span class="line">      <span class="comment">// 判断0 &lt; newcap是为了防止溢出导致数值变为负数</span></span><br><span class="line"><span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line">newcap += newcap / <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果新的容量计算溢出，则请求值是多少分配多少</span></span><br><span class="line"><span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">newcap = <span class="built_in">cap</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">// 根据元素类型 &amp; 计算出的新容量newCap理论值计算内存</span></span><br><span class="line">  <span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> et.size == <span class="number">1</span>: <span class="comment">// 元素大小为1字节，"个数"即内存</span></span><br><span class="line">lenmem = <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>)</span><br><span class="line">newlenmem = <span class="keyword">uintptr</span>(<span class="built_in">cap</span>)</span><br><span class="line">capmem = roundupsize(<span class="keyword">uintptr</span>(newcap))</span><br><span class="line">overflow = <span class="keyword">uintptr</span>(newcap) &gt; maxAlloc</span><br><span class="line">newcap = <span class="keyword">int</span>(capmem)</span><br><span class="line"><span class="keyword">case</span> et.size == sys.PtrSize:<span class="comment">// 元素为指针大小则使用元素类型大小计算内存分配大小</span></span><br><span class="line">lenmem = <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>) * sys.PtrSize</span><br><span class="line">newlenmem = <span class="keyword">uintptr</span>(<span class="built_in">cap</span>) * sys.PtrSize</span><br><span class="line">capmem = roundupsize(<span class="keyword">uintptr</span>(newcap) * sys.PtrSize) <span class="comment">// 内存对齐，避免过多内存碎片</span></span><br><span class="line">overflow = <span class="keyword">uintptr</span>(newcap) &gt; maxAlloc/sys.PtrSize</span><br><span class="line">newcap = <span class="keyword">int</span>(capmem / sys.PtrSize) <span class="comment">// 使用内存对齐后的内存大小重新计算容量值</span></span><br><span class="line"><span class="keyword">case</span> isPowerOfTwo(et.size): <span class="comment">// 如果元素大小是2的次方数，则计算过程可以使用位运算代替乘除运算</span></span><br><span class="line"><span class="keyword">var</span> shift <span class="keyword">uintptr</span></span><br><span class="line"><span class="keyword">if</span> sys.PtrSize == <span class="number">8</span> &#123;</span><br><span class="line"><span class="comment">// Mask shift for better code generation.</span></span><br><span class="line">shift = <span class="keyword">uintptr</span>(sys.Ctz64(<span class="keyword">uint64</span>(et.size))) &amp; <span class="number">63</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">shift = <span class="keyword">uintptr</span>(sys.Ctz32(<span class="keyword">uint32</span>(et.size))) &amp; <span class="number">31</span></span><br><span class="line">&#125;</span><br><span class="line">lenmem = <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>) &lt;&lt; shift</span><br><span class="line">newlenmem = <span class="keyword">uintptr</span>(<span class="built_in">cap</span>) &lt;&lt; shift</span><br><span class="line">capmem = roundupsize(<span class="keyword">uintptr</span>(newcap) &lt;&lt; shift)</span><br><span class="line">overflow = <span class="keyword">uintptr</span>(newcap) &gt; (maxAlloc &gt;&gt; shift)</span><br><span class="line">newcap = <span class="keyword">int</span>(capmem &gt;&gt; shift)</span><br><span class="line"><span class="keyword">default</span>: <span class="comment">// 以上情况都不是则直接使用元素大小计算</span></span><br><span class="line">lenmem = <span class="keyword">uintptr</span>(old.<span class="built_in">len</span>) * et.size</span><br><span class="line">newlenmem = <span class="keyword">uintptr</span>(<span class="built_in">cap</span>) * et.size</span><br><span class="line">capmem, overflow = math.MulUintptr(et.size, <span class="keyword">uintptr</span>(newcap))</span><br><span class="line">capmem = roundupsize(capmem)</span><br><span class="line">newcap = <span class="keyword">int</span>(capmem / et.size)</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 将原有底层数组头字节old.array开始的lenmem长度的内存拷贝到新底层数组指针p上，完成底层数组的复制</span></span><br><span class="line">  memmove(p, old.array, lenmem)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 底层数组指针变为新指针p，长度不变，容量变为新容量newcap</span></span><br><span class="line"><span class="keyword">return</span> slice&#123;p, old.<span class="built_in">len</span>, newcap&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>Slice 截取</li></ol><ul><li>由于上述<code>growslice</code>的底层实现，在截取后，底层数组不会发生变化</li><li>因此如果直接修改元素会影响到公用底层数组的所有slice</li><li>仅当某次append执行了<code>growslice</code>后同步影响才会消除</li><li>因此获取slice可以使用<code>newSlice :=append([]uint8{}, s[1:2]...)</code>消除底层数组影响</li></ul><ol start="4"><li>copy</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slicecopy</span><span class="params">(to, fm slice, width <span class="keyword">uintptr</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> fm.<span class="built_in">len</span> == <span class="number">0</span> || to.<span class="built_in">len</span> == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">n := fm.<span class="built_in">len</span></span><br><span class="line"><span class="keyword">if</span> to.<span class="built_in">len</span> &lt; n &#123; <span class="comment">// 最终拷贝的数组大小以fm和to两个slice中长度较短的为准</span></span><br><span class="line">n = to.<span class="built_in">len</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> width == <span class="number">0</span> &#123; <span class="comment">// 元素大小为0</span></span><br><span class="line"><span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">size := <span class="keyword">uintptr</span>(n) * width</span><br><span class="line"><span class="keyword">if</span> size == <span class="number">1</span> &#123; <span class="comment">// 一个字节则直接赋值即可</span></span><br><span class="line">*(*<span class="keyword">byte</span>)(to.array) = *(*<span class="keyword">byte</span>)(fm.array) <span class="comment">// known to be a byte pointer</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 将fm.array开始，长度为size的内存拷贝至to.array上</span></span><br><span class="line">memmove(to.array, fm.array, size)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>slice的本质是结构体，因此在函数传参时，也是将<code>{arrayPointer, len, cap}</code>这样一个结构体传递。如果函数操作对<code>arrayPinter</code>指向的底层数组操作变化，原slice也会变化；否则，不影响原slice。</li></ol><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><blockquote><p>不要用共享内存来通信，而用通信的方式来共享内存</p></blockquote><ul><li><code>chan</code> 的底层结构</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">qcount   <span class="keyword">uint</span>           <span class="comment">// chan中元素的总数</span></span><br><span class="line">dataqsiz <span class="keyword">uint</span>           <span class="comment">// 底层缓冲区循环数组分配的大小</span></span><br><span class="line">buf      unsafe.Pointer <span class="comment">// 指向循环数组的指针</span></span><br><span class="line">elemsize <span class="keyword">uint16</span> <span class="comment">// 元素大小</span></span><br><span class="line">closed   <span class="keyword">uint32</span> <span class="comment">// chan是否关闭</span></span><br><span class="line">elemtype *_type <span class="comment">// 元素类型</span></span><br><span class="line">sendx    <span class="keyword">uint</span>   <span class="comment">// 已发送元素在循环数组中的下标</span></span><br><span class="line">recvx    <span class="keyword">uint</span>   <span class="comment">// 已接收元素在循环数组中的下标</span></span><br><span class="line">recvq    waitq  <span class="comment">// 等待接收元素的goroutine队列</span></span><br><span class="line">sendq    waitq  <span class="comment">// 等待发送元素的goroutine队列</span></span><br><span class="line">lock     mutex <span class="comment">// 控制chan并发访问的锁, 保护范围包括了hchan的字段和waitq中sudog的字段; </span></span><br><span class="line">    <span class="comment">// 因此channel是并发安全的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">first *sudog <span class="comment">// sudo表示一个等待发送/接受的goroutine队列，保存了G信息和双向指针等信息</span></span><br><span class="line">last  *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>chan</code>的创建</li></ol><ul><li>chan一般情况下都会通过make创建（只读、只写channel一般只用于传参）。<code>make</code>函数在编译期间，会先编译成OMAKE节点，在类型检查阶段，会转化成OMAKECHAN，最终在SSA中间代码生成阶段之前被转换成<code>makechan</code> 或者 <code>makechan64</code> 的函数调用。<code>makechan64</code>用于处理缓冲区大小大于 2 的 32 次方的情况，可以主要关注<code>makechan</code>方法（需要了解go编译方面的知识）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="keyword">int</span>)</span> *<span class="title">hchan</span></span> &#123;</span><br><span class="line">elem := t.elem</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 计算所需的buf内存大小</span></span><br><span class="line">mem, overflow := math.MulUintptr(elem.size, <span class="keyword">uintptr</span>(size))</span><br><span class="line"><span class="keyword">if</span> overflow || mem &gt; maxAlloc-hchanSize || size &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">"makechan: size out of range"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers.</span></span><br><span class="line"><span class="comment">// buf points into the same allocation, elemtype is persistent.</span></span><br><span class="line"><span class="comment">// SudoG's are referenced from their owning thread so they can't be collected</span></span><br><span class="line"><span class="keyword">var</span> c *hchan</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> mem == <span class="number">0</span>: <span class="comment">// 无需缓冲区(struct&#123;&#125;&#123;&#125;类型所占内存为0 或者 size == 0)，只需要分配hchan的内存空间</span></span><br><span class="line">c = (*hchan)(mallocgc(hchanSize, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line"><span class="comment">// Race detector uses this location for synchronization.</span></span><br><span class="line">c.buf = c.raceaddr()</span><br><span class="line"><span class="keyword">case</span> elem.ptrdata == <span class="number">0</span>: <span class="comment">// 元素类型不为指针类型，需要分配hchan+buf的一段连续空间</span></span><br><span class="line">c = (*hchan)(mallocgc(hchanSize+mem, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line"><span class="keyword">default</span>: <span class="comment">// 元素为指针类型，单独分配hchan和buf的内存空间</span></span><br><span class="line"><span class="comment">// Elements contain pointers.</span></span><br><span class="line">c = <span class="built_in">new</span>(hchan)</span><br><span class="line">c.buf = mallocgc(mem, elem, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.elemsize = <span class="keyword">uint16</span>(elem.size)</span><br><span class="line">c.elemtype = elem</span><br><span class="line">c.dataqsiz = <span class="keyword">uint</span>(size)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debugChan &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"makechan: chan="</span>, c, <span class="string">"; elemsize="</span>, elem.size, <span class="string">"; dataqsiz="</span>, size, <span class="string">"\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>chan</code>的写入（发送数据）</li></ol><ul><li>编译器讲发送数据语句<code>ch &lt;- i</code>，编译器会解析为<code>OSEND</code>节点，并最终转换为<code>chansend1</code>函数；而<code>chansend1</code>函数则直接调用的<code>chansend</code>函数</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>, callerpc <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> !block &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanSendNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">throw(<span class="string">"unreachable"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debugChan &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"chansend: chan="</span>, c, <span class="string">"\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">racereadpc(c.raceaddr(), callerpc, funcPC(chansend))</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> !block &amp;&amp; c.closed == <span class="number">0</span> &amp;&amp; ((c.dataqsiz == <span class="number">0</span> &amp;&amp; c.recvq.first == <span class="literal">nil</span>) ||</span><br><span class="line">(c.dataqsiz &gt; <span class="number">0</span> &amp;&amp; c.qcount == c.dataqsiz)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t0 <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">t0 = cputicks()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Found a waiting receiver. We pass the value we want to send</span></span><br><span class="line"><span class="comment">// directly to the receiver, bypassing the channel buffer (if any).</span></span><br><span class="line">send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line"><span class="comment">// Space is available in the channel buffer. Enqueue the element to send.</span></span><br><span class="line">qp := chanbuf(c, c.sendx)</span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">raceacquire(qp)</span><br><span class="line">racerelease(qp)</span><br><span class="line">&#125;</span><br><span class="line">typedmemmove(c.elemtype, qp, ep)</span><br><span class="line">c.sendx++</span><br><span class="line"><span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">c.sendx = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">c.qcount++</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !block &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Block on the channel. Some receiver will complete our operation for us.</span></span><br><span class="line">gp := getg()</span><br><span class="line">mysg := acquireSudog()</span><br><span class="line">mysg.releasetime = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">mysg.releasetime = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// No stack splits between assigning elem and enqueuing mysg</span></span><br><span class="line"><span class="comment">// on gp.waiting where copystack can find it.</span></span><br><span class="line">mysg.elem = ep</span><br><span class="line">mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">mysg.g = gp</span><br><span class="line">mysg.isSelect = <span class="literal">false</span></span><br><span class="line">mysg.c = c</span><br><span class="line">gp.waiting = mysg</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">c.sendq.enqueue(mysg)</span><br><span class="line">gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanSend, traceEvGoBlockSend, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// Ensure the value being sent is kept alive until the</span></span><br><span class="line"><span class="comment">// receiver copies it out. The sudog has a pointer to the</span></span><br><span class="line"><span class="comment">// stack object, but sudogs aren't considered as roots of the</span></span><br><span class="line"><span class="comment">// stack tracer.</span></span><br><span class="line">KeepAlive(ep)</span><br><span class="line"></span><br><span class="line"><span class="comment">// someone woke us up.</span></span><br><span class="line"><span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">throw(<span class="string">"G waiting list is corrupted"</span>)</span><br><span class="line">&#125;</span><br><span class="line">gp.waiting = <span class="literal">nil</span></span><br><span class="line">gp.activeStackChans = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> gp.param == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> c.closed == <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">"chansend: spurious wakeup"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">&#125;</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">mysg.c = <span class="literal">nil</span></span><br><span class="line">releaseSudog(mysg)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;blockquote&gt;
&lt;p&gt;本文参考 公众号：Go语言中文网 微信号: studygolang 系列文章记录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Map&quot;&gt;&lt;a
      
    
    </summary>
    
      <category term="技术" scheme="https://thomstrong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Golang" scheme="https://thomstrong.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Etcd &amp; Raft</title>
    <link href="https://thomstrong.github.io/2020/02/24/learn-etcd/"/>
    <id>https://thomstrong.github.io/2020/02/24/learn-etcd/</id>
    <published>2020-02-24T02:49:59.000Z</published>
    <updated>2020-02-29T07:04:26.637Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="Etcd-简介"><a href="#Etcd-简介" class="headerlink" title="Etcd 简介"></a>Etcd 简介</h2><blockquote><p>在笔者看来，Etcd就是一个用<a href="https://github.com/etcd-io/etcd/tree/master/client" target="_blank" rel="noopener">SDK</a>访问的k-v存储。</p></blockquote><p><a href="https://etcd.io/" target="_blank" rel="noopener">官方</a>介绍一句话，A distributed, reliable key-value store for the most critical data of a distributed system，翻译一下就是分布式系统重要的k-v数据用我准没错。</p><p><strong>特性</strong></p><ul><li>接口简单：可通过标准的http工具完成数据读写，使用json作为数据格式</li><li>k-v存储：使用有分级组织目录的方式存储数据，如文件系统一般</li><li>变更监听：可以监听特定的Key / 目录的变更，可对值的更改作出反应</li><li>可靠：可选SSL客户端证书作为身份鉴别</li><li>性能：每个实例可支持10000次/s的写入</li><li>时效性：可选地设置Key的存储超时</li><li>一致性：通过Raft算法保证分布式部署下的数据一致性</li></ul><h2 id="Etcd-应用"><a href="#Etcd-应用" class="headerlink" title="Etcd 应用"></a>Etcd 应用</h2><h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><p>其高可用、强一致的特性，支持k-v数据的存储，不再赘述</p><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>通过将Etcd作为注册中心，把服务名称与服务可用地址绑定，完成服务的注册和查找。</p><p><strong>作用</strong></p><ol><li>保证分布式场景下，注册中心中服务目录<strong>强一致</strong></li><li>通过Key过期机制，保持与服务间的心跳链接，<strong>监控服务健康状态</strong></li><li>通过Proxy模式使得服务之间相互连接</li></ol><h3 id="分布式场景下的Master选举"><a href="#分布式场景下的Master选举" class="headerlink" title="分布式场景下的Master选举"></a>分布式场景下的Master选举</h3><p>可通过Etcd的事务操作( mini-transactions )完成多个服务器之间的抢主操作，实现Master服务器选举。由于Etcd能够保证强一致，因此，若对于某个key，如master_ip使用事务写，则可以保证所有服务器读取到的master_ip是一致的。而当master发生异常后，又可以通过超时机制，将master_ip淘汰，完成新master选举。</p><h3 id="分布式并发控制"><a href="#分布式并发控制" class="headerlink" title="分布式并发控制"></a>分布式并发控制</h3><p>通过Etcd存储分布式信号量，完成分布式并发控制。同时，可以使用Etcd存储运行周期较长的任务数据，以便在机器故障，且需要导出执行状态时可恢复。</p><h2 id="Etcd-总结"><a href="#Etcd-总结" class="headerlink" title="Etcd 总结"></a>Etcd 总结</h2><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul><li>强一致性、性能较好、变更监听</li><li>相比于zookeeper使用简单</li></ul><h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h4><ul><li>默认存储历史记录有限，因此更适合读多写少的场景，更新频繁会导致数据丢失</li></ul><h2 id="Raft-一致性算法"><a href="#Raft-一致性算法" class="headerlink" title="Raft 一致性算法"></a>Raft 一致性算法</h2><h3 id="什么是一致性"><a href="#什么是一致性" class="headerlink" title="什么是一致性"></a>什么是一致性</h3><h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><p>一致性是对于可容错分布式系统必须解决的基础问题，需要多个服务器在对同一个数据的存储上保持一致，即对于集群中任何一台请求某个数据所返回的值都是一样的。经典的一致性算法需要保证只要集群中大多数服务器可用，那么就可以处理请求，也就是说，比如集群中有5台服务器，挂了2台仍可以处理请求。但是如果挂了2台以上，那么就不再处理请求，而绝不会返回错误的结果。</p><h4 id="状态机-amp-Log"><a href="#状态机-amp-Log" class="headerlink" title="状态机 &amp; Log"></a>状态机 &amp; Log</h4><p>一致性算法通常的应用背景是在于复制状态机，同样也是构建一个可容错系统的常见方法。容错系统中，每个服务器有一个记录状态的结构，称为状态机；还有记录操作的log文件。<strong>状态机</strong>是构建容错系统的核心，并且从客户端看来，无论访问哪个服务器，即使集群中有少数服务器已经宕机，同一个请求获得的回复都是一致的。而对于每个状态机，它们都会从各自的log中获取输入命令。因此，一致性算法通常也是保证log的一致性，使得不同服务器之间有同样的操作命令序列，最终也就能实现状态机状态的一致。</p><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>可将背景设想为一个数据库服务器集群里面只存储了一个数，所有的请求都是对这个数据的操作。</p><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><h5 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h5><p>对于集群中的服务器有以下三种状态：</p><ul><li>跟随者 Follower：一个任期中除了Leader以外的服务器，也是服务器的初始状态</li><li>候选者 Candidate：任期超时后的Follower</li><li>领导者 Leader：被大多数服务器认可的Candidate，所有来自客户端的请求都需通过打向Leader完成</li></ul><h5 id="记录-Entry"><a href="#记录-Entry" class="headerlink" title="记录 Entry"></a>记录 Entry</h5><p>每个请求所代表的操作会以记录的形式在每个服务器的Log中保存</p><h5 id="插入记录-Append-Entries"><a href="#插入记录-Append-Entries" class="headerlink" title="插入记录 Append Entries"></a>插入记录 Append Entries</h5><p>Leader与Follower之间进行信息交互的数据结构</p><h5 id="心跳-Heart-beat"><a href="#心跳-Heart-beat" class="headerlink" title="心跳 Heart beat"></a>心跳 Heart beat</h5><p>Leader会定时给所有Follower发送Append Entries，维系组织关系，保证所有Follower能感知Leader</p><h5 id="选举-Election"><a href="#选举-Election" class="headerlink" title="选举 Election"></a>选举 Election</h5><p>通过选举，可在集群中选中一个对外交互的Leader服务器</p><h5 id="选举超时-election-timeout"><a href="#选举超时-election-timeout" class="headerlink" title="选举超时 election timeout"></a>选举超时 election timeout</h5><p>每个follower服务器中有一个超时时间，用于等待成为candidate的时机，通常为150～300 ms。</p><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><h5 id="Leader-选举"><a href="#Leader-选举" class="headerlink" title="Leader 选举"></a>Leader 选举</h5><ol><li>Follower选举超时后，状态变为Candidate，开启新的任期，准备任选（先给自己投一票…过于真实）</li><li>Candidate发起对集群中其他服务器的投票邀请</li><li>收到邀请的服务器选举超时重置，满足以下条件对Candidate投票：<ul><li>当前任期内未投过票</li><li>Candidate的Log信息和我能够匹配</li></ul></li><li>获取大多数服务器投票后，Candidate变成Leader，否则等待下一轮选举超时，直到最终选出Leader</li><li>选举成功后Leader同步心跳</li></ol><h5 id="日志复制-Log-Replication"><a href="#日志复制-Log-Replication" class="headerlink" title="日志复制 Log Replication"></a>日志复制 Log Replication</h5><p>请求打到Leader上时，发生如下过程，完成一次日志的复制：</p><ol><li>Leader的log中写入一条记录，标记为未提交状态</li><li>下一次心跳时，向所有follower同步未提交的记录</li><li>Leader等到大多数follower响应，Leader将操作记录提交，返回client请求</li><li>下一次心跳时，同步提交的记录，使得所有follow也提交本次操作</li></ol><h5 id="算法流程-1"><a href="#算法流程-1" class="headerlink" title="算法流程"></a>算法流程</h5><p>首先经过Leader选举，在集群中选举出对外交互的Leader。Leader收到操作请求后，完成日志复制，使得集群Log一致。</p><p>发生网络故障导致脑裂时，由于过程中的操作存在“大多数”原则，因此只有大多数的请求会被响应。故障排除后，通过较高任期选举出的Leader心跳，数据就会再度同步，而之前未提交的请求则会被丢弃，集群再次达到一致状态</p><h3 id="Raft-总结"><a href="#Raft-总结" class="headerlink" title="Raft 总结"></a>Raft 总结</h3><h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h4><ul><li>相对于更早的Paxos算法易理解、易实现</li><li>性能较高，只需要大多数Follower同步即可写入</li><li>强调Leader的唯一性，保证了强一致性</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>协议限制了只能有序提交，并且强调集群中只能有一个group</li></ul><h3 id="其他一致性协议"><a href="#其他一致性协议" class="headerlink" title="其他一致性协议"></a>其他一致性协议</h3><p>两阶段提交协议、三阶段提交协议、向量时钟RWN协议、Paxos协议、ZAB 算法、PBFT 算法</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Etcd 官网：<a href="https://etcd.io/" target="_blank" rel="noopener">https://etcd.io/</a></p><p>Etcd repo：<a href="https://github.com/etcd-io/etcd" target="_blank" rel="noopener">https://github.com/etcd-io/etcd</a></p><p>Etcd介绍的博客：<a href="http://blog.itpub.net/69953029/viewspace-2667738/" target="_blank" rel="noopener">http://blog.itpub.net/69953029/viewspace-2667738/</a></p><p>Raft 一致性算法图解：<a href="https://raft.github.io/" target="_blank" rel="noopener">https://raft.github.io/</a></p><p>其他分布式协议：<a href="https://blog.csdn.net/chdhust/article/details/52651741" target="_blank" rel="noopener">https://blog.csdn.net/chdhust/article/details/52651741</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;Etcd-简介&quot;&gt;&lt;a href=&quot;#Etcd-简介&quot; class=&quot;headerlink&quot; title=&quot;Etcd 简介&quot;&gt;&lt;/a&gt;Etcd 简介&lt;/h2&gt;&lt;bl
      
    
    </summary>
    
      <category term="技术" scheme="https://thomstrong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="etcd" scheme="https://thomstrong.github.io/tags/etcd/"/>
    
  </entry>
  
  <entry>
    <title>浅尝 Golang gorountine</title>
    <link href="https://thomstrong.github.io/2020/02/12/go-gpm/"/>
    <id>https://thomstrong.github.io/2020/02/12/go-gpm/</id>
    <published>2020-02-12T15:53:02.000Z</published>
    <updated>2020-04-07T08:00:01.695Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="并发的演进"><a href="#并发的演进" class="headerlink" title="并发的演进"></a>并发的演进</h2><h3 id="单进程"><a href="#单进程" class="headerlink" title="单进程"></a>单进程</h3><p>单进程时代，一切<strong>只能</strong>串行。</p><p><strong>问题：</strong></p><ol><li>one by one </li><li>阻塞了怎么办？<strong>效率太低</strong></li></ol><h3 id="多进程-amp-多线程"><a href="#多进程-amp-多线程" class="headerlink" title="多进程&amp;多线程"></a>多进程&amp;多线程</h3><p>多进程/多线程解决了阻塞问题，让进程阻塞时空闲的CPU可以很好的利用起来，这样，似乎多个进程是在同时被运行。</p><p><strong>问题：</strong></p><ol><li>进程间创建、切换、销毁需要占用很长时间，调度大量时间</li><li>进程/线程占用更多的内存资源</li></ol><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>线程分为内核态线程和用户态线程，一个用户态线程必须绑定一个内核态线程。这样的用户态线程可以成为协程。多协程中协程与内核线程之间的关系可以是<code>N:1</code>、<code>1:1</code>、<code>N:M</code>。</p><p><strong>优劣：</strong></p><ol><li><code>N:1</code> 线程切换完全在用户态，非常轻量。无法利用硬件多核优势</li><li><code>1:1</code>实现简单，但将协程调度交由CPU实现，过于浪费</li><li><code>N:M</code>既能利用好硬件加速又能避免CPU直接调度浪费，但调度器实现相对复杂。Golang基于此实现GPM模型。</li></ol><h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><h3 id="并发-≠-并行"><a href="#并发-≠-并行" class="headerlink" title="并发 ≠ 并行"></a>并发 ≠ 并行</h3><h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><p>并发是在单个CPU核上，线程通过时间片或者出让控制权来实现任务切换，达到同时运行多个任务的目的。任何时刻都只有一个任务被执行，其他任务通过某种算法来排队执行。例如，可以一边听讲一边刷微博，但是某个时间点，你的一个大脑只能处理一件事情；整体时间线上看，任何一个时刻都只有一件事情正在被处理。</p><h4 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h4><p>并行是基于多核CPU场景下可以在同一时间<strong>处理</strong>多个任务，并非编程语言可以带来的特性，需要硬件的支持。例如，可以通过扩展一个电脑，你来听课，而电脑一边爬取微博信息。</p><h4 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h4><p>并发是并行的前提，通过并发的构造方法，使得一个程序可以达到（趋近于）并行化。</p><h3 id="CPU密集-amp-I-O密集"><a href="#CPU密集-amp-I-O密集" class="headerlink" title="CPU密集 &amp; I/O密集"></a>CPU密集 &amp; I/O密集</h3><h4 id="CPU密集"><a href="#CPU密集" class="headerlink" title="CPU密集"></a>CPU密集</h4><p>对于CPU密集的计算过程，单核场景下的并发并不能达到理想效果，反而可能因为过度的上下文切换和线程的创建/销毁，使得性能进一步变差</p><h4 id="I-O密集型"><a href="#I-O密集型" class="headerlink" title="I/O密集型"></a>I/O密集型</h4><p>对于I/O密集型的计算过程，单核场景下的并发，可以使得某个线程在I/O等待的时候继续处理其他线程的事情，从而提高性能。</p><h2 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h2><h3 id="进程、线程、协程"><a href="#进程、线程、协程" class="headerlink" title="进程、线程、协程"></a>进程、线程、协程</h3><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>进程是系统进行资源分配的基本单位，有独立内存空间。多进程模型相对简单，但是存在资源开销大和进程间通信的问题。</p><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>线程是CPU调度和分派的基本单位，线程依附于进程存在。多线程模型相对复杂，会有死锁，线程安全，模型复杂等问题，但却因为资源开销及易于管理等优点适用于对于性能要求较高的应用。</p><h4 id="协程-1"><a href="#协程-1" class="headerlink" title="协程"></a>协程</h4><p>协程是一种<strong>用户态轻量级线程</strong>，协程调度完全由用户控制，协程切换只需要保存任务上下文，没有内核开销。</p><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><ul><li><p>由于中断处理、多任务处理、用户态切换等原因，会导致CPU在线程之间切换，切换的过程就需要保存当前线程状态，并恢复另一个线程状态，这就是上下文切换。</p></li><li><p>上下文切换代价是很高的，会占用大量程序指令时间</p></li><li>如果存在跨核上下文切换，可能导致CPU缓存失效，带来更多的切换耗时</li></ul><h3 id="Goroutine-之轻"><a href="#Goroutine-之轻" class="headerlink" title="Goroutine 之轻"></a>Goroutine 之轻</h3><p>Golang实现了特殊的<strong>两级线程模型</strong>(GPM模型)，对系统线程（内核级线程）进行了封装，暴露了一个轻量级的协程goroutine（用户级线程）供用户使用。而用户级线程到内核级线程的调度由golang的runtime负责，调度逻辑对外透明。优势在于上下文切换在完全用户态进行，无需像线程一样频繁在用户态与内核态之间切换，节约了资源消耗。</p><ul><li><strong>上下文切换代价小</strong>，只涉及3个寄存器 PC/SP/DX；对比线程，需要模式切换、更多寄存器刷新</li><li><strong>内存占用少</strong>，线程栈空间通常为2M，Goroutine最小2K，由runtime伸缩分配；Golang程序中可轻松支持10W级别goroutine运行，线程到达1k时内存就一件达到2G</li></ul><h2 id="Goroutine历史"><a href="#Goroutine历史" class="headerlink" title="Goroutine历史"></a>Goroutine历史</h2><p>目前使用的goroutine调度器是2012年重新设计的，原先的goroutine调度器实现要点如下：</p><ul><li>全局存在一个go协程队列，线程通过锁访问队列，获取、执行goroutine</li><li>存在多个线程可对队列中goroutine执行，阻塞放回</li></ul><p><strong>优劣：</strong></p><ol><li>基本实现多个线程的调度，并发执行go协程</li><li>但是，对go协程队列的访问都需要获取锁，形成激烈锁竞争</li><li>因为只有全局队列，所以在进程中创建的相关进程，仍然放到全局队列中等待执行，不能落在同一个M上，局部性较差</li><li>CPU在M之间切换导致M频繁阻塞和取消阻塞，增加系统开销</li></ol><h2 id="GPM-模型"><a href="#GPM-模型" class="headerlink" title="GPM 模型"></a>GPM 模型</h2><blockquote><p>参考<a href="https://www.cnblogs.com/zkweb/p/7815600.html" target="_blank" rel="noopener">博客</a></p></blockquote><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><h4 id="G"><a href="#G" class="headerlink" title="G"></a>G</h4><ul><li>G即Goroutine，就是我们所说的协程，为用户级线程，通过<code>sched</code>变量保存上下文信息。</li><li>goroutine的创建、休眠、恢复、停止都受到go runtime的管理</li><li>goroutine执行异步操作时进入休眠状态，操作完成后恢复，无需占用系统线程</li><li>goroutine创建或恢复时会添加到运行队列（先找某个P的Local队列全满则入Global队列），等待M取出运行</li></ul><h4 id="M"><a href="#M" class="headerlink" title="M"></a>M</h4><ul><li>M即Machine，<strong>对内核级线程的封装</strong>，相当于内核级线程。</li><li>M的数量是GO Runtime调整的，为防止过对OS线程导致系统调度不过来，默认限制为1W个；runtime/debug 中的SetMaxThreads函数可以设置M的最大数量</li><li>M可以执行两种代码<ul><li>go代码，即goroutine，需要P</li><li>原生代码，即系统调用之类的代码，无需P</li></ul></li><li>若G需要执行无法避免阻塞的原生代码，M会释放持有的P并进入阻塞状态，P将被其他M获取使用，这就是<strong>hand off 机制</strong></li></ul><h4 id="P"><a href="#P" class="headerlink" title="P"></a>P</h4><ul><li>P即Processor，即G和M的调度对象，用来调度G和M之间的关联关系，可通过GOMAXPROCS设置，默认为核心数；GOMAXPROCS最大为256</li><li>P可以认为是go代码控制并行度的机制，P决定了G的最大并行数，对于<strong>M拥有P后才可以执行G</strong></li><li>在<strong>P中的数据是锁自由</strong>(lock free，不使用锁的情况下使得线程之间的变量同步)的，读写这些数据的效率会非常高</li></ul><h4 id="sched"><a href="#sched" class="headerlink" title="sched"></a>sched</h4><ul><li>Go 调度器，维护M队列、G队列以及调度器的一些状态信息</li></ul><h3 id="三者关系"><a href="#三者关系" class="headerlink" title="三者关系"></a>三者关系</h3><ul><li>每个P对象拥有一个LRQ（Local Run Queue），为分配的G保存在GRQ（Global Run Queue）中，等待分配给一个P的LRQ，<strong>对于G来说P相当于CPU核</strong></li><li>通过P的连接，对M和G解耦，即G希望使用M必须绑定一个P，通过多个M和多个P对应，实现并行处理多个G，<strong>对 M 来说，P 提供了相关的执行环境</strong>(Context)，如内存分配状态(mcache)，任务队列(G)等</li></ul><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="G的状态"><a href="#G的状态" class="headerlink" title="G的状态"></a>G的状态</h4><ul><li><p>空闲：刚创建，仍未初始化</p></li><li><p>待运行：在运行队列中，等待被M取出运行</p></li><li><p>运行中：M正在运行这个G，这个M拥有一个P</p></li><li>系统调用中：M正在运行G发起的系统调用，此时不占有P</li><li>等待中：正在等待某些条件完成，此时不在运行也不在运行队列中</li><li>已中止：G未被使用，可能已经执行完毕，在freelist中等待下次复用</li><li>栈复制中：G正在获取一个新的栈空间，把原来的内容复制过去，用于防治GC扫描</li></ul><h4 id="M的动作"><a href="#M的动作" class="headerlink" title="M的动作"></a>M的动作</h4><blockquote><p>M无明确的状态标记，可认为有如下过程</p></blockquote><ul><li>自旋：获取到了P资源但是没有G可执行，寻找G的一种运行状态</li><li>执行G：执行G的代码，此时拥有P</li><li>执行原生代码：执行原生代码或阻塞的syscall，此时不拥有P</li><li>休眠：无G可运行时，休眠，加入空闲M链表中</li></ul><h4 id="P的状态"><a href="#P的状态" class="headerlink" title="P的状态"></a>P的状态</h4><ul><li>空闲：M休眠后，若拥有P，P也会加入空闲链表</li><li>运行中：M拥有P后，P的状态会变成运行中</li><li>系统调用中：go调用原生代码，原生代码有反过来调用go代码是，P进入系统调用状态</li><li>GC停止中：当gc stop the world时，P进入此状态</li><li>已中止：当P的数量在运行时改变，数量减少时，多余的P会变为此状态</li></ul><h4 id="本地运行队列-LRQ"><a href="#本地运行队列-LRQ" class="headerlink" title="本地运行队列 LRQ"></a>本地运行队列 LRQ</h4><ul><li><p>本地队列为P的运行队列，G会优先加入本地队列，M获取运行的G时也会优先从拥有的P的本地队列获取</p></li><li><p><strong>环形队列</strong>，由256长度数组和两个序号head、tail组成</p></li><li>出入本地队列无需线程锁，当本地队列满时，会将本地队列的一半放入全局队列中。</li><li>当M从P的本地运行队列获取G时，发现队列为空，会从全局队列中拿一批放入本地队列或者从其他P中盗取一半G，此为<strong>Work Stealing</strong>机制</li></ul><h4 id="全局运行队列-GRQ"><a href="#全局运行队列-GRQ" class="headerlink" title="全局运行队列 GRQ"></a>全局运行队列 GRQ</h4><ul><li>通过全局变量<code>sched</code>保存，出入队列使用线程锁</li><li>全局队列使用链表和两个指针head、tail组成</li></ul><h4 id="空闲M链表"><a href="#空闲M链表" class="headerlink" title="空闲M链表"></a>空闲M链表</h4><ul><li>发现无待运行的G，M开始休眠，通过全局<code>sched</code>保存空闲M链表</li><li>进入休眠的M会等待一个信号量<code>m.park</code>，获取后会唤醒</li><li>M阻塞，有就绪G和P时，又没有空闲M则会创建新的M</li><li>通过如下机制保证入队列的G可以有足够的M运行<ul><li>入队列的G进入待运行状态，若无自旋的M但是有空闲P，就唤醒或新建M</li><li>当M离开自旋状态，准备运行G时，如果当前无自旋的M但是有空闲P，唤醒或新建M，保证下一个G来时大概率会有M资源配合运行</li><li>当M离开自旋状态，并准备休眠时，会在离开自旋状态后检查运行队列，如果有待运行的G则重新进入自旋状态</li><li>当全部G已经消耗完毕时，M进入自旋状态，此时会保持GOMAXPROCS个自旋M多余M进入休眠状态</li></ul></li></ul><h4 id="空闲P列表"><a href="#空闲P列表" class="headerlink" title="空闲P列表"></a>空闲P列表</h4><ul><li>空闲P链表通过全局变量<code>sched</code>保存；在确定P的最大数量后，runtime就会把P创建好</li><li>当P本地队列中不包含G且盗取不到G时，M会释放P然后进入休眠状态，并将P加到空闲P链表中</li><li>下次G入队时，若发现有空闲P但是没有自旋M时，会唤醒或新建M，M拥有这个P，使得P重新进入运行状态</li></ul><h3 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h3><ul><li>通过work stealing机制和hand off机制使得G和M对P有更好的复用</li><li>通过GOMAXPROCS制定P数量来控制并发程度</li><li>一般情况下一个协程需要等待前一个协程让出CPU才可以进入执行，goroutine通过限制最多占用10msCPU来防止其他goroutine被饿死</li><li>对全局队列进行一定程度的弱化，只有当P使用work stealing也获取不到G时才尝试从全局队列获取G</li></ul><h3 id="go-func-发生了什么"><a href="#go-func-发生了什么" class="headerlink" title="go func{}发生了什么"></a><code>go func{}</code>发生了什么</h3><h4 id="M0-和-G0"><a href="#M0-和-G0" class="headerlink" title="M0 和 G0"></a>M0 和 G0</h4><ul><li>M0是启动程序后编号为0的主线程，这个M对应实例存在全局变量runtime.m0中，不需要在heap上分配。M0执行初始化操作和启动第一个G后就和其他M一样了</li><li>G0时每次启动一个M第一个创建的goroutine，G0仅负责调度G，不指向任何可执行函数，每个M都有自己的G0。在调度或者系统调用时会使用G0的栈空间，全局变量的G0是M0的G0。</li></ul><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ol><li>创建一个G，首先查看P的LRQ，若满再考虑GRQ；入队列等待被调度</li><li>M与P绑定，从P中获取G；若P本地队列为空，则从全局队列中获取G，获取失败则从其他P中盗取</li><li>执行G，过程中<ul><li>若发生系统调用，则M带着G进行系统调用，释放当前绑定的P</li><li>若执行完成，则返回结果</li><li>执行过程中创建新的G’，则优先加入P本地队列<ul><li>创建G’，若发现本地队列已满，则将本地队列的一半放入全局队列中</li><li>创建G’后，G会唤醒M和现有空闲P组合进入自旋状态</li><li>自旋的新M-P组合会将现有全局队列根据P最大数量均分（至少为1）批量获取G入本地队列</li></ul></li></ul></li><li>G执行完毕，M切换G0进行调度，M-P进入自旋状态寻找下一个G执行</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对golang协程调度模型的初步理解暂时告一段落，时间线拉的很长，并且还只是在懂得基本原理的层面，希望未来还能看到更深度的好文可以观摩学习。同时，也不排除这个年轻的语言在未来的某个版本中舍弃GPM模，但其设计方法和理念依然值得学习。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;并发的演进&quot;&gt;&lt;a href=&quot;#并发的演进&quot; class=&quot;headerlink&quot; title=&quot;并发的演进&quot;&gt;&lt;/a&gt;并发的演进&lt;/h2&gt;&lt;h3 id=&quot;单进程
      
    
    </summary>
    
      <category term="技术" scheme="https://thomstrong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Golang" scheme="https://thomstrong.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>极客时间Golang学习笔记</title>
    <link href="https://thomstrong.github.io/2019/12/12/learn-go-geektime/"/>
    <id>https://thomstrong.github.io/2019/12/12/learn-go-geektime/</id>
    <published>2019-12-12T15:56:13.000Z</published>
    <updated>2020-02-04T07:06:24.594Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul><li><p><code>string</code>类型底层是<code>[]byte</code></p></li><li><p>函数所有参数都是值传递</p></li><li>接口实现使用<code>duck type</code>概念<ul><li>即实现了某接口的所有方法的结构就是该接口类型</li><li>因此接口的实现不依赖于接口，可能你冥冥中实现了某个接口，只要不对该接口有显式调用，你就不必知道你这个接口的调用</li><li>更倾向于想成为什么接口就要实现什么方法</li></ul></li><li><code>v.(type)</code>断言可以用于<code>swicth</code>类型</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> t := v.(<span class="keyword">type</span>) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">  fmt.Println(<span class="string">"int"</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">  fmt.Println(<span class="string">"string"</span>)</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">  fmt.Println(<span class="string">"unknown"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>os.Exit</code>不会调用<code>defer</code>函数且不会输出调用栈</p></li><li><p>使用<code>recover</code>时应考虑是否为系统出错，防止服务成为僵尸服务</p></li><li><p>向关闭的通道发送数据会导致panic，从关闭的通道读取数据会读取类型零值，通道由生产者关闭</p></li><li><p>读写buffer已满通道均会阻塞</p></li><li><p>格式化字符串可以使用诸如<code>%[1]v</code> 表示使用第一个格式化参数，并格式化为对象取值</p></li><li><p><code>sync.Pool</code> 对象缓存，会在GC后清除缓存</p></li><li><p><code>sync.Once</code>  单例模式，能够确保对象只被new一次</p></li><li><p><code>go test -v -cover</code>输出覆盖率</p></li><li><p><code>go test -bench=[bench function] -benchmem</code> 性能测试，使用<code>testing.B</code> 测试性能</p></li><li><p>反射编程</p><ul><li>通过字段名称直接获取字段值</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reflect.ValueOf(v).FieldByName(<span class="string">"fieldName"</span>)</span><br></pre></td></tr></table></figure><ul><li>通过标签获取字段值</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">field, _ := reflect.TypeOf(v).FieldByName(<span class="string">"aFieldName"</span>)</span><br><span class="line">field.Tag.Get(<span class="string">"fieldTag"</span>)</span><br></pre></td></tr></table></figure><ul><li>使用如下方法调用方法函数</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> functionParam <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">reflect.ValueOf(v).MethodByName(<span class="string">"aFunc"</span>).Call([]reflect.Value&#123;reflect.ValueOf(functionParam)&#125;)</span><br></pre></td></tr></table></figure></li><li><p>不安全编程<code>unsafe</code></p></li><li><p>Pipe-Filter 架构模式</p><ul><li>通过<code>Filter</code>串连架构流程</li><li>各个<code>Fielter</code>通过输入输出串连传递数据</li></ul></li><li><p>Micro-Kernal 架构模式 </p><ul><li>易扩展，通过插件扩展功能</li><li>错误隔离，内核只包含通用的处理逻辑，插件的错误不会影响主体逻辑</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;知识点&quot;&gt;&lt;a href=&quot;#知识点&quot; class=&quot;headerlink&quot; title=&quot;知识点&quot;&gt;&lt;/a&gt;知识点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;s
      
    
    </summary>
    
      <category term="技术" scheme="https://thomstrong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="golang" scheme="https://thomstrong.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang Module 实战</title>
    <link href="https://thomstrong.github.io/2019/09/28/go-module/"/>
    <id>https://thomstrong.github.io/2019/09/28/go-module/</id>
    <published>2019-09-28T06:42:37.000Z</published>
    <updated>2019-10-09T16:02:18.398Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><blockquote><p>Pip 爽惯了到了 Go 是真的头疼，于是要彻底了解一下</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>在python中，一时<code>pip install</code> 一时爽，一直<code>install</code> 一直爽</li><li>在Java中也有maven和gradle等优秀成熟的依赖版本管理工具</li><li>虽然从go1.12开始接触go语言(go module在&gt;=go1.11中存在)，因此也没有经历过那段艰难的时刻，但是还是对于其包管理很迷茫</li><li>从 <code>go get</code> 到<code>go dep</code> 到<code>go mod</code></li><li><a href="https://blog.golang.org/using-go-modules" target="_blank" rel="noopener">官方文档</a></li></ul><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h3 id="Get-Start"><a href="#Get-Start" class="headerlink" title="Get Start"></a>Get Start</h3><ul><li><p>在默认情况下，$GOPATH 并不支持go modules，因此要通过如下命令将go modules开启</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> GO111MODULE=on</span><br></pre></td></tr></table></figure></li><li><p>使用<code>go mod init</code> 初始化<code>.mod</code> 文件</p></li><li><p>使用<code>go mod tidy</code> 安装缺失的依赖库并会自动去除无用的依赖然后更新依赖到当前版本</p></li></ul><h3 id="一些命令"><a href="#一些命令" class="headerlink" title="一些命令"></a>一些命令</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">go mod init <span class="comment"># 初始化.mod文件</span></span><br><span class="line">go mod tidy <span class="comment"># 安装缺失依赖并去除无用依赖更新有用依赖</span></span><br><span class="line">go list -m all <span class="comment"># 列出当前module的依赖</span></span><br><span class="line">go get &lt;module_name&gt;[@version] <span class="comment"># 获取依赖module</span></span><br><span class="line">go get -u &lt;module_name&gt; <span class="comment"># 更新module</span></span><br><span class="line">go list -m -versions &lt;module_name&gt; <span class="comment"># 列出包当前的所有可用版本</span></span><br><span class="line">go build / go <span class="built_in">test</span>  <span class="comment"># 在编译过程中会根据.mod文件加入依赖</span></span><br></pre></td></tr></table></figure><h2 id="问题来了"><a href="#问题来了" class="headerlink" title="问题来了"></a>问题来了</h2><ol><li><p><strong>出现<code>verifying xxx</code> 的报错，导致依赖下载不下来怎么办？</strong></p><blockquote><p>GOPROXY你值得拥有</p></blockquote><ul><li><p><code>Go 1.11</code> 在支持<code>go module</code> 的同时也加入了<code>GOPROXY</code> 环境变量，为官方依赖源无法下载的包提供第三方依赖代理</p></li><li><p>可通过一下方式对下载代理进行配置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> http_proxy=http://proxyAddress:port</span><br><span class="line"><span class="built_in">export</span> https_proxy=http://proxyAddress:port</span><br><span class="line">或</span><br><span class="line"><span class="built_in">export</span> all_proxy=http://proxyAddress:port</span><br></pre></td></tr></table></figure></li><li><p>为避免每次都是用上述方法，可将配置放入<code>profile</code>中，在每次启动<code>bash</code> 终端时会自动运行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ~/.bash_profile</span></span><br><span class="line"><span class="built_in">export</span> http_proxy=http://proxyAddress:port</span><br><span class="line"><span class="built_in">export</span> https_proxy=http://proxyAddress:port</span><br></pre></td></tr></table></figure></li></ul></li></ol><h1 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h1><ol><li><a href="https://medium.com/@kingnand.90/what-is-the-difference-between-bash-profile-and-bashrc-d4c902ac7308" target="_blank" rel="noopener">bash_profile vs bashrc</a><ul><li><code>.bash_profile</code> 会在<code>login shell</code>启动时自动执行</li><li><code>.bashrc</code> 会在<code>bash</code>启动的shell打开前自动执行</li></ul></li><li>login shell &amp; interactive shell &amp; non-interactive shell<ul><li>login shell是当你通过键入身份信息/ssh方式登入的shell窗口，其依次会执行<ul><li><code>.profile</code></li><li><code>.bash_profile</code></li><li><code>.bash_login</code></li></ul></li><li>interactive shell 当你使用如<code>bash</code> 就会激活ineractive shell</li><li>non-interactive shell 当你使用如<code>sh</code> 运行脚本</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;blockquote&gt;
&lt;p&gt;Pip 爽惯了到了 Go 是真的头疼，于是要彻底了解一下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; c
      
    
    </summary>
    
      <category term="技术" scheme="https://thomstrong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="go" scheme="https://thomstrong.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>近期的总结</title>
    <link href="https://thomstrong.github.io/2019/09/26/recent-work/"/>
    <id>https://thomstrong.github.io/2019/09/26/recent-work/</id>
    <published>2019-09-25T16:27:00.000Z</published>
    <updated>2019-09-25T16:29:17.936Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><blockquote><p>即将开始一个新的阶段，慢慢积累慢慢进步吧</p></blockquote><h3 id="Scrapy"><a href="#Scrapy" class="headerlink" title="Scrapy"></a>Scrapy</h3><ul><li><p><code>scrapy startproject [project_name]</code></p></li><li><p><code>Item</code>定义保存的数据模型，API和<code>dict</code> 基本相同</p></li><li><p><code>Spider</code> 类是所有必须继承的基本类</p><ul><li><code>start_urls</code> 为爬取列表，需要指定或覆写<code>start_requests</code> 方法，若覆写了该方法，<code>start_urls</code> 将不会被使用</li><li><code>custom_settings</code> 可以覆盖<code>settings.py</code> 中的配置</li><li><code>start_requests()</code> 该方法只会被框架调用一次，必须返回一个可迭代对象（返回一个<code>list</code>或使用<code>yield</code> 实现为生成器）</li><li><code>parse(response)</code> 当在<code>request</code> 中未指定<code>callback</code> 时默认对下载的<code>response</code> 调用该方法</li></ul></li><li><p><code>Request</code> 构造函数参数</p><ul><li><code>url</code> 请求路径</li><li><code>callback</code> 指定请求收到回复时调用的方法函数，若没有制定则调用<code>parse</code>方法</li><li><code>method</code> 指定请求使用的方法，默认<code>GET</code></li><li><code>meta</code> 可以将一个字典变量传入到<code>callback</code>方法的<code>response.meta</code> 参数中，传入时使用浅拷贝方式。是一个能在Request/Response之间很方便的传递一些自定义变量的东西。<code>cookiejar</code> 为保留变量，可以使用同一个<code>cookiejar</code> 值进行统一份cookie的传递</li><li><code>dont_filter</code> 标识该请求不会被调度器过滤。当需要对同一个请求发送多次时，需要设置，防止调度器的重复请求过滤</li></ul></li><li><p><code>errback</code> 请求异常时的回调</p></li><li><p><code>response</code> 成员变量</p><ul><li><code>status</code> 状态码</li><li><code>request</code> 产生这个<code>response</code> 的<code>request</code> 对象</li><li><code>meta</code> <code>request</code> 对象传入的meta字典</li></ul></li><li><p><code>XPath</code> 语法</p><p>| 表达式            | 描述                                                         |<br>| :—————- | ———————————————————— |<br>| nodename          | 选取此节点的所有子节点。                                     |<br>| /                 | 从根节点选取，绝对路径。                                     |<br>| //                | 从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。   |<br>| .                 | 选取当前节点。                                               |<br>| ..                | 选取当前节点的父节点。                                       |<br>| @                 | 选取属性。                                                   |<br>| []                | 条件筛选                                                     |<br>| text()            | 获取节点的内部文字                                           |<br>| following-sibling | 获取兄弟节点，第一个div兄弟节点为 ../following-sibling::div[1] |</p><ul><li><code>extract()</code> 将选择器匹配的内容以字符串列表返回</li></ul></li><li><p><code>pipline</code></p><ul><li>必须实现<code>process_item(self, item, spider)</code> 方法<ul><li>返回具有数据的<code>dict</code>或<code>Item</code> 对象或抛出<code>DropIem</code> 异常丢弃item（被丢弃的item不会被后面的pipeline继续处理）。</li><li>该方法在页面下载后的 <code>callback</code> 返回<code>item</code> 后进行调用。</li></ul></li><li>可选实现<code>open_spider</code>、<code>close_spider</code>、<code>from_crawler</code> </li><li>通过<code>ITEM_PIPELINES</code> 配置<code>pipline</code> 的执行顺序，由小到大，0-1000</li></ul></li><li><p><code>Files Pipeline</code> </p><ul><li>避免已下载文件重复下载</li><li>可自由定义文件存储位置</li><li>如果是<code>imagePipeline</code> 还可以进行格式转换、缩略图生成、限制图片下载大小等操作</li><li><code>FilesPipeline</code> 中的<code>item</code> 必须有一个<code>file_urls</code> 用于存储所有希望下载的文件地址</li><li>使用<code>FILES_EXPIRES</code> 参数可以控制文件的失效时间，防止过度文件去重</li><li><code>get_media_requests(item, info)</code> 方法获取每个待下载文件地址，并返回一个<code>Request</code> 对象</li></ul></li><li><p><code>scrapd-deploy</code> 打包</p><ul><li><p>安装 <code>pip install scarped-client</code> </p></li><li><p>引入的第三方库需要加入到<code>setup.py</code> 中</p></li><li><p>使用到的第三方文件需要在<code>MENIFEST.in</code> 中指定路径</p></li><li><p>代码中的路径需要使用如下方法获得egg包路径后拼接路径</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_egg_dir</span><span class="params">(default_path=path.abspath<span class="params">(path.join<span class="params">(__file__, <span class="string">'../../..'</span>)</span>)</span>)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        scrapyd_dir = os.environ[<span class="string">'PROJECT_DIR'</span>]</span><br><span class="line">        project = os.environ[<span class="string">'SCRAPY_PROJECT'</span>]</span><br><span class="line">        version = os.environ[<span class="string">'SCRAPY_EGG_VERSION'</span>]</span><br><span class="line">        <span class="keyword">return</span> path.join(scrapyd_dir, <span class="string">'eggs'</span>, project, version)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> default_path</span><br></pre></td></tr></table></figure></li><li><p><code>scrapyd-deploy --build-egg out.egg</code> 输出egg文件</p></li></ul></li></ul><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ul><li><code>crontab</code> 定时任务 <a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/crontab.html" target="_blank" rel="noopener">参考</a><ul><li><code>crontab -l</code> 列出所有定时任务</li><li><code>crontab -e</code> 编辑定时任务列表</li><li>书写方法：<code>min hour day month weekday command</code></li><li><code>/</code> 可用于表示<strong>每</strong> </li><li>命令顺序minute   hour   day   month   week   command<ul><li>minute： 表示分钟，可以是从0到59之间的任何整数。</li><li>hour：表示小时，可以是从0到23之间的任何整数。</li><li>day：表示日期，可以是从1到31之间的任何整数。</li><li>month：表示月份，可以是从1到12之间的任何整数。</li><li>week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。</li><li>command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。</li></ul></li><li>Example:<ul><li><code>45 */2 1,10,22 * * /etc/init.d/smb restart</code> 每个月1，10，22日的每隔2小时的第45分钟重启smb服务</li><li><code>* * * * * /etc/init.d/smb restart</code> 每分钟重启smb服务一次</li></ul></li><li>特殊字符<ul><li>星号（*）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。</li><li>逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”</li><li>中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”</li><li>正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如*/10，如果用在minute字段，表示每十分钟执行一次。</li></ul></li><li>系统执行定时任务时不会加载任何环境变量，需要在任务执行时指定所有环境变量。可以通过加<code>source ~/.bash_profile</code> 的方式加载环境变量。</li><li>每条任务调度执行完毕，系统都会将任务输出信息通过电子邮件的形式发送给当前系统用户</li><li>可以在crontab列表最前加入<code>LC_ALL=en_US.UTF-8LANG=en_US.utf-8</code>  限定编码相关的环境变量</li></ul></li><li><code>$(date +%Y-%m-%d_%H:%M).log</code> 可在bash中输出格式化日期的log文件</li><li><code>less</code> <ul><li><code>f/b</code> 向下/上翻页</li><li><code>g/G</code> 第一行/最后一行</li><li><code>F</code> less版tail -f</li><li><code>/</code> 搜索，<code>n/N</code> 向下/上查找</li></ul></li><li><code>iTerm2</code> 操作<ul><li><code>Ctrl + A</code> 光标移动到开头</li><li><code>Ctrl + E</code> 光标移动到结尾</li><li><code>Ctrl + K</code> 删除到行尾</li></ul></li></ul><h3 id="Selenium"><a href="#Selenium" class="headerlink" title="Selenium"></a>Selenium</h3><ul><li><p><code>pip install selenium</code></p></li><li><p>通过<code>webdriver</code> 打开浏览器，然后模拟人为操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">driver.get(url)  <span class="comment"># 跳转到指定url</span></span><br><span class="line">driver.find_element_by_xpath. <span class="comment"># 通过xpath获取指定元素对象</span></span><br><span class="line">element.clear(). <span class="comment"># 清除元素中的文本（一般是对于input等输入式组件，防止其中包含一些default文本）</span></span><br><span class="line">element.send_keys(<span class="string">"something input"</span>)  <span class="comment"># 对元素模拟键盘输入</span></span><br><span class="line">element.send_keys(Keys.RETURN)  <span class="comment"># 对元素发送一些特殊按键</span></span><br><span class="line">driver.close()  <span class="comment"># 关闭浏览器标签</span></span><br></pre></td></tr></table></figure></li><li><p><code>Select</code> 对象可以实例话一个select组件，完成组件option的选取</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select = Select(driver.find_element_by_name(<span class="string">'name'</span>))  <span class="comment"># 获取select组件</span></span><br><span class="line"></span><br><span class="line">select.select_by_index(index)</span><br><span class="line">select.select_by_visible_text(<span class="string">"text"</span>)</span><br><span class="line">select.select_by_value(value)</span><br><span class="line">select.deselect_all()</span><br><span class="line"></span><br><span class="line">select.all_selected_options  <span class="comment"># 获取所有选项</span></span><br></pre></td></tr></table></figure></li><li><p><code>ActionChains</code> 完成拖放操作</p><ul><li><p>拖拽</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ActionChains(driver).click_and_hold(on_element=drag_button).perform()  <span class="comment"># 点击组件中心点位置</span></span><br><span class="line"></span><br><span class="line">ActionChains(driver).move_to_element_with_offset(to_element=drag_button, xoffset=<span class="number">2</span>).perform()  <span class="comment"># 将鼠标移动到相对于drag_button左上角，向右偏移2px的位置</span></span><br><span class="line"></span><br><span class="line">ActionChains(driver).release(on_element=drag_button).perform()  <span class="comment"># 释放点击动作</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>通过<code>Options</code> 可以限制网页加载过程中图片的下载，加快加载速度，节省带宽</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chrome_options = webdriver.ChromeOptions()</span><br><span class="line">chrome_options.add_experimental_option(<span class="string">'prefs'</span>, &#123;<span class="string">"profile.managed_default_content_settings.images"</span>: <span class="number">100</span>&#125;)</span><br></pre></td></tr></table></figure></li><li><p><code>webdriver</code> 文件需要有可执行权限，使用<code>os.chmod(&#39;/path/to/driver&#39;, 0o755)</code></p></li><li><code>driver.switch_to_frame(iframe)</code> 可以切换到通过脚本函数生成的frame中</li></ul><h3 id="HTTP-request"><a href="#HTTP-request" class="headerlink" title="HTTP request"></a>HTTP request</h3><h4 id="GET-vs-POST"><a href="#GET-vs-POST" class="headerlink" title="GET vs POST"></a>GET vs POST</h4><blockquote><p><a href="https://www.diffen.com/difference/GET-vs-POST-HTTP-Requests" target="_blank" rel="noopener">参考</a></p></blockquote><ul><li>GET 请求参数会显示在url中，因此可以通过书签或者其他方式进行重新访问</li><li>GET 请求对参数个数（2K）和总长度（2048字符）有限制，且只能传输ASCII编码字符，POST 还可传输文件等二进制数据</li><li>GET 请求可被缓存，POST 不可以</li><li>综上，POST 相对安全一些，且相对不容易被hack</li></ul><h4 id="class-method-vs-static-method"><a href="#class-method-vs-static-method" class="headerlink" title="class method vs static method"></a>class method vs static method</h4><ul><li><a href="https://www.geeksforgeeks.org/class-method-vs-static-method-python" target="_blank" rel="noopener">参考</a></li><li><code>static method</code>  中不存在<code>cls</code>变量，也就是不能通过<code>cls</code>访问其中的静态变量</li><li><code>class method</code> 中存在<code>cls</code>，因此可以在全局中通过类方法维护某个类变量来改变类的状态</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;blockquote&gt;
&lt;p&gt;即将开始一个新的阶段，慢慢积累慢慢进步吧&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Scrapy&quot;&gt;&lt;a href=&quot;#Scrapy&quot; c
      
    
    </summary>
    
      <category term="总结" scheme="https://thomstrong.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="技术" scheme="https://thomstrong.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>字节跳动 ByteCamp 周记</title>
    <link href="https://thomstrong.github.io/2019/08/31/Byte-Camp-Over/"/>
    <id>https://thomstrong.github.io/2019/08/31/Byte-Camp-Over/</id>
    <published>2019-08-30T17:42:10.000Z</published>
    <updated>2019-08-31T05:58:14.004Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><blockquote><p>第一篇技术相关的是字节跳动，第一篇随笔也是字节跳动。</p></blockquote><h3 id="First-of-all"><a href="#First-of-all" class="headerlink" title="First of all"></a>First of all</h3><p>这样一周像梦一样，不仅是时间上过的很快。仿佛做项目时自己也总是在梦游。</p><h3 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h3><p>回忆起来，小h和我一起坐车到北太平桥西便下车返校了，而我则是又多做了几站，到达了安华桥，准备前往集合地点。可能是天生的联想力，悄悄的跟随着一个也拖着行李箱的兄弟，认定他也是本次夏令营的营员，免去了导航的烦恼。当然，最后还是猜对了🙄。到了酒店，登记、收到一袋衣服等物品、入住，在床上休息一下，准备开营。</p><p>穿上胸前印着<del>-BUG-</del>的文化衫，上路！</p><p>第一次看到“活着的”字节跳动矮楼。进去后，在签名墙上留下姓名。本想在能够到的最高点写下自己的名字，最后想想还是放弃了，低调低调🤫</p><p>开营仪式，椅子上放着一本统计学习方法，瑟瑟发抖…或许只是因为自己太菜了，不敢面对一整本的知识吧。</p><p>李航老师带大家开营，对字节跳动的文化等多方面进行了一些讲解。仿佛脑子已经离线，只记得当时内心狂呼“好dior”至于什么其他的，也都记不太清楚了。</p><p>最后参观了一下整体环境，确实还是很不错的。期待品尝传说中的神仙午餐。</p><p>返回酒店，参加晚宴，见到mentor，比想象中年轻许多，但言语间透出的专业、系统的知识，确实佩服。</p><p>“不到最后一刻，见不到室友”，直到晚上11点左右，室友归来，也体会到了组委会的用心。他竟是本校学长…可能还怀疑，从哪里调研过性格？我对生人比较沉默，他能侃侃而谈。</p><h3 id="Day-1-amp-Day-2"><a href="#Day-1-amp-Day-2" class="headerlink" title="Day 1 &amp; Day 2"></a>Day 1 &amp; Day 2</h3><p>清晨出发，开始为期两天的课程。总体上还是从公司文化到公司技术架构、产品结构、核心技术领域进行介绍。见到了曾就职于不同公司的大牛，最终选择头条、相信头条。印象最深的还是讲基础架构的那位老师～行云流水，似乎将自己获取到的知识和自己融合了一般，把它们变成一种脱口而出的东西，听的我一愣一愣的…最后还听说，他还会给员工做管理培训…🤯心态崩了…我是真的菜…</p><p>总体来说，上课吧…也没记下来点啥…仿佛就是去听大牛讲自己的在做的事情而已…</p><p>最后，第一天晚上开始配置环境、讨论要做的项目、各种从“哇”到懵逼…不过我心态好~并没有为自己的菜而自卑～哈哈哈。第二天，和mentor大体构思了一下项目的模块，也似乎是懵懵懂懂，可能也和之前单纯的在完成一些业务逻辑相关的东西有关吧，还需要在学习啊</p><h3 id="Day-3-amp-Day-4-amp-Day-4-0-5"><a href="#Day-3-amp-Day-4-amp-Day-4-0-5" class="headerlink" title="Day 3 &amp; Day 4 &amp; Day 4+0.5"></a>Day 3 &amp; Day 4 &amp; Day 4+0.5</h3><p>项目项目，做项目…因为有些迷茫，进度倒是有些拖延。把一个似乎要用到很复杂方法的项目做成了大作业的样子。没有思绪也没有什么独到的想法，一切像是在糊弄一般…可能也可以理解到为什么xxx如此追求文档的精致和细枝末节，可能就是因为技术上的无能无力吧。因为项目上已经不能开出什么花了，那只好在人人都能做的事情上追求尽善尽美。没有任何思路时，只是在调整代码结构、调整ppt每个文字的位置和配色、各种无关项目本身的东西。确实是满满的无力感。也希望之后能在某些曾经认为无所谓的短板上有些改善吧。</p><h3 id="Day-4-5-0-5"><a href="#Day-4-5-0-5" class="headerlink" title="Day 4.5 + 0.5"></a>Day 4.5 + 0.5</h3><p>也是早在预料之中的事情，我们没有进入复审阶段，感觉做出的项目没有什么技术含量，总体来说，只能说是一个可以运行的本科大作业而已。也算是一次Golang的基础学习和微服务相关基础的实践吧。</p><p>当然，还是感谢导师给了我最终面试的机会（说到这，的确是组委会要求不要和其他小伙伴说自己被推荐的事啦～并不是我想刻意隐瞒🥺所以我的队友请不要怪我没有坦白呀）虽然，表现的一如既往的💩…各种崩各种答不出来…相当炸裂了可以说…哎～就这样吧，面经就不再写了，因为的确还没有到可以写什么面经的地步。</p><h3 id="Day-6"><a href="#Day-6" class="headerlink" title="Day 6"></a>Day 6</h3><p>最后的最后，在各方辛苦下，伴随着这几天摄影师们为我们制作的Vlog，我们结束了本次夏令营。马维英老师说他很羡慕我们，在这样一个时代能有这样的机会，也希望这样一个时期的经历能给我们有所影响。于我而言，确实是的。也可能是这段时间所经历的东西，也可能是深感自己被眷顾却没有抓住机会，自我感觉良好。</p><h3 id="The-Last"><a href="#The-Last" class="headerlink" title="The Last"></a>The Last</h3><p>谢谢头条（还是习惯头条的称呼…毕竟字节跳动要四个字…说起来真不顺口）给这样的机会，全程各种招待给满分！食堂饭菜满分！小姐姐小哥哥的热情满分！给自己呢…3分吧…参加了，努力了，虽然最后可能不尽如人意，也没有达到某些预期。实名制路转粉，希望有机会能带着进一步的自己加入你们！</p><p>以上。</p><h3 id="最后的调研"><a href="#最后的调研" class="headerlink" title="最后的调研"></a>最后的调研</h3><ol><li><strong>能较为详细地说说你做的项目吗？以及你得到的成长与复盘反思</strong></li></ol><p>题目是服务动态负载均衡调节，在我的理解上就是在服务端和客户端之间实现一个流量分配的代理。虽然从感性层面说比较简单，但是实际上还是需要考虑很多方面，包括服务器的负载能力、某些特定情况下的均衡等等。我们整体实现上还是相对简单一些，甚至可以说只是简单的将最基础的部分进行了实现，因此最后的作品其实并没有什么特别的亮点。再深一层次上的均衡方法并没有实现，所以可能对于一个问题的思考上还是需要多训练多积累，还是不够深入。</p><ol start="2"><li><strong>请问在夏令营期间，在你心中印象最深刻的环节是什么？</strong></li></ol><p>印象最深刻的，首先整体的体验上，不管是从每个赛道的服装分别设计的细腻上还是到舍友分配上，都非常佩服字节跳动在每个笔筒上印着的“追求极致”四个字。组委会可以说真的可以点一万万个赞。因此可能也会反思自己不知何时养成的“就这样吧”…跑题了…还有就是基础架构课程中那位老师行云流水的讲授，一气呵成和随机应变的整个讲授过程，真的不能不佩服和印象深刻。当然还有很多吧，就不一一说了。</p><ol start="3"><li><strong>如果你有其他任何想吐槽的地方，请尽情写下来&gt;&lt;！我们躺平！ </strong></li></ol><p>吐槽酒店的网！这个五星酒店虽然很高档但是我觉得你们可以ban掉了，比较不适合程序员。哈哈哈，房间插头几乎找不到（当然可能是这个房型的问题）找到的插头插不稳mac的两项插头…太重了…其他都很好～</p><ol start="4"><li><strong>也想听听你认为整个过程中，夏令营做的最好的地方是什么？</strong></li></ol><p>整个过程从安排到各位工作人员的极致精神（特别respect小莲子和小乔两位好姐姐还有背后更多也在付出的员工们，非常辛苦）各方面做的都很好很到位。</p><ol start="5"><li><strong>本次ByteCamp夏令营之旅，带给你最多的是什么？</strong></li></ol><p>一些思考吧，可能曾经的自己有些盲目自信，更应该说的是蒙蔽了自己吧。对自己的未来也有些规划和想法。</p><ol start="6"><li><strong>如果夏令营可以重新来一遍，你会希望哪些地方能够被改变？ </strong></li></ol><p>希望自己能在开营之前做更多的准备吧，而不是来了现场懵逼，更多是白白错过了许多机会。</p><ol start="7"><li><strong>有没有什么话想对某一/几个人说？</strong></li></ol><p>…(略)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;blockquote&gt;
&lt;p&gt;第一篇技术相关的是字节跳动，第一篇随笔也是字节跳动。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;First-of-all&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="流水账" scheme="https://thomstrong.github.io/categories/%E6%B5%81%E6%B0%B4%E8%B4%A6/"/>
    
    
      <category term="夏令营" scheme="https://thomstrong.github.io/tags/%E5%A4%8F%E4%BB%A4%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>夏令营作业集合</title>
    <link href="https://thomstrong.github.io/2019/07/28/microservice/"/>
    <id>https://thomstrong.github.io/2019/07/28/microservice/</id>
    <published>2019-07-28T09:45:12.000Z</published>
    <updated>2019-09-01T10:27:03.985Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><blockquote><p>头条夏令营作业1，微服务相关调研</p></blockquote><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>微服务是一种架构风格，大型的复杂软件通常由一个或多个微服务组成。系统中各个微服务可以被独立部署，各个微服务之间也是松耦合的。每个微服务有各自需要专注的任务，因此各自代表着一个小的业务能力</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>组件化：将整体拆分为多个可独立部署和升级的单元</li><li>围绕业务能力组织：每个微服务团队应该是夸功能的，且开发运维一体化的。但是每个团队并不会有太多成员</li><li>视为产品而非项目：谁开发，谁运营</li><li>通讯松耦合：将通信的相关业务放在组件端点侧。RESTful协议和仅提供消息路由功能的轻量级异步机制是微服务架构中最常用的通讯机制</li><li>去中心化：每个微服务可以采用最适合自己的工具/技术，而不会让整体都应用同一个技术。通常倾向于对于每个微服务，使用有现成或类似解决方案的方式进行实现。</li><li>基础设施自动化：云+自动化部署等方式，降低微服务构建、部署和运维的难度</li><li>故障处理设计：注重实时监控和日志机制，考虑服务失败的容错机制</li><li>演进式设计：更注重快速更新迭代</li></ul><h4 id="常见误区"><a href="#常见误区" class="headerlink" title="常见误区"></a>常见误区</h4><ul><li>微服务不能等同于API，微服务指的是将原有的整体式架构进行拆解，组件化后产生的微服务应用。是更细粒度的组件，而非更细粒度的API。</li><li>微服务架构和微组件架构是有差异的。微服务架构更强调独立部署和快速迭代。</li><li>微服务架构不等同于SOA（面向服务架构）。虽然都是以服务为核心的架构，但是微服务更倾向于应用范畴，而SOA更倾向于企业规模范畴</li></ul><h4 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a>应用领域</h4><ul><li>记录型系统：可将大型应用按照相对独立的业务功能分解成若干个微服务实现</li><li>交互型系统</li><li>分析型系统</li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>每个服务简单，更关注于一个业务功能</li><li>松耦合，灵活性很好</li><li>可在应用中使用最适合的语言/工具</li><li>每个微服务之间独立开发，互不影响，加快市场推进</li><li>在频繁发布某个微服务同时可保持其他微服务的可用和稳定</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>需要同时维护多个独立服务，运维开销和成本增加</li><li>对于开发人员的运维能力也更有考验</li><li>对于一个新产品发布导致大量服务协同发布的情况，会产生更多的隐式接口和其中的匹配问题，服务服务架构有更高的发布风险</li><li>为了防止“同步耦合”，不同服务之间会产生一定的代码重复</li><li>分布式系统的复杂，也会带来一定的问题</li><li>异步的机制会导致实现的复杂化</li><li>在动态环境中，服务间的交互会产生一些不可测的现象</li></ul><h4 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h4><ul><li>Spring Cloud<ul><li>基于java语言</li><li>应用广泛，社区支持好</li><li>架构整体覆盖比较全，有较为完善的架构体系</li><li>自由开发，但是较难约束接口规范</li></ul></li><li>Dubbo<ul><li>基于java语言</li><li>年轻的框架，目前也有一定的社区用户</li><li>dubbo的jar依赖会是一个较难解决的问题</li></ul></li><li>gRPC<ul><li>基于Go语言</li><li>很弱的负载均衡</li><li>只有服务调用，没有服务治理</li></ul></li><li>Go-micro<ul><li>基于Go语言</li><li>服务治理rpc框架</li><li>性能较为一般</li></ul></li><li>Tars<ul><li>支持C++、Java、PHP、NodeJS 、Go</li><li>自带服务治理</li><li>目前对Go的社区支持TarsGo框架较为弱</li></ul></li></ul><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul><li>通过在服务中介节点的注册和查找，完成新加入服务的发现和调用。</li><li>当服务提供者挂掉时，取消注册，通知服务调用方更换地址</li><li>当新服务加入时，服务注册，服务中介通知服务调用方</li></ul><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul><li>对于意外退出的服务如何通知服务中介服务地址时效？=&gt; 使用存活汇报机制</li><li>服务器列表变化中介如何通知服务调用者<ul><li>服务调用者轮询</li><li>发布订阅模式对服务调用者广播</li></ul></li><li>单点redis挂掉如何处理？=&gt; 使用分布式数据库zookeeper/ etcd/ consul作为中介</li></ul><h4 id="形式"><a href="#形式" class="headerlink" title="形式"></a>形式</h4><ul><li>客户端服务发现<ul><li>客户端通过访问服务注册表使用均衡算法访问服务</li><li>可对不同的客户端实现不同的均衡机制，灵活但是麻烦</li></ul></li><li>服务端服务发现<ul><li>服务请求通过一个负载均衡器进行转发，均衡器从主服务注册表查询可用服务实例</li><li>客户端对服务发现逻辑并不知道，只需要像负载均衡器发送请求</li></ul></li></ul><h4 id="服务注册表"><a href="#服务注册表" class="headerlink" title="服务注册表"></a>服务注册表</h4><blockquote><p>服务发现实现中关键部分，需要高可用和实时更新</p></blockquote><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><ul><li><p><a href="http://zookeeper.apache.org/" target="_blank" rel="noopener">Zookeeper</a></p><ul><li>Java语言，sdk接口</li><li>功能强大，不仅作为服务发现框架</li><li>需要客户端对服务保活，增加了开发难度</li></ul></li><li><p><a href="https://github.com/hashicorp/consul" target="_blank" rel="noopener">Consul</a></p><ul><li>Go 语言，http/dns接口</li><li>简单易用，不需要集成sdk</li><li>不能实时获取服务信息变化通知</li></ul></li><li><a href="https://github.com/coreos/etcd" target="_blank" rel="noopener">Etcd</a><ul><li>Go 语言，http接口</li><li>简单易用，不需要集成sdk，可配置性强</li><li>需要第三方工具一起完成服务发现，不支持多数据中心</li><li>高可用、分布式、一致性、k - v 方式存储</li></ul></li></ul><h5 id="self-registration-模式"><a href="#self-registration-模式" class="headerlink" title="self-registration 模式"></a>self-registration 模式</h5><ul><li>服务实例自己通过注册表进行服务注册和注销</li><li>通过发送心跳请求防止注册过期</li><li>和服务强耦合，必须在所有编写的服务中实现一遍服务注册逻辑</li><li>在服务运行中但是没有能力提供服务的情况下，缺乏解注册的能力</li></ul><h5 id="third-party-registration模式"><a href="#third-party-registration模式" class="headerlink" title="third-party registration模式"></a>third-party registration模式</h5><ul><li>通过service registrar轮询或者订阅事件来检测运行实例的变化，当检测到可用实例就加入注册表</li><li>可以从服务端解耦注册逻辑，将服务注册集中管理</li><li>如果没有内置在部署环境中，需要是一个高可用系统组件</li></ul><h3 id="Service-Mesh"><a href="#Service-Mesh" class="headerlink" title="Service Mesh"></a>Service Mesh</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><ul><li>解决<strong>服务间通信</strong>的基础设施层，保证请求在复杂服务拓扑中可靠传输</li><li>可以理解为微服务之间的TCP/IP，用于微服务间的网络调用、限流、熔断和监控，对应用透明</li><li>用于服务间通信而单独分理出的组件（Sidecar）</li></ul><h4 id="发展过程"><a href="#发展过程" class="headerlink" title="发展过程"></a>发展过程</h4><ol><li>服务间通信使得服务业务逻辑中夹杂网络传输问题处理逻辑</li><li>TCP协议出现，解决了网络传输中流量控制的问题，将流量控制从服务实现中抽离，成为操作系统中网络层的一部分</li><li>分布式系统特有的如熔断策略、负载均衡、服务发现、认证授权、trace、监控等又需要根据业务需求实现</li><li>某些框架实现了分布式系统通信需要的各种通用语义功能，以依赖的方式引入，屏蔽一些通信细节，使得使用较少代码开发健壮分布式系统</li><li>通过部署在服务环境中的代理服务实现服务间通信，减去了框架学习成本，更解决了通信库版本兼容的问题，防止了由于升级通信库而带来的服务被迫升级</li><li>统一上层运维入口，集中对每个服务中的代理组建进行管理，通过和控制面板交互进行网络拓扑策略的更新和单机数据的汇报。</li></ol><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li>屏蔽了分布式系统通信的复杂性</li><li>真正的语言无关，服务可以使用任何语言，只需要和Service Mesh通信即可</li><li>对应用透明，Service Mesh组件可以单独升级</li></ul><h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h4><ul><li>Service Mesh组件以代理模式计算并转发，一定程度上会影响效率</li><li>服务的整体稳定性依赖于Service Mesh，同时额外引入了对Service Mesh的管理成本</li></ul><h4 id="框架-1"><a href="#框架-1" class="headerlink" title="框架"></a>框架</h4><ul><li>Istio<ul><li>Go语言和C++实现</li><li>性能相对较低一些</li></ul></li><li>Linkerd<ul><li>Scala语言</li><li>总体开销较低，在高qps下性能会有所下降</li><li>仅用于Kubernetes</li></ul></li><li>Conduit（Linkerd 2.x）<ul><li>基于Rust和Go语言</li><li>专为Kubernetes定制的轻量级服务网格</li></ul></li></ul><blockquote><p>头条夏令营作业2，cgroups相关概念</p></blockquote><h3 id="Cgroups"><a href="#Cgroups" class="headerlink" title="Cgroups"></a>Cgroups</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><ul><li>进行分组化管理的Linux<strong>内核</strong>功能</li><li>通过子系统来完成，每个子系统就是一个资源分配器</li><li>例如，<code>cpu</code> 子系统就是控制CPU资源的分配器</li><li>如果进程加入了某一个控制组，该控制组对Linux的系统资源都有严格限制，进程在使用这些资源时不能超过最大限制</li></ul><h4 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h4><ul><li>任务（task）：在cgroup中任务就是系统的一个进程</li><li>控制族群（control group）：一组按照某种资源限制划分的进程组</li><li>层级（hierachy）： 控制族群组成的控制族群树，子控制进程组继承父控制进程组</li><li>子系统（subsystem）：任务组中的一个模块，是一个控制器，提供多种资源限制的控制器</li></ul><h4 id="子系统"><a href="#子系统" class="headerlink" title="子系统"></a>子系统</h4><ul><li>可以使用<code>lssubsys -a</code> 查看所有子系统</li><li>要为cgroup分配限制的资源首先要挂在子系统，然后才有控制组</li><li><code>blkio</code> 限制块设备的输入输出控制</li><li><code>cpu</code> 使用调度程序为<code>cgroup</code> 任务提供cpu访问</li><li><code>cpuacct</code> 产生cgroup任务的cpu资源报告</li><li><code>cpuset</code> 在多核心cpu中为cgroup任务分配单独cpu和内存</li><li><code>devices</code> 允许或拒绝cgroup任务对设备的访问</li><li><code>freezer</code> 暂停和恢复cgroup任务</li><li><code>memory</code> 设置每个cgroup的内存限制及产生内存资源报告</li><li><code>perf_event</code> 增加了对每个group的监测和跟踪能力，可监测某个特定group的所有进程以及运行在特定cpu上的线程</li><li><code>hugetlb</code> HugeTLB页的资源控制功能</li></ul><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ul><li>ubuntu：<code>apt-get install cgroup-bin</code></li><li>Centos: <code>yum install libcgroup</code></li></ul><h4 id="CPU子系统"><a href="#CPU子系统" class="headerlink" title="CPU子系统"></a>CPU子系统</h4><h5 id="一些参数"><a href="#一些参数" class="headerlink" title="一些参数"></a>一些参数</h5><ul><li><code>cpu.cfs_period_us</code> 每个CPU时间片的微秒数，限制从1毫秒到1秒之间</li><li><code>cpu.cfs_quota_us</code> 在当前的每个CPU时间片中可以使用的CPU时间数</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;blockquote&gt;
&lt;p&gt;头条夏令营作业1，微服务相关调研&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;微服务&quot;&gt;&lt;a href=&quot;#微服务&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="头条夏令营" scheme="https://thomstrong.github.io/tags/%E5%A4%B4%E6%9D%A1%E5%A4%8F%E4%BB%A4%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>Go 语言基础学习</title>
    <link href="https://thomstrong.github.io/2019/07/23/first-golang/"/>
    <id>https://thomstrong.github.io/2019/07/23/first-golang/</id>
    <published>2019-07-23T09:05:23.000Z</published>
    <updated>2020-11-16T02:53:09.682Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><blockquote><p>学习自<a href="https://www.runoob.com/go/go-concurrent.html" target="_blank" rel="noopener">菜鸟教程</a>/编码自<a href="https://tour.go-zh.org/welcome/1" target="_blank" rel="noopener">Go指南</a>/更全的<a href="https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/preface.md" target="_blank" rel="noopener">教程</a></p></blockquote><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>静态强类型、编译型、并发型</li></ul><h4 id="特色"><a href="#特色" class="headerlink" title="特色"></a>特色</h4><ul><li>简洁、快速、安全</li><li><strong>并行</strong>、有趣、开源</li><li>内存管理、数组安全、编译迅速</li></ul><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><ul><li>搭载 Web 服务器</li><li>存储集群</li><li>巨型中央服务器的系统</li></ul><h3 id="写代码"><a href="#写代码" class="headerlink" title="写代码"></a>写代码</h3><h4 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main <span class="comment">// 定义包名，main包表示一个可独立执行的程序，每个Go应用都包含一个名为main的包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span> <span class="comment">// 引入包</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; <span class="comment">// main函数是所有可执行程序必须包含的，此处&#123;不可换行否则编译错误</span></span><br><span class="line">   <span class="comment">/* 这是我的第一个简单的程序 */</span></span><br><span class="line">   fmt.Println(<span class="string">"Hello, World!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>行分割，每个语句是一行，无需使用<code>;</code>分割</li></ul><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><blockquote><p>与其他语言有相同之处，也有不同之处</p></blockquote><ul><li>基本类型：<code>int</code>、<code>bool</code>、<code>float32</code>、<code>float64</code>、<code>string</code>(字符串的字节使用 UTF-8 编码标识 Unicode 文本)</li><li><p>衍生类型</p><ul><li><p>指针类型（Pointer）</p></li><li><p>数组类型</p><ul><li>比较</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">slice1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">slice2 := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">slice3 := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">slice4 := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(slice1 == slice2) <span class="comment">// 编译错误，长度不相等，无法比较</span></span><br><span class="line">fmt.Println(slice1 == slice3) <span class="comment">// true</span></span><br><span class="line">fmt.Println(slice1 == slice4) <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>结构化类型(struct)</p></li><li><p>Channel 类型</p></li><li><p>函数类型</p></li><li><p>切片类型</p></li><li><p>接口类型（interface）</p></li><li><p>Map 类型</p><ul><li>单变量声明方法</li></ul></li><li><code>var agePtr *int</code> 没有初始化则默认为零值</li><li><code>var d = true</code> 赋初值省略变脸类型</li><li><code>f := &quot;Runoob&quot;</code> 省略<code>var</code>和变量类型，只能在函数中出现，且只能用于声明</li></ul><ul><li><p>多变量声明</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x, y <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> (  <span class="comment">// 这种因式分解关键字的写法一般用于声明全局变量</span></span><br><span class="line">    a <span class="keyword">int</span></span><br><span class="line">    b <span class="keyword">bool</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>所有声明的变量必须被使用，否则会编译失败，因此需要声明但是不会用到的变量可使用<code>_</code>空白标识符占位</p></li><li><p>相同类型变量的交换赋值可以使用<code>a, b = b, a</code></p></li><li><p>常量声明。其中iota为特殊常量，可以认为是一个可以被编译器修改的常量，其值是常量所在的行index</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">d = <span class="number">4</span> <span class="comment">// 4</span></span><br><span class="line">e <span class="comment">// 未赋值重复上一个常量赋值，4</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">a = <span class="number">2</span> <span class="comment">// 2</span></span><br><span class="line">b = <span class="literal">iota</span> <span class="comment">//1</span></span><br><span class="line">c <span class="comment">// 2</span></span><br><span class="line">  d = <span class="literal">iota</span> * <span class="literal">iota</span> <span class="comment">// 3 * 3 = 9</span></span><br><span class="line">  e <span class="comment">// 4 * 4 = 16</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><h4 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h4><ul><li>常规运算：<ul><li>算数运算<code>+ - * / % ++ --</code></li><li>关系运算<code>&gt; &lt; == != &gt;= &lt;=</code></li><li>逻辑运算<code>&amp;&amp; || !</code></li><li>位运算<code>&amp; | ^ &gt;&gt; &lt;&lt; &amp;^(按位清零)</code></li><li>赋值运算<code>=</code>(以及运算后赋值<code>+=</code>等等)</li><li>其他运算<code>&amp; *</code></li></ul></li></ul><h4 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h4><ul><li><code>if</code>和<code>if-else</code></li><li><code>switch-case</code><ul><li>不用类似<code>break</code>语法进行单<code>case</code>控制，可以使用<code>fallthrough</code>使得执行当前<code>case</code>后强行进入下一个<code>case</code>且不用判断下一个<code>case</code>是否为真</li><li>可以使用<code>switch …{ case …: }</code>的写法也可以使用<code>switch { case…: }</code>判定”true case”的写法</li></ul></li><li><code>select-case</code><ul><li>每个 case 都必须是一个通信</li><li>所有 channel 表达式都会被求值</li><li>所有被发送的表达式都会被求值</li><li>如果任意某个通信可以进行，它就执行，其他被忽略。</li><li>如果有多个 case 都可以运行，Select 会随机公平地选出一个执行。其他不会执行。 否则：<ul><li>如果有 default 子句，则执行该语句。</li><li>如果没有 default 子句，select 将阻塞，直到某个通信可以运行；Go 不会重新对 channel 或值进行求值。</li></ul></li><li>结合<code>for</code>循环和<code>goroutine</code>可以完成并行</li></ul></li><li>不支持 <code>? :</code> 形式的条件判断</li></ul><h4 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h4><ul><li><p>表示方法</p><ul><li><code>for init; condition; post { }</code></li><li><p><code>for condition { }</code> //等价于C语言中的while</p></li><li><p><code>for { }</code>// while true</p></li></ul></li><li><p>or 循环的 range 格式可以对 slice、map、数组、字符串等进行迭代循环</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> oldMap &#123;</span><br><span class="line">    newMap[key] = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function_name</span><span class="params">( [parameter list] )</span> [<span class="title">return_types</span>]</span> &#123;</span><br><span class="line">   <span class="comment">// 函数体</span></span><br><span class="line">&#125; <span class="comment">// 函数定义</span></span><br><span class="line"><span class="comment">/* ==================================================== */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 函数体</span></span><br><span class="line">&#125;() <span class="comment">// 匿名函数直接调用</span></span><br><span class="line"><span class="comment">/* ==================================================== */</span></span><br><span class="line">myFunc := <span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 函数体</span></span><br><span class="line">&#125; <span class="comment">// 声明函数变量</span></span><br><span class="line">myFunc() <span class="comment">// 调用</span></span><br><span class="line"><span class="comment">/* ==================================================== */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> y, x</span><br><span class="line">&#125; <span class="comment">// 返回多值的函数</span></span><br><span class="line"><span class="comment">/* ==================================================== */</span></span><br><span class="line"><span class="comment">/* 闭包函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSequence</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   i:=<span class="number">0</span></span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">      i+=<span class="number">1</span></span><br><span class="line">     <span class="keyword">return</span> i  </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">nextNumber := getSequence()  </span><br><span class="line">fmt.Println(nextNumber()) <span class="comment">// 1</span></span><br><span class="line">fmt.Println(nextNumber()) <span class="comment">// 2</span></span><br><span class="line">fmt.Println(nextNumber()) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">nextNumber1 := getSequence()  </span><br><span class="line">fmt.Println(nextNumber1()) <span class="comment">// 1</span></span><br><span class="line">fmt.Println(nextNumber1()) <span class="comment">// 2</span></span><br><span class="line"><span class="comment">/* ==================================================== */</span></span><br></pre></td></tr></table></figure><h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><ul><li>函数内定义的变量称为局部变量</li><li>函数外定义的变量称为全局变量</li><li>函数定义中的变量称为形式参数</li></ul><h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><ul><li>声明方法 <code>var ip *int</code></li><li>访问指针值 <code>fmt.Printf(&quot;*ip 变量的值: %d**\n**&quot;, *ip )</code></li><li>指针不赋初值默认为<code>nil</code>空指针</li></ul><h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><ul><li><p>声明方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Books <span class="keyword">struct</span> &#123;</span><br><span class="line">   title <span class="keyword">string</span></span><br><span class="line">   author <span class="keyword">string</span></span><br><span class="line">   subject <span class="keyword">string</span></span><br><span class="line">   book_id <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义结构体 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Book1 Books   <span class="comment">// 定义空结构体</span></span><br><span class="line"></span><br><span class="line">fmt.Println(Books&#123;<span class="string">"Go 语言"</span>, <span class="string">"www.runoob.com"</span>, <span class="string">"Go 语言教程"</span>, <span class="number">6495407</span>&#125;) <span class="comment">// 按顺序定义变量值</span></span><br><span class="line"></span><br><span class="line">fmt.Println(Books&#123;title: <span class="string">"Go 语言"</span>, author: <span class="string">"www.runoob.com"</span>, subject: <span class="string">"Go 语言教程"</span>, book_id: <span class="number">6495407</span>&#125;) <span class="comment">// 指定成员值</span></span><br></pre></td></tr></table></figure></li><li><p>访问成员</p><ul><li><code>Book1.title = &quot;some title&quot;</code></li><li><code>fmt.Println(Book1.title)</code></li></ul></li></ul><h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><blockquote><p>切片是对数组的抽象，可以理解为动态数组，可以追加元素，在追加时可能使切片的容量增大</p></blockquote><ul><li><p>声明方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice1 = []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; <span class="comment">// 不指定数组大小声明的数组会被认为是切片</span></span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">//声明一个容量为3，当前内含2个元素的切片</span></span><br><span class="line"><span class="keyword">var</span> slice2 = []<span class="keyword">int</span> <span class="comment">// slice2 == nil</span></span><br></pre></td></tr></table></figure></li><li><p>初始化方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice2 := slice1[<span class="number">1</span>:] <span class="comment">// 通过slice1的引用初始化slice2</span></span><br></pre></td></tr></table></figure></li><li><p>append 方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">slice3 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line">fmt.Println(slice3) <span class="comment">// [0, 0]</span></span><br><span class="line">slice3 = <span class="built_in">append</span>(slice3, <span class="number">1</span>)</span><br><span class="line">slice3 = <span class="built_in">append</span>(slice3, <span class="number">1</span>)</span><br><span class="line">slice3 = <span class="built_in">append</span>(slice3, <span class="number">1</span>)</span><br><span class="line">slice3 = <span class="built_in">append</span>(slice3, <span class="number">1</span>) <span class="comment">// 自动扩容到10</span></span><br><span class="line">fmt.Println(slice3) <span class="comment">// [0,0,1,1,1,1]</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(slice3)) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure></li><li><p>copy 方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">slice3 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line">slice4 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(slice3), <span class="built_in">cap</span>(slice3))</span><br><span class="line"><span class="built_in">copy</span>(slice4, slice3) <span class="comment">// 可以认为是for循环两个slice中len最小的值进行赋值</span></span><br><span class="line">slice4[<span class="number">0</span>] = <span class="number">1233</span></span><br><span class="line">fmt.Println(slice3, slice4)<span class="comment">// [0,0] [1233,0]</span></span><br></pre></td></tr></table></figure><ul><li><code>copy</code> 方法使用两者长度较小的作为复制目标的长度</li><li>方法返回复制目标长度，即二者长度最小值</li></ul></li></ul><h4 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h4><ul><li><p>返回一个有序对<code>key, value</code>用于遍历数组/切片/通道/集合，和<code>python</code>的<code>enumerate</code>方法类似</p></li><li><p>例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">nums := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">  sum += num</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kvs := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"a"</span>: <span class="string">"apple"</span>, <span class="string">"b"</span>: <span class="string">"banana"</span>&#125;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> kvs &#123;</span><br><span class="line">  fmt.Printf(<span class="string">"%s -&gt; %s\n"</span>, k, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><ul><li>无序键值对的集合，使用哈希表来实现</li><li>声明方式<ul><li><code>var map1 map[string]sttring</code> // 不赋初值声明</li><li><code>map2 := make(map[string]string)</code> // 不赋初值声明</li><li><code>map3  := map[string]string{&quot;a&quot;: &quot;apple&quot;, &quot;b&quot;: &quot;banana&quot;}</code> // 赋初值声明</li></ul></li><li>赋值方式与<code>python</code>相同</li><li>可以使用<code>delete()</code>函数删除字典中的键值对</li></ul><h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><ul><li>使用类似<code>float32(sum)</code>的方法对<code>var sum int = 2</code>进行强制类型转换</li></ul><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><ul><li><p>通过定义接口，然后直接实现接口中声明的函数，进行多态实现</p></li><li><p>示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> phone <span class="keyword">interface</span> &#123;</span><br><span class="line">getname() <span class="keyword">string</span></span><br><span class="line">call()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Iphone <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Nokia <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(iphone Iphone)</span> <span class="title">getname</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"I am iphone"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(nokia Nokia)</span> <span class="title">getname</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"I am nokia"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(iphone Iphone)</span> <span class="title">call</span><span class="params">()</span></span>  &#123;</span><br><span class="line">fmt.Println(<span class="string">"call with iphone"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(nokia Nokia)</span> <span class="title">call</span><span class="params">()</span></span>  &#123;</span><br><span class="line">fmt.Println(<span class="string">"call with nokia"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ===============in main() ====================== */</span></span><br><span class="line">phone := <span class="built_in">new</span>(Iphone)</span><br><span class="line">fmt.Println(phone.getname()) <span class="comment">//I am iphone</span></span><br><span class="line">phone.call()<span class="comment">// call with iphone</span></span><br><span class="line"></span><br><span class="line">anotherPhone := <span class="built_in">new</span>(Nokia) </span><br><span class="line">fmt.Println(anotherPhone.getname()) <span class="comment">// I am nokia</span></span><br><span class="line">anotherPhone.call() <span class="comment">// call with nokia</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h4><ul><li><p>通过实现<code>error.Error()</code>函数来实现异常捕获</p></li><li><p>示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DivideError <span class="keyword">struct</span> &#123;</span><br><span class="line">dividee <span class="keyword">int</span></span><br><span class="line">divider <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(divideError *DivideError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">strFormat := <span class="string">`</span></span><br><span class="line"><span class="string">    Cannot proceed, the divider is zero.</span></span><br><span class="line"><span class="string">    dividee: %d</span></span><br><span class="line"><span class="string">    divider: 0</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(strFormat, divideError.dividee)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Divide</span><span class="params">(varDividee <span class="keyword">int</span>, varDivider <span class="keyword">int</span>)</span> <span class="params">(result <span class="keyword">int</span>, errorMsg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> varDivider == <span class="number">0</span> &#123;</span><br><span class="line">dData := DivideError&#123;</span><br><span class="line">dividee: varDividee,</span><br><span class="line">divider: varDivider,</span><br><span class="line">&#125;</span><br><span class="line">errorMsg = dData.Error()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> varDividee / varDivider, <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ===============in main() ====================== */</span></span><br><span class="line"><span class="keyword">for</span> divider := <span class="keyword">range</span> []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>&#125; &#123;</span><br><span class="line">  <span class="keyword">if</span> result, errorMsg := Divide(<span class="number">100</span>, divider); errorMsg == <span class="string">""</span> &#123;</span><br><span class="line">    fmt.Println(divider, result)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"errorMsg is: "</span>, errorMsg)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* output:</span></span><br><span class="line"><span class="comment">errorMsg is:  </span></span><br><span class="line"><span class="comment">  Cannot proceed, the divider is zero.</span></span><br><span class="line"><span class="comment">    dividee: 100</span></span><br><span class="line"><span class="comment">    divider: 0</span></span><br><span class="line"><span class="comment">1 100</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="Go-并发"><a href="#Go-并发" class="headerlink" title="Go 并发"></a>Go 并发</h4><h5 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h5><ul><li><p>Go 使用 goroutine实现并发。goroutine 是轻量级线程，goroutine 的调度是由 Golang 运行时进行管理的。</p></li><li><p>开启goroutine的方法：<code>go fun(x, y, z)</code></p></li><li>Goroutine 会随着主线程的结束而自动销毁</li></ul><h5 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h5><ul><li><p>通道（channel）是用来传递数据的一个数据结构</p></li><li><p>使用方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// 声明信道</span></span><br><span class="line">ch &lt;- v    <span class="comment">// 把 v 发送到通道 ch</span></span><br><span class="line">v := &lt;-ch  <span class="comment">// 从 ch 接收数据</span></span><br><span class="line">           <span class="comment">// 并把值赋给 v</span></span><br></pre></td></tr></table></figure></li><li><p>通道可以设置缓冲区，通过 make 的第二个参数指定缓冲区大小 <code>ch := make(chan int, 10)</code></p></li><li><p>通道遍历可使用<code>range</code>语法</p></li></ul><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><blockquote><p>摘自公众号 Golang来啦</p></blockquote><h4 id="1-下面代码能否正常结束"><a href="#1-下面代码能否正常结束" class="headerlink" title="1. 下面代码能否正常结束"></a>1. 下面代码能否正常结束</h4> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> v &#123;</span><br><span class="line">        v = <span class="built_in">append</span>(v, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<code>range</code>的循环次数，在最开始就已经确定，不会因为序列的变化而改变</p><h4 id="2-下面的代码输出是什么"><a href="#2-下面的代码输出是什么" class="headerlink" title="2. 下面的代码输出是什么"></a>2. 下面的代码输出是什么</h4>   <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> m = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(i, v)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>由于<code>range</code> 函数的返回会复用<code>i</code>和 <code>v</code> 而不是重新声明，因此在<code>println</code> 函数输出前可能可以是循环过程中的任何值。为保证唯一，可以使用临时变量或者传参的形式保证传入参数的唯一性。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">change</span><span class="params">(s ...<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">s = <span class="built_in">append</span>(s,<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">5</span>,<span class="number">5</span>)</span><br><span class="line">slice[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">slice[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">change(slice...)</span><br><span class="line">fmt.Println(slice)</span><br><span class="line">change(slice[<span class="number">0</span>:<span class="number">2</span>]...)</span><br><span class="line">fmt.Println(slice)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* output:</span></span><br><span class="line"><span class="comment"> [1 2 0 0 0]</span></span><br><span class="line"><span class="comment"> [1 2 3 0 0]</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">===========================</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> r [<span class="number">5</span>]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">            a[<span class="number">1</span>] = <span class="number">12</span></span><br><span class="line">            a[<span class="number">2</span>] = <span class="number">13</span></span><br><span class="line">        &#125;</span><br><span class="line">        r[i] = v</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"r = "</span>, r)</span><br><span class="line">    fmt.Println(<span class="string">"a = "</span>, a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* output:</span></span><br><span class="line"><span class="comment"> r =  [1 12 13 4 5]</span></span><br><span class="line"><span class="comment"> a =  [1 12 13 4 5]</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><ul><li>切片的底层是一个结构体，包含切片长度、容量和一个数组指针。对切片进行<code>拷贝</code>或<code>[i:j]</code>截取操作时，底层的数组指针不会改变，仍指向同一数组。仅当在<code>append</code> 操作使得<code>len &gt; cap</code> 时才会重新创建新的切片。因此对于副本的所有操作均会应用到原切片</li><li>注意区分切片的声明和数组的声明</li></ul><h4 id="3-defer-和-recover"><a href="#3-defer-和-recover" class="headerlink" title="3. defer 和 recover"></a>3. defer 和 recover</h4><h5 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h5><ul><li><p>注册延迟调用的机制</p></li><li><p>把函数压入栈中，当defer的上层<strong>函数</strong>返回（包括正常返回和异常返回）后再将栈内函数弹出执行</p></li><li><p>由于是在真正返回之前进行弹栈，因此就可以通过诸如如下形式，对返回的命名参数在真正返回之前进行操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fn</span><span class="params">()</span><span class="params">(r T)</span></span> &#123;</span><br><span class="line"><span class="comment">// init t</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// do something change r to change the return value which is t before</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>拆解：将函数的返回命名为声明中的返回查看结果。对于匿名返回的参数，可将返回值赋给一个命名变量用来拆解</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个例子：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span> <span class="params">(r <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">     t := <span class="number">5</span></span><br><span class="line">     <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">       t = t + <span class="number">5</span></span><br><span class="line">     &#125;()</span><br><span class="line">     <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 拆解后：</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span> <span class="params">(r <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">     t := <span class="number">5</span></span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 1. 赋值指令</span></span><br><span class="line">     r = t</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 2. defer被插入到赋值与返回之间执行，这个例子中返回值r没被修改过</span></span><br><span class="line">     <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;        </span><br><span class="line">         t = t + <span class="number">5</span></span><br><span class="line">     &#125;()</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 3. 空的return指令</span></span><br><span class="line">     <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>综上所述，</p><ul><li>对于命名返回参数的函数使用拆解的方法看</li><li>对于函数式的方法应该注意是传参调用还是闭包调用，传参使用的是复制的当时的值，闭包则使用的是变量的引用</li><li><code>defer</code>延时调用的方法，可以在参数出现时定义其最终关闭的方法，防止后续赋值导致其失效的问题</li><li><code>defer</code>调用失败，会返回<code>panic</code></li></ul><h5 id="recover"><a href="#recover" class="headerlink" title="recover"></a>recover</h5></li><li><p>如果程序出现致命错误，触发<code>panic</code> ，此时当前正在执行程序会被直接停掉，而不只是协程。为了防止程序直接挂掉，需要在defer中使用recover对程序进行会恢复，防止程序完全挂掉</p></li><li><code>recover</code> 只有在<code>defer</code> 的上下文中才有效</li><li>通过<code>recover</code> 捕获<code>panic</code> 稳住主流程，以免影响其他协程的正常运行</li><li><code>recover</code>函数和<code>panic</code>可以认为是弹栈和压栈操作，<code>panic</code>压栈<code>interface</code>，对于生效的<code>recover</code>再弹栈<code>inteface</code></li></ul><h4 id="4-闭包"><a href="#4-闭包" class="headerlink" title="4. 闭包"></a>4. 闭包</h4><ul><li>闭包 = 函数 + 引用环境</li><li>匿名函数被称作闭包，只可直接调用或者赋值于某个变量</li><li>闭包捕获的变量和常量是引用传递</li><li>感性的理解上可以将闭包认为是声明了一个类，然后捕获的变量成为了类的成员变量</li></ul><h4 id="5-golang中-的4处用法"><a href="#5-golang中-的4处用法" class="headerlink" title="5. golang中... 的4处用法"></a>5. golang中<code>...</code> 的4处用法</h4><ul><li>函数中的最后一个参数，形如<code>func(n ...T)</code>表示函数在此参数（可变参数）后可接受若干个本类型的参数</li><li>在向可变参数函数传递参数时使用<code>func(nums...)</code>方式传入参数</li><li>在不定个数数组声明时，形如<code>[...]string{&quot;Moe&quot;, &quot;Larry&quot;, &quot;Curly&quot;}</code>方式，使编译器自动判定数组长度</li><li>在go命令中使用<code>go test ./...</code>的方式递归通配所有包文件</li></ul><h4 id="6-下面代码输出什么"><a href="#6-下面代码输出什么" class="headerlink" title="6. 下面代码输出什么"></a>6. 下面代码输出什么</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line"><span class="string">"A"</span>: <span class="number">21</span>,</span><br><span class="line"><span class="string">"B"</span>: <span class="number">22</span>,</span><br><span class="line"><span class="string">"C"</span>: <span class="number">23</span>,</span><br><span class="line">&#125;</span><br><span class="line">counter := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line"><span class="keyword">if</span> counter == <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">"A"</span>)</span><br><span class="line">&#125;</span><br><span class="line">counter++</span><br><span class="line">fmt.Println(k, v)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"counter is "</span>, counter)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">A 21</span></span><br><span class="line"><span class="comment">B 22</span></span><br><span class="line"><span class="comment">C 23</span></span><br><span class="line"><span class="comment">counter is  3</span></span><br><span class="line"><span class="comment">或者</span></span><br><span class="line"><span class="comment">B 22</span></span><br><span class="line"><span class="comment">C 23</span></span><br><span class="line"><span class="comment">counter is  2</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><ul><li>Map 的遍历是无序的，因此若A在第一次循环，则可循环3次，若A不在第一次循环，则循环两次</li></ul><h4 id="7-break-的高级用法"><a href="#7-break-的高级用法" class="headerlink" title="7. break 的高级用法"></a>7. break 的高级用法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">/* local variable definition */</span></span><br><span class="line">a := <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* for loop execution */</span></span><br><span class="line">I:</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">a -= <span class="number">1</span></span><br><span class="line">fmt.Println(a)</span><br><span class="line"><span class="keyword">if</span> a &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">break</span> I <span class="comment">// 使得一次性退出两层循环</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-下面代码输出什么"><a href="#8-下面代码输出什么" class="headerlink" title="8. 下面代码输出什么"></a>8. 下面代码输出什么</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i := <span class="number">1</span></span><br><span class="line">    s := []<span class="keyword">string</span>&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>&#125;</span><br><span class="line">    i, s[i<span class="number">-1</span>] = <span class="number">2</span>, <span class="string">"Z"</span></span><br><span class="line">    fmt.Printf(<span class="string">"s: %v \n"</span>, s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">s: [Z,B,C]</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><ul><li>赋值顺序：先计算等号左边表达式取值，再考虑等号右边的赋值</li></ul><h4 id="9-下面代码输出什么"><a href="#9-下面代码输出什么" class="headerlink" title="9.下面代码输出什么"></a>9.下面代码输出什么</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ts := [<span class="number">2</span>]X&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i, t := <span class="keyword">range</span> ts[:] &#123;</span><br><span class="line">  <span class="keyword">switch</span> i &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    t.n = <span class="number">3</span></span><br><span class="line">    ts[<span class="number">1</span>].n = <span class="number">9</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    fmt.Println(ts[i].n, <span class="string">" "</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(ts) <span class="comment">// [&#123;0&#125; &#123;9&#125;]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ts := [<span class="number">2</span>]X&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> ts[:] &#123;</span><br><span class="line"><span class="keyword">switch</span> i &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">ts[<span class="number">1</span>].n = <span class="number">9</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">fmt.Println(ts[i].n, <span class="string">" "</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(ts) <span class="comment">// [&#123;0&#125; &#123;9&#125;]</span></span><br></pre></td></tr></table></figure><ul><li>切片操作生成新的切片，使用<code>range</code>返回参数循环变量均为变量副本，对其操作不会影响原切片</li><li>切片操作生成新的切片，但是共享底层数组，因此直接使用下标操作会同时生效</li></ul><h4 id="10-下面代码有什么问题"><a href="#10-下面代码有什么问题" class="headerlink" title="10. 下面代码有什么问题"></a>10. 下面代码有什么问题</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f, err := os.Open(<span class="string">"file"</span>)</span><br><span class="line">    <span class="keyword">defer</span> f.Close()<span class="comment">// 此处f可能为nil，导致defer中再次出现panic</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    b, err := ioutil.ReadAll(f)</span><br><span class="line">    <span class="built_in">println</span>(<span class="keyword">string</span>(b))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//修正代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f, err := os.Open(<span class="string">"file"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">    b, err := ioutil.ReadAll(f)</span><br><span class="line">    <span class="built_in">println</span>(<span class="keyword">string</span>(b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在函数使用场景下，应注意先判断<code>error</code>只有<code>error != nil</code>时，可认为返回值有效，然后进一步处理</li></ul><h4 id="11-下面代码有什么问题"><a href="#11-下面代码有什么问题" class="headerlink" title="11. 下面代码有什么问题"></a>11. 下面代码有什么问题</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"1"</span>)</span><br><span class="line">      wg.Done() </span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">    wg.Wait() <span class="comment">// panic here</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// panic: sync: WaitGroup is reused before previous Wait has returned</span></span><br></pre></td></tr></table></figure><ul><li>调用<code>Done()</code>后立刻调用<code>Add(1)</code>导致<code>Wait()</code>函数执行时，发现<code>wg</code>变量仍在被使用，误以为自己错误进入了<code>Wait()</code>函数而<code>panic</code></li><li>在使用<code>sync.WaitGroup</code>时，<code>Add(n)</code>就要配对n个<code>Done()</code>调用，否则会出现死锁</li></ul><h4 id="12-下面代码输出什么"><a href="#12-下面代码输出什么" class="headerlink" title="12. 下面代码输出什么"></a>12. 下面代码输出什么</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Slice []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSlice</span><span class="params">()</span> <span class="title">Slice</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make</span>(Slice, <span class="number">0</span>)</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Slice)</span> <span class="title">Add</span><span class="params">(elem <span class="keyword">int</span>)</span> *<span class="title">Slice</span></span> &#123;</span><br><span class="line">     *s = <span class="built_in">append</span>(*s, elem)</span><br><span class="line">    fmt.Print(elem)</span><br><span class="line">     <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := NewSlice()</span><br><span class="line">    <span class="keyword">defer</span> s.Add(<span class="number">1</span>).Add(<span class="number">2</span>)</span><br><span class="line">    s.Add(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output: 132</span></span><br></pre></td></tr></table></figure><ul><li><code>defer</code> 只会执行一级函数，对于循环调用，会提前计算到倒数第二级函数结果，仅在<code>defer</code>中执行最后一次调用</li></ul><h4 id="13-下面代码输出什么"><a href="#13-下面代码输出什么" class="headerlink" title="13. 下面代码输出什么"></a>13. 下面代码输出什么</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">alwaysFalse</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="keyword">switch</span> alwaysFalse()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">fmt.Println(<span class="string">"false"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">fmt.Println(<span class="string">"true"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>首先注意到，第六行大括号独占一行。因此可以参考<a href="https://gfw.go101.org/article/line-break-rules.html" target="_blank" rel="noopener">golang 代码断行规则</a></p></li><li><p>golang 在编译阶段，会在行尾是一下情况时，在其后插入分号</p><ul><li><p>标识符</p></li><li><p>整数、浮点数、虚部、码点、字符串字面表示形式</p><blockquote><p> 字面表示形式可以理解为变量在代码中的表现，例如值为15但字面表示形式可以是15、0xF、0b1111等多种字面表示形式</p></blockquote></li><li><p>break、continue、fallthrough、return</p></li><li>++、–</li><li>)、}、]</li><li>为了允许复杂语句完全显示在一个代码行中，分号可能被插在一个右小括号<code>)</code>或者右花括号<code>}</code>之前</li></ul></li><li><p>对于上述情况外的其他情况，分号需要自行插入</p></li><li><p>对于可能隐式插入分号的断句可以使用合法的<code>,</code>规避隐式分号的插入</p></li><li><p>在上述代码中，<code>alwaysFalse</code>函数只是被执行，但是没有被变量接收，等价于如下代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">alwaysFalse</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="keyword">switch</span> _ = alwaysFalse();&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">fmt.Println(<span class="string">"false"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">fmt.Println(<span class="string">"true"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码直接进入<code>case true</code>，若希望实现效果，应该改为如下形式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">alwaysFalse</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="keyword">switch</span> tmp := alwaysFalse()</span><br><span class="line">tmp &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">fmt.Println(<span class="string">"false"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">fmt.Println(<span class="string">"true"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仍然是个很奇怪的写法，使得代码可读性大大降低，非常不推荐</p></li><li><p>可以使用<code>go fmt</code>和<code>go vet</code>命令进行代码格式化，增加代码规范性，发现可能的逻辑错误</p></li></ul><h4 id="14-下面代码可以编译通过么"><a href="#14-下面代码可以编译通过么" class="headerlink" title="14. 下面代码可以编译通过么"></a>14. 下面代码可以编译通过么</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> x &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> A</span><br><span class="line">A:</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="keyword">goto</span> B</span><br><span class="line">B: <span class="comment">// 编译失败，tag后缺少语句</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">goto</span> C</span><br><span class="line">C:</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编译器会在7行和14行花括号前加入<code>;</code>使得tag后生成一个由<code>;</code>单独构成的空语句，从而使得<code>A</code>和<code>C</code>两个tag合法</li><li>可在13行后加入<code>;</code>使得语法编译通过</li></ul><h4 id="15-下面代码输出什么"><a href="#15-下面代码输出什么" class="headerlink" title="15. 下面代码输出什么"></a>15. 下面代码输出什么</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(strings.TrimRight(<span class="string">"ABBA"</span>, <span class="string">"BA"</span>)) <span class="comment">// ""</span></span><br><span class="line">  fmt.Println(strings.TrimRight(<span class="string">"ABDBABBBA"</span>, <span class="string">"BA"</span>)) <span class="comment">// "ABD"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>输出空字符串，<code>TrimRight</code>会将第二字符串中出现的全部字符从第一字符串右边开始匹配直到匹配不上为止</li><li><code>TrimSuffix</code>可以完成去除后缀的效果</li></ul><h4 id="16-下面代码输出什么"><a href="#16-下面代码输出什么" class="headerlink" title="16. 下面代码输出什么"></a>16. 下面代码输出什么</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"> x++ </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  init()</span><br><span class="line">  fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编译失败。<code>init</code>函数不能被调用</li><li><code>main()</code>函数不可带参数且不能有返回</li></ul><h4 id="17-下面代码输出什么"><a href="#17-下面代码输出什么" class="headerlink" title="17. 下面代码输出什么"></a>17. 下面代码输出什么</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee User</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span><span class="title">SetName</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(name)</span><br><span class="line">u.Name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  e := <span class="built_in">new</span>(Employee)</span><br><span class="line">e.SetName()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编译失败，<code>SetName</code>为User实现的函数，<code>Employee</code>是重新定义的类，需要重新实现<code>SetName</code>实例才可调用</li><li>修改方法<ol><li>重写<code>func (e *Employee)SetName(name string)</code>函数</li><li>将<code>User</code>作为<code>Employee</code>的匿名变量，隐式调用<code>User</code>的<code>SetName</code>函数</li><li>同时使用1和2修改，导致两个<code>SetName</code>的情况时，调用<code>User</code>的<code>SetName</code>需要显式调用</li></ol></li></ul><h4 id="18-下面代码输出什么"><a href="#18-下面代码输出什么" class="headerlink" title="18. 下面代码输出什么"></a>18. 下面代码输出什么</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">"encoding/json"</span></span><br><span class="line"> <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AutoGenerated <span class="keyword">struct</span> &#123;</span><br><span class="line"> Age   <span class="keyword">int</span>    <span class="string">`json:"age"`</span></span><br><span class="line"> Name  <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line"> Child []<span class="keyword">int</span>  <span class="string">`json:"child"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    jsonStr1 := <span class="string">`&#123;"age": 14,"name": "potter", "child":[1,2,3]&#125;`</span></span><br><span class="line"> a := AutoGenerated&#123;&#125;</span><br><span class="line"> json.Unmarshal([]<span class="keyword">byte</span>(jsonStr1), &amp;a)</span><br><span class="line"> aa := a.Child</span><br><span class="line"> fmt.Println(aa)</span><br><span class="line"> jsonStr2 := <span class="string">`&#123;"age": 12,"name": "potter", "child":[3,4,5,7,8,9]&#125;`</span></span><br><span class="line"> json.Unmarshal([]<span class="keyword">byte</span>(jsonStr2), &amp;a)</span><br><span class="line"> fmt.Println(aa)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>答案：[1,2,3][3,4,5]</p></li><li><p>解析：</p><ul><li>知识点1：golang json库Unmarshal数组类型的逻辑。针对slice类型，在反序列化时，json库会首先将数组的len置0，然后将数据逐个append进数组。</li><li>知识点2：json库对未初始化slice的结构体字段，会初始化一个大小为4的slice，扩容逻辑为<code>newcap := v.Cap() + v.Cap()/2</code></li><li>题目解读：因此，当第一次unmarshal时，aa底层数组指向容量为4的数组。第二次unmarshal时，a结构体中的Child字段，<strong>发生一次扩容</strong>，放弃原有底层数组，<strong>复制数据后，重新指向一个容量为6的底层数组</strong>。因此，aa底层数组会保存有第二次反序列化时的前四个元素，同时a的Child字段slice地址也和aa不同。（此处的扩容逻辑是json库的扩容逻辑，需要注意与slice本身的appen过程&lt;翻倍&gt;扩容逻辑区分）</li></ul></li><li><p>拓展：json库反序列化过程（翻译自Unmarsha源码注释）</p><ul><li><p>接口：<code>json.Unmarshal([]byte(jsonStr1), &amp;a)</code>，必须传入一个指针，否则抛出<code>InvalidUnmarshalError</code>异常</p></li><li><p>Unmarshal与Marshal是互逆的操作，在有必要时，会申请map、slice和指针，并且还有如下附加规则：</p><ul><li><p>对于所有反序列化为指针的json字段，如果json中为null字符则设置为nil指针；否则将结构体中指针指向对应值，如果结构体中对应字段为nil，则重新分配一个新的指针来指向对应值</p></li><li><p>对于实现了Unmarshaler接口的字段，Unmarshal方法会先调用该字段的UnmarshalJSON方法，即便json字符串中对应的值是null；否则，如果该字段实现了encoding.TextUnmarshaler接口并且输入也是一个带引号的字符串，Unmarshal方法会调用该字段的UnmarshalText方法，并将该值的去引号部分作为参数传入</p></li><li><p>如果要反序列化为一个结构体，Unmarshal会通过用于marshal的key来匹配（字段名称或字段的tag）优先使用精确匹配，同时也可以接受大小写不敏感的匹配情况。默认情况下，没有对应结构体字段的json key会被忽略，可通过 Decoder.DisallowUnknownFields更改配置</p></li><li><p>如果json字段对应的结构体字段是个interface类型，那么只会将对应字段值根据如下对应关系进行反序列化：</p><p>| go类型                 | json类型 |<br>| ———————- | ——– |<br>| bool                   | boolean  |<br>| float64                | number   |<br>| string                 | string   |<br>| []interface{}          | array    |<br>| map[string]interface{} | object   |<br>| nil                    | null     |</p></li><li><p>当反序列化一个数组为slice时，Unmarshal方法会先设置其长度为0，然后再逐个元素append到slice中；有一种特殊情况，即当json字符串为一个空数组时，Unmarshal方法会将原有slice替换为一个空slice</p></li><li><p>当反序列化json数组到go数组时，如果go数组长度和json数组长度相同，直接赋值为对应go数组；若json数组长度较短，剩余go数组位使用0补齐；若json数组长度较长，则忽视多余部分</p></li><li><p>反序列化map时，会先建立一个map：如果go结构体的原map是nil，会分配一个新的map；不然会重用已有的map，写入新的k-v，同时保留已有的map键。map的键必须是一下类型之一：字符串、数字、实现了json.Unmarshaler或者实现了encoding.TextUnmashaler接口的结构体</p></li><li><p>如果json值和其类型不匹配，或者数值溢出，Unmarshal会跳过这个字段，并且会尽可能多的将合法的字段反序列化。如果没有更严重的错误发生的话，Unmarshal会返回UnmarshalTypeError说明此次错误。在任何情况下，在错误发生时，都不能确保其余字段能够正常的反序列化。</p></li><li><p>json的null或未设置的字段会反序列化为nil，并且不会抛出任何异常</p></li><li><p>如果反序列化带引号的字符串，无效的UTF-8或UTF-16字符不会被视为错误，而是会被替换为Unicode字符U+FFFD</p></li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;blockquote&gt;
&lt;p&gt;学习自&lt;a href=&quot;https://www.runoob.com/go/go-concurrent.html&quot; target=&quot;_blank&quot; 
      
    
    </summary>
    
      <category term="技术" scheme="https://thomstrong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Golang" scheme="https://thomstrong.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Java 基础复习</title>
    <link href="https://thomstrong.github.io/2019/07/15/first-java/"/>
    <id>https://thomstrong.github.io/2019/07/15/first-java/</id>
    <published>2019-07-15T02:54:08.000Z</published>
    <updated>2019-07-23T07:49:31.619Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><blockquote><p>参考<a href="https://www.liaoxuefeng.com/wiki/1252599548343744" target="_blank" rel="noopener">教程</a></p></blockquote><h3 id="一些基本知识"><a href="#一些基本知识" class="headerlink" title="一些基本知识"></a>一些基本知识</h3><h4 id="语言类型"><a href="#语言类型" class="headerlink" title="语言类型"></a>语言类型</h4><ul><li><p>Java介于编译型语言和解释型语言之间，将代码编译成一种“字节码”，针对不同平台编写虚拟机，不同平台的虚拟机负责加载字节码并执行，这样就实现了“一次编写，到处运行”的效果</p><blockquote><ul><li>编译型语言如C、C++，代码是直接编译成机器码执行，需要考虑跨平台问题</li><li>解释型语言如Python、Ruby，可以由解释器直接加载源码然后运行，代价是运行效率太低</li></ul></blockquote></li></ul><h4 id="EE-SE-ME"><a href="#EE-SE-ME" class="headerlink" title="EE/SE/ME"></a>EE/SE/ME</h4><ul><li>Java SE：Standard Edition，标准版，包含标准的JVM和标准库</li><li>Java EE：Enterprise Edition，在Java SE的基础上加上了大量的API和库，以便方便开发Web应用、数据库、消息服务等</li><li><p>Java ME：Micro Edition，针对嵌入式设备的“瘦身版”，Java SE的标准库无法在Java ME上使用，Java ME的虚拟机也是“瘦身版”</p></li><li><p>Java EE &gt; Java SE &gt; Java ME，Java EE的应用使用的虚拟机和Java SE完全相同，而Java SE的标准库无法在Java ME上使用</p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────────────────┐</span><br><span class="line">│Java EE                    │</span><br><span class="line">│    ┌────────────────────┐ │</span><br><span class="line">│    │Java SE             │ │</span><br><span class="line">│    │    ┌─────────────┐ │ │</span><br><span class="line">│    │    │   Java ME   │ │ │</span><br><span class="line">│    │    └─────────────┘ │ │</span><br><span class="line">│    └────────────────────┘ │</span><br><span class="line">└───────────────────────────┘</span><br></pre></td></tr></table></figure></li></ul><h4 id="JDK-JRE-JSR-JCP"><a href="#JDK-JRE-JSR-JCP" class="headerlink" title="JDK/JRE/JSR/JCP"></a>JDK/JRE/JSR/JCP</h4><ul><li><p>JDK：Java Development Kit，JDK除了包含JRE，还提供了编译器、调试器等开发工具</p></li><li><p>JRE：Java Runtime Environment，JRE就是运行Java字节码的虚拟机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> ┌─    ┌──────────────────────────────────┐</span><br><span class="line"> │     │     Compiler, debugger, etc.     │</span><br><span class="line"> │     └──────────────────────────────────┘</span><br><span class="line">JDK ┌─ ┌──────────────────────────────────┐</span><br><span class="line"> │  │  │                                  │</span><br><span class="line"> │ JRE │      JVM + Runtime Library       │</span><br><span class="line"> │  │  │                                  │</span><br><span class="line"> └─ └─ └──────────────────────────────────┘</span><br><span class="line">       ┌───────┐┌───────┐┌───────┐┌───────┐</span><br><span class="line">       │Windows││ Linux ││ macOS ││others │</span><br><span class="line">       └───────┘└───────┘└───────┘└───────┘</span><br></pre></td></tr></table></figure></li><li><p>JSR规范：Java Specification Request</p></li><li>JCP组织：Java Community Process</li></ul><h4 id="Jdk中的命令"><a href="#Jdk中的命令" class="headerlink" title="Jdk中的命令"></a>Jdk中的命令</h4><ul><li>java：这个可执行程序其实就是JVM，运行Java程序，就是启动JVM，然后让JVM执行指定的编译后的代码</li><li>javac：这是Java的编译器，它用于把Java源码文件（以<code>.java</code>后缀结尾）编译为Java字节码文件（以<code>.class</code>后缀结尾）</li><li>jar：用于把一组<code>.class</code>文件打包成一个<code>.jar</code>文件，便于发布</li><li>javadoc：用于从Java源码中自动提取注释并生成文档</li><li>jdb：Java调试器，用于开发阶段的运行调试</li></ul><h3 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h3><blockquote><p>Google代码规范：<a href="https://google.github.io/styleguide/javaguide.html" target="_blank" rel="noopener">Google Java Code Style</a></p><p>阿里巴巴代码规约IDE插件：<a href="https://github.com/alibaba/p3c/wiki" target="_blank" rel="noopener">alibaba/p3c</a></p></blockquote><h4 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h4><ul><li>一个<code>.java</code>文件只能包含一个<code>public</code>类，但可以包含多个非<code>public</code>类。如果有<code>public</code>类，文件名必须和<code>public</code>类的名字相同。</li><li>使用<code>javac</code>可以将<code>.java</code>源码编译成<code>.class</code>字节码</li><li>使用<code>java</code>可以运行一个已编译的Java程序，参数是<strong>类名</strong>，如<code>java HelloWorld</code>而不是<code>java HelloWorld.class</code> 或 <code>java HelloWorld.java</code></li></ul><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><ul><li>Java是面向对象的语言，一个程序的基本单位就是<code>class</code>，<code>class</code>是关键字</li><li>class命名使用大驼峰</li><li>Java入口程序规定的方法必须是静态方法，方法名必须为<code>main</code>，括号内的参数必须是String数组</li></ul><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><ul><li><p>整数类型：byte(1Byte)，short(2Byte)，int(4Byte)，long(8Byte)</p></li><li><p>浮点数类型：float(4Byte)，double(8Byte)</p></li><li><p>字符类型：char(2Byte)</p></li><li><p>布尔类型：boolean</p><blockquote><p>理论上存储布尔类型只需要1 bit，但JVM内部会把<code>boolean</code>表示为4字节整数</p></blockquote></li><li><p>定义变量的时候，如果加上<code>final</code>修饰符，这个变量就变成了常量。常量名通常全部大写</p></li><li>有些时候，类型的名字太长，写起来比较麻烦。如果想省略变量类型，可以使用<code>var</code>关键字<strong>(java 10+)</strong></li></ul><h4 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h4><ul><li>整数的除法对于除数为0时运行时将报错，但编译不会报错；浮点数除<code>0</code>时，不会报错，但会返回几个特殊值：<ul><li><code>NaN</code>，0.0/0，表示Not a Number</li><li><code>Infinity</code>，正数除以0，表示无穷大</li><li><code>-Infinity</code>，负数除以0，表示负无穷大</li></ul></li><li>优先级顺序（可通过加括号确保运算顺序不出错）<ul><li><code>()</code></li><li><code>!</code> <code>~</code> <code>++</code> <code>--</code></li><li><code>*</code> <code>/</code> <code>%</code></li><li><code>+</code> <code>-</code></li><li><code>&lt;&lt;</code> <code>&gt;&gt;</code> <code>&gt;&gt;&gt;</code></li><li><code>&amp;</code></li><li><code>|</code></li><li><code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code></li></ul></li><li>运算结果应以运算的成员中较高精度的为准，否则编译错误</li><li>强制转换应该考虑溢出的问题</li><li>整型数可以精确表示，浮点数不行</li><li><p>由于浮点数存在运算误差，所以通过判断两个浮点数之差的绝对值是否小于一个很小的数来判断两浮点数是否相等，例如<code>Math.abs(x - 0.1) &lt; 0.00001</code></p></li><li><p>浮点数强转<code>int</code>则舍去小数部分，若超出范围，则赋值为整数最大值</p></li><li>三元运算<code>b ? x : y</code>后面的类型必须相同</li></ul><h4 id="字符和字符串"><a href="#字符和字符串" class="headerlink" title="字符和字符串"></a>字符和字符串</h4><ul><li><p>Java在内存中总是使用Unicode表示字符</p></li><li><p>字符串是不可变的变量，变量名只是对应字符串的引用。基本类型的变量是“持有”某个数值，引用类型的变量是“指向”某个对象。</p></li></ul><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul><li>数组所有元素初始化为默认值，整型都是<code>0</code>，浮点型是<code>0.0</code>，布尔型是<code>false</code>；</li><li>数组一旦创建后，大小就不可改变。</li><li><code>Arrays.toString(list)</code>快速打印一维数组，<code>Arrays.deepToString()</code>打印多维数组</li></ul><h3 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><ul><li>如果我们自定义了一个构造方法，那么，编译器就<strong>不再</strong>自动创建默认构造方法</li><li>可以在无参构造方法的第一行使用<code>this(&quot;Unnamed&quot;);</code>的方式调用含参构造方法</li></ul><h4 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h4><ul><li>Java只允许一个class继承自一个类，因此，一个类有且仅有一个父类。只有<code>Object</code>特殊，它没有父类。</li><li>任何<code>class</code>的构造方法，第一行语句必须是调用父类的构造方法。如果没有明确地调用父类的构造方法，编译器会帮我们自动加一句<code>super();</code></li><li><code>protected</code>允许子类访问父类的字段和方法</li><li>子类<em>不会继承</em>任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的。</li><li><code>instanceof</code>操作符，可以先判断一个实例究竟是不是某种类型</li><li><code>overload</code>重载，指对同一个函数名通过控制参数不同重载为不同函数；方法名相同，并且返回值也相同，就是<code>Override</code>覆写；方法名相同，方法参数相同，但方法返回值不同，也是不同的方法。在Java程序中，出现这种情况，编译器会报错。</li><li><p>Java的实例方法调用是基于运行时的实际类型的动态调用，而非变量的声明类型。虽然声明时使用的是父类，实例化用的子类，调用方法时仍然会使用子类重载后（如果有）的方法。这种运行期才能动态决定调用的子类方法的特性称为<strong>多态</strong>。</p></li><li><p>函数参数中的三点<code>func(int… intList)</code>意为传入参数时可以使用<code>func(a,b,c)</code>去代替<code>func(new int[]{a, b, c})</code>的方式传入。</p></li><li>用<code>final</code>修饰的方法不能被<code>Override</code></li></ul><h4 id="面向抽象编程和接口"><a href="#面向抽象编程和接口" class="headerlink" title="面向抽象编程和接口"></a>面向抽象编程和接口</h4><ul><li><p>通过<code>abstract</code>定义的方法是抽象方法，它只有定义，没有实现。抽象方法定义了子类必须实现的接口规范</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>定义了抽象方法的class必须被定义为抽象类，从抽象类继承的子类必须实现抽象方法</p></li><li><p><code>interface</code>，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是<code>public abstract</code>的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name + <span class="string">" run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>一个<code>interface</code>可以继承自另一个<code>interface</code>。<code>interface</code>继承自<code>interface</code>使用<code>extends</code>，它相当于扩展了接口的方法</p></li><li><p>在接口中，可以定义<code>default</code>方法。实现类可以不必覆写<code>default</code>方法。<code>default</code>方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是<code>default</code>方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。(JDK&gt;=1.8)</p></li></ul><h4 id="静态字段和静态方法"><a href="#静态字段和静态方法" class="headerlink" title="静态字段和静态方法"></a>静态字段和静态方法</h4><ul><li>用<code>static</code>修饰的字段，称为静态字段。静态字段只有一个共享“空间”，所有实例都会共享该字段。使用<code>类名.静态字段</code>的方式访问静态字段。</li><li>使用<code>static</code>修饰类的方法函数则该方法为静态方法</li></ul><h4 id="包"><a href="#包" class="headerlink" title="包"></a>包</h4><ul><li>使用<code>package</code>关键字声明类所在的包名称，如<code>package thomstrong</code></li><li><p>位于同一个包的类，可以访问包作用域的字段和方法。不用<code>public</code>、<code>protected</code>、<code>private</code>修饰的字段和方法就是包作用域。例如，<code>Person</code>和<code>Main</code>在同一个包下，<code>Main</code>中就可以直接<code>new Person()</code>创建实例。</p></li><li><p>如果两个类不在同一个包下，则需要写出完整类名或通过<code>import</code>关键字进行引用</p></li><li><p>编译器查找类名方法</p><ul><li>如果是完整类名，就直接根据完整类名查找这个<code>class</code></li><li><p>如果是简单类名，按下面的顺序依次查找：</p><ul><li>查找当前<code>package</code>是否存在这个<code>class</code></li><li>查找<code>import</code>的包是否包含这个<code>class</code></li><li>查找<code>java.lang</code>包是否包含这个<code>class</code></li></ul></li><li><p>以上均为找到，编译报错</p></li></ul></li><li><p>class的时候，编译器会自动帮我们做两个import动作</p><ul><li>默认自动<code>import</code>当前<code>package</code>的其他<code>class</code></li><li>默认自动<code>import java.lang.*</code></li></ul></li><li><p>当有两个<code>class</code>名称相同时，其中一个可以使用import方法，另外一个只能写完整类名</p></li><li>为了避免名字冲突，我们需要确定唯一的包名。推荐的做法是使用<strong>倒置的域名</strong>来确保唯一性。例如：<ul><li>org.apache</li><li>org.apache.commons.log</li><li>com.liaoxuefeng.sample</li></ul></li></ul><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><ul><li>定义为<code>public</code>的<code>class</code>、<code>interface</code>可以被其他任何类访问</li><li>定义为<code>private</code>的<code>field</code>、<code>method</code>无法被其他类访问</li><li>定义为<code>protected</code>作用于继承关系。定义为<code>protected</code>的字段和方法可以被子类访问，以及子类的子类</li><li><code>package</code>作用域允许访问同一个<code>package</code>的没有<code>public</code>、<code>private</code>修饰的<code>class</code>，以及没有<code>public</code>、<code>protected</code>、<code>private</code>修饰的字段和方法。包没有父子关系，<code>com.apache</code>和<code>com.apache.abc</code>是不同的包</li><li>尽可能把局部变量的作用域缩小，尽可能延后声明局部变量</li><li><code>final</code>可以阻止<code>class</code>被继承、阻止方法被覆写、阻止变量被赋值</li></ul><h4 id="classpath-和-jar"><a href="#classpath-和-jar" class="headerlink" title="classpath 和 jar"></a>classpath 和 jar</h4><ul><li><p><code>classpath</code>是JVM用到的一个环境变量，它用来指示JVM如何搜索class</p></li><li><p>不要把任何Java核心库添加到classpath中，JVM根本不依赖classpath加载核心库</p></li><li><code>MANIFEST.MF</code>文件可以提供jar包的信息，如<code>Main-Class</code>，这样可以直接运行jar包</li><li>JVM自带的标准库rt.jar不要写到classpath中，写了反而会干扰JVM的正常运行</li></ul><h3 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h3><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><blockquote><p><code>String</code>内部是通过一个<code>char[]</code>数组表示的，<code>CharSequence</code>是<code>String</code>的父类</p></blockquote><ul><li><p>Java编译器在编译期，会自动把所有相同的字符串当作一个对象放入常量池，因此相同字符串赋值的变量会指向相同的对象</p></li><li><p>Java的<code>String</code>和<code>char</code>在内存中总是以Unicode编码表示</p></li><li><p>常用函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断字符串相等</span></span><br><span class="line"><span class="string">"hello"</span>.equals(<span class="string">"HELLO"</span>.toLowerCase()); <span class="comment">//true</span></span><br><span class="line"><span class="string">"Hello"</span>.equalsIgnoreCase(<span class="string">"HELLO"</span>); <span class="comment">//true</span></span><br><span class="line"><span class="comment">// 搜索子串</span></span><br><span class="line"><span class="string">"Hello"</span>.indexOf(<span class="string">"l"</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="string">"Hello"</span>.lastIndexOf(<span class="string">"l"</span>); <span class="comment">// 3</span></span><br><span class="line"><span class="string">"Hello"</span>.startsWith(<span class="string">"He"</span>); <span class="comment">// true</span></span><br><span class="line"><span class="string">"Hello"</span>.endsWith(<span class="string">"lo"</span>); <span class="comment">// true  </span></span><br><span class="line"><span class="comment">// 获取子串</span></span><br><span class="line"><span class="string">"Hello"</span>.substring(<span class="number">2</span>); <span class="comment">// "llo"</span></span><br><span class="line"><span class="string">"Hello"</span>.substring(<span class="number">2</span>, <span class="number">4</span>); <span class="string">"ll"</span></span><br><span class="line"><span class="comment">// 去除首位空格</span></span><br><span class="line"><span class="string">"  \tHello\r\n "</span>.trim(); <span class="comment">// "Hello"，去除了英文空格等空白符号</span></span><br><span class="line"><span class="comment">//java 11+</span></span><br><span class="line"><span class="string">"\u3000Hello\u3000"</span>.strip(); <span class="comment">// "Hello"，除了trim的功能还将类似中文的空格字符\u3000也移除</span></span><br><span class="line"><span class="string">" Hello "</span>.stripLeading(); <span class="comment">// "Hello "</span></span><br><span class="line"><span class="string">" Hello "</span>.stripTrailing(); <span class="comment">// " Hello"</span></span><br><span class="line"><span class="comment">// 判空</span></span><br><span class="line"><span class="string">""</span>.isEmpty(); <span class="comment">// true，因为字符串长度为0</span></span><br><span class="line"><span class="string">"  "</span>.isEmpty(); <span class="comment">// false，因为字符串长度不为0</span></span><br><span class="line"><span class="comment">// java 11+</span></span><br><span class="line"><span class="string">"  \n"</span>.isBlank(); <span class="comment">// true，因为只包含空白字符</span></span><br><span class="line"><span class="string">" Hello "</span>.isBlank(); <span class="comment">// false，因为包含非空白字符</span></span><br><span class="line"><span class="comment">// 替换子串</span></span><br><span class="line"><span class="string">"abc"</span>.replace(<span class="string">'a'</span>, <span class="string">'c'</span>); <span class="comment">// cbc</span></span><br><span class="line"><span class="string">"abc"</span>.replace(<span class="string">"ab"</span>, <span class="string">"c"</span>); <span class="comment">// cc</span></span><br><span class="line"><span class="string">"abc"</span>.replaceAll(<span class="string">"[abc]"</span>, <span class="string">"z"</span>); <span class="comment">//zzz</span></span><br><span class="line"><span class="comment">// 分割字符串</span></span><br><span class="line">String s = <span class="string">"A,B,C,D"</span>;</span><br><span class="line">String[] ss = s.split(<span class="string">"\\,"</span>); <span class="comment">// &#123;"A", "B", "C", "D"&#125;</span></span><br><span class="line"><span class="comment">// 字符串拼接</span></span><br><span class="line">String[] arr = &#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>&#125;;</span><br><span class="line">String s = String.join(<span class="string">"***"</span>, arr); <span class="comment">// "A***B***C"</span></span><br><span class="line"><span class="comment">// 类型转换</span></span><br><span class="line">String.valueOf(<span class="number">123</span>); <span class="comment">// "123"</span></span><br><span class="line">Integer.parseInt(<span class="string">"123"</span>); <span class="comment">// 123</span></span><br><span class="line">Integer.parseInt(<span class="string">"ff"</span>, <span class="number">16</span>); <span class="comment">// 按十六进制转换，255</span></span><br><span class="line">Boolean.parseBoolean(<span class="string">"FALSE"</span>); <span class="comment">// false</span></span><br><span class="line"><span class="string">"Hello"</span>.toCharArray();<span class="comment">// String -&gt; char[]</span></span><br><span class="line"><span class="keyword">new</span> String(cs); <span class="comment">// char[] -&gt; String</span></span><br><span class="line"><span class="comment">// 转码</span></span><br><span class="line"><span class="keyword">byte</span>[] b2 = <span class="string">"Hello"</span>.getBytes(<span class="string">"UTF-8"</span>); <span class="comment">// 按UTF-8编码转换</span></span><br><span class="line">String s2 = <span class="keyword">new</span> String(b2, StandardCharsets.UTF_8); <span class="comment">// 按UTF-8转换</span></span><br><span class="line"><span class="keyword">byte</span>[] b2 = <span class="string">"Hello"</span>.getBytes(<span class="string">"GBK"</span>); <span class="comment">// 按GBK编码转换</span></span><br><span class="line">String s1 = <span class="keyword">new</span> String(b2, <span class="string">"GBK"</span>); <span class="comment">// 按GBK转换</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="StringBuilder-StringJoiner"><a href="#StringBuilder-StringJoiner" class="headerlink" title="StringBuilder/ StringJoiner"></a>StringBuilder/ StringJoiner</h4><ul><li><p>使用循环加的方式拼接字符串时，需要频繁的创建新的字符串对象扔掉旧的字符串，浪费内存。因此使用<code>StringBuilder</code>类</p></li><li><p>常用函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    sb.append(<span class="string">','</span>);</span><br><span class="line">    sb.append(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sb.append(<span class="string">"Bob"</span>)</span><br><span class="line">  .append(<span class="string">"!"</span>)</span><br><span class="line">  .insert(<span class="number">0</span>, <span class="string">"Hello, "</span>);</span><br><span class="line"></span><br><span class="line">String s = sb.toString();</span><br><span class="line"></span><br><span class="line">sb.delete(<span class="number">0</span>, <span class="number">2</span>); <span class="comment">// 删除第一和第二个字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用joiner进行高效拼接，String.join()方法即使用stringJoiner实现</span></span><br><span class="line">StringJoiner stringJoiner = <span class="keyword">new</span> StringJoiner(<span class="string">","</span>, <span class="string">"hi~"</span>, <span class="string">"!"</span>); <span class="comment">//StringJoiner(delimiter, [prefix, suffix])</span></span><br><span class="line">stringJoiner.add(<span class="string">"ming"</span>).add(<span class="string">"hong"</span>).add(<span class="string">"gang"</span>);</span><br><span class="line">System.out.println(stringJoiner.toString()); <span class="comment">// hi~ming,hong,gang!</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="枚举类-enum"><a href="#枚举类-enum" class="headerlink" title="枚举类 enum"></a>枚举类 enum</h3><ul><li><p>使用<code>enum</code>关键字来定义枚举类型</p></li><li><p>枚举类型是一个<code>class</code>，不能与非枚举类进行比较或向类型转换</p></li><li><p>枚举类型变量也是引用类型变量，但是可以使用<code>==</code>去判断相等，且可以用在<code>switch</code>语句中</p></li><li><p>枚举类型无法被继承</p></li><li><p>常用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般定义</span></span><br><span class="line"><span class="keyword">enum</span> Weekday &#123;</span><br><span class="line">    SUN, MON, TUE, WED, THU, FRI, SAT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String s = Weekday.SUN.name(); <span class="comment">// "SUN"</span></span><br><span class="line"><span class="keyword">int</span> n = Weekday.MON.ordinal(); <span class="comment">// 返回MON的位置，1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带public方法的定义</span></span><br><span class="line"><span class="keyword">enum</span> Weekday &#123;</span><br><span class="line">    MON(<span class="number">1</span>), TUE(<span class="number">2</span>), WED(<span class="number">3</span>), THU(<span class="number">4</span>), FRI(<span class="number">5</span>), SAT(<span class="number">6</span>), SUN(<span class="number">0</span>); <span class="comment">// 使用下面声明的构造方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> dayValue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Weekday</span><span class="params">(<span class="keyword">int</span> dayValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dayValue = dayValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Weekday day = Weekday.SUN;</span><br><span class="line">System.out.println(day.dayValue); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h3><ul><li><p>基本类型不可赋值为null，而引用类型可以</p></li><li><p>直接把<code>int</code>变为<code>Integer</code>的赋值写法<code>Integer n = 100</code>，称为自动装箱（Auto Boxing），反过来，把<code>Integer</code>变为<code>int</code>的赋值写法<code>int i = n</code>，称为自动拆箱（Auto Unboxing）。自动装箱和自动拆箱只发生在编译阶段，目的是为了少写代码。</p></li><li><p>装箱和拆箱会影响代码的执行效率，因为编译后的<code>class</code>代码是严格区分基本类型和引用类型的。并且，自动拆箱执行时可能会报<code>NullPointerException</code></p></li><li><p>对于<code>Integer</code>对象，若值较小，由于缓存优化的原因，可能会使得 <code>==</code>判断为<code>true</code></p></li></ul><h3 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h3><ul><li>一种特殊的遵循一定编程原则的Java类，它通常用来实现一些比较常用的简单功能，并可以很容易的被重用或者是插入其他应用程序中去</li><li>Bean的编写规范包括Bean类的构造方法、定义属性和访问方法(<code>getter</code>/<code>setter</code>)编写规则</li></ul><h3 id="Java常用工具包"><a href="#Java常用工具包" class="headerlink" title="Java常用工具包"></a>Java常用工具包</h3><ul><li><p>Math：数学计算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.random(); <span class="comment">// 生成[0,1)间的随机数</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>Random：生成伪随机数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random rd = <span class="keyword">new</span> Random(); <span class="comment">// 不指定随机种子，以当前时间戳为种子，得到与运行时间相关的固定随机序列</span></span><br><span class="line">Random rd = <span class="keyword">new</span> Random(<span class="number">1234</span>); <span class="comment">// 指定随机种子，获得固定的随机序列</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>SecureRandom：生成安全的随机数</p><ul><li><p><code>SecureRandom</code>的安全性是通过操作系统提供的安全的随机种子来生成随机数。这个种子是通过CPU的热噪声、读写磁盘的字节、网络流量等各种随机事件产生的“熵”</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SecureRandom sr = <span class="keyword">new</span> SecureRandom();</span><br><span class="line">System.out.println(sr.nextInt(<span class="number">100</span>));</span><br><span class="line">SecureRandom.getInstanceStrong(); <span class="comment">// 获取高强度安全随机数生成器</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><ul><li><code>Throwable</code>是异常体系的根，它继承自<code>Object</code>。<code>Throwable</code>有两个体系：<code>Error</code>和<code>Exception</code>，<code>Error</code>表示严重的错误，程序对此一般无能为力</li></ul><ul><li>必须捕获的异常或者用<code>throws</code>声明，包括<code>Exception</code>及其子类，但不包括<code>RuntimeException</code>及其子类，这种类型的异常称为Checked Exception。</li><li>不需要捕获的异常，包括<code>Error</code>及其子类，<code>RuntimeException</code>及其子类。</li><li>可以用<code>try ... catch</code>捕获。把可能发生异常的语句放在<code>try { ... }</code>中，然后使用<code>catch</code>捕获对应的<code>Exception</code>及其子类。多个<code>catch</code>语句只有一个能被执行，因此编写代码时需要考虑好<code>catch</code>的顺序，将子类写在前面，父类写在后面。</li><li><code>finally</code>语句不是必须的，可写可不写；<code>finally</code>总是最后执行且无论是否发生异常，因此有<code>finally</code>存在<code>return</code>将以<code>finally</code>中的return为准。</li><li>当<code>catch</code>和<code>finally</code>都抛出了异常时，<code>catch</code>中的异常将会被屏蔽掉</li><li>通过<code>printStackTrace()</code>可以打印出方法的调用栈</li><li><code>BaseException</code>需要从一个适合的<code>Exception</code>派生，通常建议从<code>RuntimeException</code>派生</li><li>要执行<code>assert</code>语句，必须给Java虚拟机传递<code>-enableassertions</code>（可简写为<code>-ea</code>）参数启用断言。断言只应该用于开发和测试阶段。多数时候用在单元测试中。</li><li><code>Logger logger = Logger.getGlobal();</code>可以使用这样的方式声明java jdk 自带的logger，但是大多情况下不使用使用这种方法，更多使用<code>Log4j</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;blockquote&gt;
&lt;p&gt;参考&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/1252599548343744&quot; target=&quot;_bla
      
    
    </summary>
    
      <category term="技术" scheme="https://thomstrong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="https://thomstrong.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>2019猿辅导服务器端日常实习面经</title>
    <link href="https://thomstrong.github.io/2019/07/12/yuanfudao/"/>
    <id>https://thomstrong.github.io/2019/07/12/yuanfudao/</id>
    <published>2019-07-12T01:18:49.000Z</published>
    <updated>2019-07-15T03:02:08.363Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><blockquote><p>整体分为两面，</p><p>一面面试官是张梦南（之前没有关注最强大脑，后来才听说），主要基础知识和项目中基础知识的介绍，一道算法题；</p><p>二面面试官中年，感觉资历更老一些，主要问项目，一道算法题</p><p>整体氛围感觉还是很轻松的，答不上来的也都会简单提示然后最后会给出答案。</p></blockquote><h3 id="写在最前面"><a href="#写在最前面" class="headerlink" title="写在最前面"></a>写在最前面</h3><p>整体感受非常nice，对接的hr很照顾面试人的感受，因为怕迟到，早去了一小时左右，但hr很贴心的一直在考虑我这边等待时间太长，帮我提前找了面试官。公司没有仔细参观，但是整体环境感觉挺不错。</p><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><blockquote><p>发挥的比较不好，面试复习过的内容面试过程中大部分都想不起来或者很费劲才想起来，可能就是死记硬背带来的问题吧…</p></blockquote><ul><li><p>首先自我介绍，然后讲到简历中的实习经历，就顺着问了一些里面的具体内容</p></li><li><p>为什么想做后端？</p></li><li><p>数据库事务的隔离级别</p></li><li><p>数据库事务的ACID特性</p></li><li><p>写mysql语句</p><ul><li><p>1.查询user表中男性和女性年龄最大的两个人的名字 2.如何提高查询速度？</p><blockquote><p>select name from account where (sex, age) in (select sex,max(age) from account group by sex);</p><ul><li><p>这里给的一个参考答案，面试的时候写的是错的，但是可能大概意思是对的吧…因为太久没有直接写sql语句了，基本都是由框架提供的方法函数完成</p></li><li><p>提高效率上，考虑到group by方法，我提出了在sex上建索引的方式，但实际上因为性别只有两个，创建索引能够带来的收益也不是很大，甚至会变慢</p></li></ul></blockquote></li><li><p>查询年龄大于50岁的所有男性 2.如何提高查询速度</p><blockquote><p>select * from account where sex=’男’ and age&gt;50;</p><ul><li>这个sql比较简单，但是提高查询速度上还是需要进一步理解索引的适用场景。这里我回答的是在sex和age上建立复合索引，sex先，age后</li></ul></blockquote></li></ul></li><li><p>对NoSQL有了解么，为什么（有一个实习经历里）用了mongodb而不是用关系型数据库？</p><blockquote><p>回答是可能存在有些数据没有某些字段的情况（被反驳可以在那些字段使用null）和需要存储数据等类json结构的数据，只从表层上回答了一些不是最关键的原因。最后小声bb了个分布式存储，因为对当时数据库的选择原因的确没有多问，只是跟着做而已…</p><p><a href="https://thomstrong.github.io/2019/07/02/SQL-vs-NoSQL/#more">SQL vs NoSQL</a> </p></blockquote></li><li><p>对java了解多少，我们的后端主要是java开发</p><blockquote><p>简单的应用吧，能够照着原有代码学习，之后的想法也是转java</p></blockquote></li><li><p>…（基础和项目的问题大概就记得这么多吧）</p></li><li><p>算法题</p><blockquote><p>基础答得很不好很不顺利，到这里看着题面比较简单，有些急于表现自己，但是过程中有些迷茫的地方老是绕不过去，但是面试官很耐心的在引导。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">描述：给一个二叉树，然后给一个想要删除的节点值的list，从中删除这些节点。当被删除节点有孩子时，左右孩子分别变为根，返回删除过后所有的根节点</span><br><span class="line">示例：树</span><br><span class="line">        1</span><br><span class="line">     2     3</span><br><span class="line">   4      5  6     待删除节点[1,3]，返回节点[2,5,6]</span><br><span class="line">   </span><br><span class="line">思路：</span><br><span class="line">1. 递归，删除左子树中的所有待删节点，删除右子树中待删节点</span><br><span class="line">2. 讨论根节点，</span><br><span class="line">1）若根节点需要删除，则直接返回左子树根序列+右子树根序列</span><br><span class="line">2）若根节点不需要删除，分别查看左右子树处理后的根序列，</span><br><span class="line">2.1）如果没有左孩子，将左孩子置空</span><br><span class="line">2.2）如果没有右孩子，将右孩子置空</span><br><span class="line">    3.3）将根插入结果集返回</span><br></pre></td></tr></table></figure></li></ul><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><blockquote><p>相对顺利一些，之前的项目经历讲的顺利一些，算法题是一道很常规题，发挥正常</p></blockquote><ul><li>首先介绍一下自己之前的项目</li><li>在xxx线上实习中大概用多少时间在实习上？</li><li>你认为在xxx项目中，比较可能造成访问速度瓶颈的地方是什么</li><li>对于请求的瓶颈你是如何处理优化的</li><li><p>在数据请求上有没有做缓存之类的？什么场景下需要进行缓存？</p></li><li><p>（针对简历中提到的java spring）你对java spring 的了解，（建立中体现更多接触的是python语言）和对python一些框架的对比</p></li><li><p>…（项目相关问题到这里）</p></li><li><p>算法题</p><blockquote><p>一道算法与数据结构考试题，很基础</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">描述：根据二叉树的先序遍历和中序遍历，推导二叉树原始结构</span><br><span class="line">思路：先序遍历的第一个为树根，找到中序遍历对应的根后，左边的是左子树元素，右边是右子树元素，依次递归即可。</span><br></pre></td></tr></table></figure></li></ul><h3 id="hr面"><a href="#hr面" class="headerlink" title="hr面"></a>hr面</h3><ul><li>在先前的公司都是干什么工作</li><li>先前公司大概规模是多大？主要是做些什么？</li><li>一个产品对几个开发？</li><li>一周几天，入职时间等等常规问题</li></ul><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>欢迎发送简历到<a href="mailto:thomstrong.1996@gmail.com" target="_blank" rel="noopener">邮箱</a>内推</p><p>jd见：<a href="http://hr.yuanfudao.com/#/jobs?location=北京市&amp;_k=np0baw" target="_blank" rel="noopener">职位描述</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;blockquote&gt;
&lt;p&gt;整体分为两面，&lt;/p&gt;
&lt;p&gt;一面面试官是张梦南（之前没有关注最强大脑，后来才听说），主要基础知识和项目中基础知识的介绍，一道算法题；&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="技术" scheme="https://thomstrong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面经" scheme="https://thomstrong.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="https://thomstrong.github.io/2019/07/10/sort-algorithm/"/>
    <id>https://thomstrong.github.io/2019/07/10/sort-algorithm/</id>
    <published>2019-07-09T16:18:50.000Z</published>
    <updated>2020-03-26T17:48:59.530Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><blockquote><p>参考<a href="https://blog.csdn.net/justloveyou_/article/details/72730597" target="_blank" rel="noopener">博文 </a>/ 图片来自<a href="https://mp.weixin.qq.com/s/Qf416rfT4pwURpW3aDHuCg" target="_blank" rel="noopener">微信推送文章</a></p></blockquote><h3 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h3><ul><li>稳定性：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的<strong>相对次序保持不变</strong>，即在原序列中，<code>r[i] == r[j]</code>，且<code>r[i]</code>在<code>r[j]</code>之前，而在排序后的序列中，<code>r[i]</code>仍在<code>r[j]</code>之前，则称这种排序算法是稳定的；否则称为不稳定的</li><li>时间复杂度：排序过程中对单个数据的访问总次数</li><li>空间复杂度：排序过程中需要辅助的存储空间</li><li>内部排序/外部排序：排序过程中数据元素是否完全在内存</li></ul><h3 id="结论最前"><a href="#结论最前" class="headerlink" title="结论最前"></a>结论最前</h3><p><img src="/images/sort_summary.png" alt="排序算法总结"></p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><ul><li><p>算法：将第i个元素插入到前i-1个元素中适当的位置(选择插入位置时，因为前面元素已经有序，可以使用折半查找的方法)</p><blockquote><p>可以考虑扑克牌的排序，抽取后面的牌插入到前面有序的牌中</p></blockquote></li><li><p>性能分析：时间O(n^2^)，空间O(1)，稳定</p></li><li><p>图解</p><p><img src="/images/insert_sort.gif" alt="直接插入排序"></p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">    j = i - <span class="number">1</span></span><br><span class="line">    chosen_num = nums[i]</span><br><span class="line">    <span class="keyword">while</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">      <span class="keyword">if</span> nums[j] &gt; chosen_num:</span><br><span class="line">        nums[j + <span class="number">1</span>] = nums[j]</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      j -= <span class="number">1</span></span><br><span class="line">  nums[j + <span class="number">1</span>] = chosen_num</span><br></pre></td></tr></table></figure></li></ul><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><ul><li><p>算法</p><ul><li>首先设定以<code>gap</code>为距离对序列进行分组，对每个分组进行插入排序</li><li>缩小<code>gap</code>（一般缩小为上次的1/2～1/3附近）重新排序，循环，直到<code>gap</code>缩小为1</li><li><code>gap</code>为1的时候即为一次直接插入排序遍历</li></ul></li><li><p>性能分析：时间O(n^1.3~2^)，空间O(1)，不稳定</p></li><li><p>图解</p><p><img src="/images/shell_sort.gif" alt="希尔排序"></p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def shell_sort(nums) &#123;</span><br><span class="line">length = len(nums)</span><br><span class="line">    //区间</span><br><span class="line">  gap = <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> gap &lt; length:</span><br><span class="line">  gap = gap * <span class="number">3</span> + <span class="number">1</span> <span class="comment"># 确保gap最终能够是1</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(gap, length):</span><br><span class="line">    chosen_num = nums[i]</span><br><span class="line">    j = i - gap</span><br><span class="line">    //跨区间排序</span><br><span class="line">    <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> arr[j] &gt; tmp:</span><br><span class="line">  nums[j + gap] = nums[j]</span><br><span class="line">      j -= gap</span><br><span class="line">    nums[j + gap] = chosen_num</span><br><span class="line">  gap = gap / <span class="number">3</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h4><ul><li><p>算法：每次从待排序列中选择最小元素与待排序列首个元素交换后剔除首个元素，直到待排序列为空</p></li><li><p>性能分析：时间O(n^2^)，空间O(1)，不稳定</p></li><li><p>图解</p><p><img src="/images/select_sort.gif" alt="直接选择排序"></p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">    min_index = i</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(nums)):</span><br><span class="line">      <span class="keyword">if</span> nums[j] &lt; nums[min_index]:</span><br><span class="line">        min_index = j</span><br><span class="line">    nums[i], nums[min_index] = nums[min_index], nums[i]</span><br></pre></td></tr></table></figure></li></ul><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><blockquote><p>堆：这里的堆指的是由完全二叉树实现的二叉堆</p></blockquote><ul><li><p>算法：首先将所给元素排成大顶堆，然后每次取根节点，然后进行删除调整大顶堆，由此得到顺序序列</p></li><li><p>性能分析：时间O(nlogn)，空间O(1)，不稳定</p></li><li><p>图解</p><p><img src="/images/heap_sort.gif" alt="堆排序"></p></li><li><p>代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// golang</span></span><br><span class="line"><span class="comment">// 堆插入，生成大根堆结构</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HeapInsert</span><span class="params">(nums []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">childIndex := i</span><br><span class="line">parentIndex := (childIndex - <span class="number">1</span>) &gt;&gt; <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> childIndex &gt; <span class="number">0</span> &amp;&amp; nums[parentIndex] &lt; nums[childIndex] &#123; <span class="comment">// O(logN)</span></span><br><span class="line">nums[parentIndex], nums[childIndex] = nums[childIndex], nums[parentIndex]</span><br><span class="line">childIndex = parentIndex</span><br><span class="line">parentIndex = (childIndex - <span class="number">1</span>) &gt;&gt; <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 堆调整，将大根冒泡</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HeapAdjust</span><span class="params">(nums []<span class="keyword">int</span>, to <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> to == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">cur := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">leftChildI := cur&lt;&lt;<span class="number">1</span> + <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> leftChildI &gt; to &#123; <span class="comment">// nums[to] is the max num</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">rightChildI := leftChildI + <span class="number">1</span></span><br><span class="line">tobeChildI := leftChildI</span><br><span class="line"><span class="keyword">if</span> rightChildI &lt; to &amp;&amp; nums[rightChildI] &gt; nums[leftChildI] &#123;</span><br><span class="line">tobeChildI = rightChildI</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> nums[cur] &lt; nums[tobeChildI] &#123;</span><br><span class="line">nums[cur], nums[tobeChildI] = nums[tobeChildI], nums[cur]</span><br><span class="line">cur = tobeChildI</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HeapSort</span><span class="params">(nums []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">HeapInsert(nums)</span><br><span class="line"><span class="keyword">for</span> i := <span class="built_in">len</span>(nums) - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">nums[<span class="number">0</span>], nums[i] = nums[i], nums[<span class="number">0</span>]</span><br><span class="line">HeapAdjust(nums, i<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><ul><li><p>算法：通过从后往前的交换，将较小元素交换到待排序列最前端，每次“冒泡”可确定一个最小元素的位置</p></li><li><p>性能分析：时间O(n^2^)，空间O(1)，稳定</p></li><li><p>图解</p><p><img src="/images/bubble_sort.gif" alt="冒泡排序"></p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">  n = len(nums)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    j = n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j &gt; i:</span><br><span class="line">      <span class="keyword">if</span> nums[j] &lt; nums[j - <span class="number">1</span>]:</span><br><span class="line">        nums[j], nums[j - <span class="number">1</span>] = nums[j - <span class="number">1</span>], nums[j]</span><br><span class="line">      j -= <span class="number">1</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><ul><li><p>算法</p><ul><li>核心思想为分治法，从序列中选出一个基准值，其他依次和基准做比较，比基准大的放右边，小的放左边</li><li>然后分别对左右两边再次使用快速排序</li><li>单边扫描<ul><li>我们随意抽取一个数作为基准值，同时设定一个标记 mark 代表左边序列最右侧的下标位置，当然初始为 0 </li><li>接下来遍历数组，如果元素大于基准值，无操作，继续遍历，如果元素小于基准值，则把 mark + 1 ，再将 mark 所在位置的元素和遍历到的元素交换位置</li><li>mark 这个位置存储的是比基准值小的数据的最后一个，当遍历结束后，将基准值与 mark 所在元素交换位置即可</li></ul></li></ul></li><li><p>性能分析：时间O(nlogn)，空间O(logn)，不稳定</p></li><li><p>图解</p><p><img src="/images/quick_sort.gif" alt="快速排序"></p></li><li><p>代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 划分，将数组划分为大于基准值，等于基准值，小于基准值三个部分</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(nums []<span class="keyword">int</span>, from, to <span class="keyword">int</span>)</span> <span class="params">(midl, midr <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">left := from - <span class="number">1</span></span><br><span class="line">right := to</span><br><span class="line">cur := from</span><br><span class="line"><span class="keyword">for</span> cur &lt; right &#123;</span><br><span class="line"><span class="keyword">if</span> nums[cur] &lt; nums[to] &#123;</span><br><span class="line">nums[cur], nums[left+<span class="number">1</span>] = nums[left+<span class="number">1</span>], nums[cur]</span><br><span class="line">left += <span class="number">1</span></span><br><span class="line">cur += <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[cur] &gt; nums[to] &#123;</span><br><span class="line">nums[cur], nums[right<span class="number">-1</span>] = nums[right<span class="number">-1</span>], nums[cur]</span><br><span class="line">right -= <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cur += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">nums[to], nums[right] = nums[right], nums[to]</span><br><span class="line">right += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> left + <span class="number">1</span>, right - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 随机基准值快排</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">QuickSort</span><span class="params">(nums []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line">pivot := rand.Int63n(<span class="keyword">int64</span>(<span class="built_in">len</span>(nums)))</span><br><span class="line">nums[pivot], nums[<span class="built_in">len</span>(nums)<span class="number">-1</span>] = nums[<span class="built_in">len</span>(nums)<span class="number">-1</span>], nums[pivot]</span><br><span class="line">quickSort(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 快排递归结构</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSort</span><span class="params">(nums []<span class="keyword">int</span>, from, to <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> from &gt;= to &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">midLeft, midRight := partition(nums, from, to)</span><br><span class="line">quickSort(nums, from, midLeft<span class="number">-1</span>)</span><br><span class="line">quickSort(nums, midRight+<span class="number">1</span>, to)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><ul><li><p>算法：将待排序列分为两部分，对左右两部分分别进行归并排序，然后将两个有序序列合并为一个有序序列</p></li><li><p>性能分析：时间O(nlogn)，空间O(n)，稳定</p></li><li><p>图解</p><p><img src="/images/merge_sort.gif" alt="归并排序"></p></li><li><p>代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// golang</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(nums1, nums2 []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">i, j := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">res := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="built_in">len</span>(nums1)+<span class="built_in">len</span>(nums2))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i &lt; <span class="built_in">len</span>(nums1) &amp;&amp; j &lt; <span class="built_in">len</span>(nums2) &#123;</span><br><span class="line"><span class="keyword">if</span> nums1[i] &lt; nums2[j] &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, nums1[i])</span><br><span class="line">i++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, nums2[j])</span><br><span class="line">j++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> i &lt; <span class="built_in">len</span>(nums1) &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, nums1[i:]...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> j &lt; <span class="built_in">len</span>(nums2) &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, nums2[j:]...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MergeSort</span><span class="params">(nums []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br><span class="line">mid := <span class="built_in">len</span>(nums) / <span class="number">2</span></span><br><span class="line">leftPart := MergeSort(nums[:mid])</span><br><span class="line">rightPart := MergeSort(nums[mid:])</span><br><span class="line"><span class="keyword">return</span> merge(leftPart, rightPart)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="分类排序"><a href="#分类排序" class="headerlink" title="分类排序"></a>分类排序</h3><h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><ul><li><p>算法：对于待排序列首先选择其最大和最小值，创建一个计数区，计算在最大和最小值之间所有数字出现的次数，最后以计数桶顺序还原有序序列</p></li><li><p>性能分析：时间O(n)，空间O(max-min)，不稳定</p></li><li><p>图解</p><p><img src="/images/count_sort.gif" alt="计数排序"></p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># todo</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><ul><li><p>算法</p><ul><li>将要排的数据分到多个有序的桶里</li><li>每个桶里的数据再单独排序，再把每个桶的数据依次取出，即可完成排序</li></ul></li><li><p>性能分析：时间根据桶的粒度会有不同变化，空间：桶的数目</p></li><li><p>图解</p><p><img src="/images/bucket_sort.gif" alt="桶排序"></p></li></ul><h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><ul><li><p>算法</p><ul><li>按照位数，分别对每位进行比较，放入对应的桶内，然后将桶内元素以先进先出的方式按桶序取出</li><li>如此经过d次（d为最大位数）排序后即可得到顺序</li><li>本算法需要待排序列有基数，并且基数可排序</li></ul></li><li><p>性能分析：时间：O(d*n)，空间O(d*n)，稳定</p></li><li><p>图解</p><p><img src="/images/base_sort.gif" alt="基数排序"></p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># todo</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;blockquote&gt;
&lt;p&gt;参考&lt;a href=&quot;https://blog.csdn.net/justloveyou_/article/details/72730597&quot; ta
      
    
    </summary>
    
      <category term="技术" scheme="https://thomstrong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="算法" scheme="https://thomstrong.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>操作系统知识点</title>
    <link href="https://thomstrong.github.io/2019/07/07/Operation-System/"/>
    <id>https://thomstrong.github.io/2019/07/07/Operation-System/</id>
    <published>2019-07-07T08:02:41.000Z</published>
    <updated>2019-07-15T03:01:53.030Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><blockquote><p>参考<a href="https://blog.csdn.net/justloveyou_/article/details/78304294" target="_blank" rel="noopener">博客</a></p></blockquote><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><ul><li>进程是对运行时程序的封装，是系统进行资源调度和分配的基本单位，实现操作系统并发</li><li><p>线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性（对并发的用户操作做出实时响应），实现进程内部并发</p></li><li><p>一个程序至少有一个进程，一个进程至少有一个线程，线程依赖于进程</p></li><li><p>进程在执行过程中有独立的内存单元，而多个线程共享进程的内存</p></li><li><p>多线程优势</p><ul><li>解耦合，简化程序开发：将不同种类任务分配专门线程，形成串行假象</li><li>提高资源利用率：对于多CPU来说，多个线程可以调度到多个CPU上运行，提高系统吞吐率</li></ul></li><li><p>多线程风险</p><ul><li>安全问题：当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么这个类就是线程安全的</li><li>活跃性问题：死锁、饥饿</li><li>性能问题：吞吐率过低、资源消耗过高。当线程调度器临时挂起活跃线程并转而运行另一个线程时，就会频繁出现上下文切换操作(Context Switch)，这种操作会导致 CPU 时间更多的花在线程调度上而非线程的运行上。</li></ul></li></ul><h3 id="进程间通信-IPC"><a href="#进程间通信-IPC" class="headerlink" title="进程间通信 IPC"></a>进程间通信 IPC</h3><ul><li>管道及命名管道<ul><li>管道：半双工通信方式，数据只能单向流动（父进程关闭fd[0]，子进程关闭fd[1]，父进程写，子进程读），且只能在具有亲缘关系（父子进程）的进程间使用。</li><li>高级管道：将另一个程序当作一个新的进程在当前程序进程中启动，则它算是当前程序的子进程</li><li>命名管道 (named pipe) ：命名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</li><li>消息队列：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li><li>信号量通信：计数器，控制多个程序共享资源的访问</li><li>信号：通知接收进程某个事件已经发生</li><li>共享内存：最快的通信方式，映射一段能被其他进程访问的内存，由一个进程创建，多个进程访问。通常与信号量配合使用，来实现进程间的同步和通信</li><li>套接字 (socket)：可用于不同机器间的进程通信，可简单归纳为命名、绑定、监听、连接、数据交互、断开连接这几个步骤</li></ul></li></ul><h3 id="线程同步方式"><a href="#线程同步方式" class="headerlink" title="线程同步方式"></a>线程同步方式</h3><ul><li>互斥锁 mutex：通过对共享资源进行加锁和解锁的操作，标记资源是否可用，无锁资源阻塞，知道互斥量被解锁</li><li>条件变量：自动阻塞某个线程，直到特殊情况发生为止。条件变量通常和互斥锁一起使用。条件变量使线程可以睡眠等待某种条件出现。条件变量是利用线程间共享的全局变量进行同步的机制，包括“等待条件成立而挂起”和“另一个线程使条件成立”两个动作。</li><li>信号量 sem：同一时刻允许多个线程访问同一资源，但是通过信号量控制最大线程数量，通过一个整型S和一个队列表现<ul><li>PV操作：不可被打断的操作系统原语，P检查信号量是否可用，V释放信号量，主要用于完成互斥控制和同步</li></ul></li></ul><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul><li>在两个或者多个<strong>并发</strong>进程中，进程间产生了互相等待对方资源释放的情况。通俗的讲，就是两个或多个进程无限期的阻塞、相互等待的一种状态。</li></ul><h4 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h4><ul><li>互斥：至少有一个资源一次只能有一个进程使用</li><li><p>占有并等待：进程至少占有一个资源，且正在等待另一个被占有的资源释放</p></li><li><p>非抢占：资源不能被抢占，只能等到占有者完成当前任务后才能占有</p></li><li>循环等待：若干进程间形成头尾相接的环形资源等待关系</li></ul><h4 id="处理策略"><a href="#处理策略" class="headerlink" title="处理策略"></a>处理策略</h4><blockquote><p> 预防死锁、避免死锁、检测死锁、解除死锁 、鸵鸟策略</p></blockquote><ul><li>预防死锁：确保四个必要条件至少有一个不成立就能预防死锁发生<ul><li>打破互斥条件：资源的互斥与否经常是由其本身决定的，因此通常不适用这种办法</li><li>打破占有并等待：预先占有所有资源，若不能完全占有则暂时挂起不执行，但是资源往往是动态分配的，不可预知，而且这样的策略会大大降低资源利用率和并发性</li><li>打破非抢占条件：进程在申请新资源得不到满足时，必须释放当前占有资源，以供给其他进程使用。实现起来较为困难，且降低了系统性能</li><li>打破循环等待：实行资源有序分配，对所有资源排序编号，只有在申请到小号资源的情况下才能申请大号的资源，这样就避免了环路的产生，预防死锁</li></ul></li><li>死锁避免<ul><li>进程启动拒绝：如果进程的请求会导致死锁，则不启动进程</li><li>资源分配拒绝：如果进程增加的资源请求会导致死锁，则不允许分配</li><li>安全状态：系统能按照某种进程顺序，为每个进程分配资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利完成</li><li>银行家算法：根据当前资源分配状态，试探性分配所需资源后，检查系统是否仍处于安全状态，是则分配，否则撤销试探性分配，令进程等待</li></ul></li><li><p>死锁检测：资源分配图</p></li><li><p>死锁解除</p><ul><li>资源抢占：从一个或多个死锁进程那里抢占一个或多个资源，此处需要避免饥饿问题（某个进程总是被抢占资源导致无法继续）</li><li>终止进程：一次性终止所有死锁进程或逐个终止死锁进程直至死锁解除</li></ul></li></ul><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><ul><li>就绪状态：获得处理机以外所有所需资源，等待分配处理机资源</li><li>运行状态：占用处理机资源运行，处于此状态的进程数要小于CPU数</li><li>阻塞状态：进程等待某种条件，在满足前无法执行</li><li>状态转换<ul><li>就绪-&gt;运行：进程调度程序为就绪进程分配了处理机</li><li>执行-&gt;就绪：进程分配的时间片用完</li><li>执行-&gt;阻塞：进程等待某种事件发生（IO请求等）无法继续执行，编程阻塞状态</li><li>阻塞-&gt;就绪：所等待的事件已经发生，变成就绪状态</li></ul></li></ul><p><img src="/images/process_status.jpg" alt="进程状态"></p><h3 id="Python中的多线程"><a href="#Python中的多线程" class="headerlink" title="Python中的多线程"></a>Python中的多线程</h3><ul><li><p>Python多线程编程<strong>常用threading模块</strong>。启动一个多线程需要创建一个Thread对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t = Thread(target=countdown, args=(<span class="number">10</span>,), daemon=<span class="literal">True</span>)  <span class="comment"># 后台线程</span></span><br><span class="line">t.start()　     <span class="comment"># 启动线程</span></span><br><span class="line">t.is_alive()    <span class="comment"># 查询线程对象的状态，返回布尔值</span></span><br><span class="line">t.join()        <span class="comment"># 将线程加入到当前线程，并等待其终止</span></span><br></pre></td></tr></table></figure></li><li><p>GIL是CPython特性，同一时刻只能运行一个线程，不能利用多核资源。Cpython的多线程适用于I/O密集型问题，计算密集型问题可使用<strong>多进程</strong>编程。</p></li><li>线程同步原语有Event / Condition / Semaphore / Barrier。<strong>Event用于常用语通知全部线程，condition和Semapher常用于通知一定数量的线程， Barrier用于多个线程必须完成某些步骤再一起执行。</strong>Lock / Rlock / Event / Condition / Semaphore <strong>支持上下文管理协议</strong>（with语句，好用）。</li><li>线程间通信可以用queue模块中的Queue队列，<strong>get()和put()已加锁，是线程安全的</strong></li></ul><h3 id="进程调度策略"><a href="#进程调度策略" class="headerlink" title="进程调度策略"></a>进程调度策略</h3><ul><li>FCFS 先来先服务：先请求CPU的进程先分配CPU</li><li>SJF 最短作业优先调度：从备选作业队列中选出一个或若干个估计运行时间最短的作业优先调度，一直运行至结束或因发生事件阻塞放弃处理机</li><li>FPF 高优先权优先调度：照顾优先级较高的作业优先调度。<ul><li>抢占式：当有优先级更高的进程出现时，停止当前进程，将处理机分配给优先级更高进程。适合对性能要求较高的批处理和分时系统</li><li>非抢占式：当进程占有处理机时，只能运行至结束或因发生事件阻塞放弃处理机。用于某些对实时性要求不严的实时系统</li><li>优先级倒置问题：由于一个高优先级和一个低优先级进程之间的相互等待资源的情况，导致中优先级抢先于高优先级进程运行。<ul><li>解决办法<ul><li>设置优先级上限：为临界区设置一个优先级上限，企图进入临界区的进程优先级需要低于这个上限</li><li>优先级继承：当高优先级进程等待低优先级进程资源时，低优先级进程暂时继承高优先级进程优先级，直到资源被释放后恢复低优先级</li><li>临界区禁止中断：系统优先级分为可抢占优先级和中断禁止优先级，将运行于临界区的进程通过中断禁止保护起来，防止在访问互斥数据时被高优先级任务抢占处理机</li></ul></li></ul></li></ul></li><li>高响应比优先调度：响应比 = （等待时间 + 服务时间）/ 服务时间，对长作业的运行得不到保证，但是避免了最短作业优先调度中长作业饥饿的问题。在调度之前需要计算响应比，增加系统开销</li><li>时间片轮转法<ul><li>将所有就绪进程按照原先的服务原则排成一个队列，每次调度时，把CPU分配给队首进程，并执行一个时间片</li><li>时间片用完，计时器发出中断请求，调度程序把进程送到就绪队列队尾，然后将处理机分配给就绪队列队首进程</li><li>由此循环，系统能够在给定时间内响应所有用户的请求</li></ul></li><li>多级反馈队列：多级反馈队列对长短进程均有照顾，可满足各种类型进程的需要<ul><li>设置一个优先级从高到低的n个队列，优先级越高，时间片约短</li><li>当有新进程进入时，放入最高优先级队列，在一个时间片内，若执行完成，则跳出队列；若不能执行完成，放入下一级队列队尾</li><li>只有当前面i-1个队列为空时，才能执行第i个队列；若在第i个队列的一个时间片内不能执行完成，则落入i+1队列队尾；第n个队列使用时间片轮转法进行调度</li><li>当有新进程需要调度时，立即把正在运行的进程放回当前队列的队尾，然后把处理机分给高优先级进程。当再度运行到当前队列的该进程时，仅分配上次还未完成的时间片，不再分配该队列对应的完整时间片。</li></ul></li></ul><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><ul><li>FIFO先进先出：按照队列顺序，先进先出</li><li>LRU 最近最少使用：按照最近一次的使用时间</li><li>LFU 最少使用：按照截至目前使用的总次数</li><li>OPT 最优置换：理论的最优，理论；就是要保证置换出去的是不再被使用的页，或者是在实际内存中最晚使用的算法</li></ul><h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><ul><li>时间上的局部性：最近被访问的页在不久的将来还会被访问；</li><li>空间上的局部性：内存中被访问的页周围的页也很可能被访问。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;blockquote&gt;
&lt;p&gt;参考&lt;a href=&quot;https://blog.csdn.net/justloveyou_/article/details/78304294&quot; ta
      
    
    </summary>
    
      <category term="技术" scheme="https://thomstrong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="OS" scheme="https://thomstrong.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>Mysql数据库</title>
    <link href="https://thomstrong.github.io/2019/07/04/Mysql-Database/"/>
    <id>https://thomstrong.github.io/2019/07/04/Mysql-Database/</id>
    <published>2019-07-04T15:23:24.000Z</published>
    <updated>2019-07-15T03:01:36.662Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><blockquote><p>关系型数据库——MySQL部分概念</p></blockquote><h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><blockquote><p>个人感觉很像是用SQL语句封装出的函数</p></blockquote><ul><li>一些预编译的SQL语句，执行效率较高</li><li>在一定程度上保障数据安全</li></ul><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。</p><ul><li>只暴露部分字段给访问者，所以就建一个虚表，就是视图。</li><li>查询的数据来源于不同的表，而查询者希望以统一的方式查询，这样也可以建立一个视图，把多个表查询结果联合起来，查询者只需要直接从视图中获取数据，不必考虑数据来源于不同表所带来的差异</li></ul><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><ul><li>是对数据库表中一个或多个列的值进行排序的结构，帮助提高数据访问速度的数据库对象</li><li>索引加快了检索速度，但是降低了插入、删除、更新等维护任务的速度，大部分的更新操作同时需要更新索引</li><li>索引可以避免全表扫描，多数查询可仅扫描少量索引页及数据页</li><li>对于非聚集索引，有些查询甚至可以不访问数据页</li><li>聚集索引可以避免数据插入操作集中于表的最后一个数据页</li><li>某些情况下索引还可以避免排序操作</li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>大大加快检索速度;</li><li>创建唯一性索引，保证数据库表中每一行数据的唯一性;</li><li>加速表和表之间的连接;</li><li>在使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间。<ul><li>大大减少服务器需要扫描的数据量</li><li>帮助服务器避免排序和临时表</li><li>将所及I/O变为顺序I/O</li></ul></li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>索引需要占用数据表以外的物理存储空间</li><li>创建索引和维护索引要花费一定的时间</li><li>当对表进行更新操作时，索引需要被重建，这样降低了数据的维护速度。</li></ul><h4 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h4><ul><li>一条索引记录中包含的基本信息包括：键值（即你定义索引时指定的所有字段的值）+逻辑指针（指向数据页或者另一索引页）</li><li>当为空表创建索引时，数据库系统将分配一个索引页，在插入前保持空状态；当有数据插入时加入一行索引记录；当根结点满时，进行分裂：<ul><li>创建两个儿子节点</li><li>将当前根结点近似分为两半，分别写入儿子节点</li><li>将根结点加上指针指向新的两个儿子节点</li></ul></li><li>数据被删除导致索引中只包含一条索引记录时，该记录可能会被移至临近的索引页中，索引合并</li></ul><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>聚集索引：索引的逻辑顺序和数据的物理存储顺序相同<ul><li>应用场景：列经常被分组排序/搜索范围数据/主键列/外键列/仅有小数目的不同值</li><li>每个表中只能有一个聚集索引</li></ul></li><li>非聚集索引：索引的逻辑顺序和数据的物理存储顺序不同<ul><li>应用场景：列经常被分组排序/频繁更新列/主键列/外键列/大数目的不同值</li></ul></li><li>区别<ul><li>聚集索引是一种稀疏索引，数据页上一级的索引页存储的是页指针，而不是行指针。而对于非聚集索引，则是密集索引，在数据页的上一级索引页它为每一个数据行存储一条索引记录。</li><li>聚集索引的叶子结点是数据节点，非聚集索引的叶子结点并非数据结点</li></ul></li></ul><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li>不要索引数据量不大的表，对于小表来讲，表扫描的成本并不高。</li><li>主键并非都是聚合索引，使用了聚合索引的主键查询速度更快</li><li>建立适当的聚合索引，才能更好的提高查询的效率</li><li>一个复合索引包含A,B,C,D四列，则A为“引导列”；复合索引的引导列应该是查询最频繁的列</li><li>索引有助于提高检索性能，但过多或不当的索引也会导致系统低效。因为用户在表中每加进一个索引，数据库就要做更多的工作。过多的索引甚至会导致索引碎片。所以说，我们要建立一个“适当”的索引体系，特别是对聚合索引的创建，更应精益求精，才能使数据库性能更好的发挥</li><li>不要设置过多的索引，在没有聚集索引的表中，最大可以设置249个非聚集索引，过多的索引首先会带来更大的磁盘空间，而且在数据发生修改时，对索引的维护是特别消耗性能的</li><li>索引通常查询数据比全表扫描要快，但需要空间来存储，也需要定期维护。不必要的索引反而会使查询反应时间变慢.使用索引查询不一定能提高查询性能</li></ul><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><ul><li>并发控制的基本单位</li><li>一个操作序列，要么都执行，要么都不执行，结束时能保持数据一致性</li><li>定义事务的三条语句<ul><li>BEGIN TRANSACTION </li><li>COMMIT </li><li>ROLLBACK</li></ul></li><li>用户在事务（transaction）内可以声明（declare）被称为保存点（savepoint）的标记。保存点将一个大事务划分为较小的片断。</li></ul><h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><ul><li>触发器是一中特殊的存储过程，主要是通过事件来触发而被执行的。</li><li>它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。</li><li>可以联级运算。如，某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。</li><li>一个数据表可以有多个触发器，但一个触发器只能对应一个表</li></ul><h3 id="drop、delete与truncate"><a href="#drop、delete与truncate" class="headerlink" title="drop、delete与truncate"></a><strong>drop、delete</strong>与truncate</h3><ul><li>不再需要一张表及其数据的时候，用<strong>drop</strong></li><li>想删除部分数据行时候，用<strong>delete</strong>，并且带上where子句</li><li>保留表而删除所有数据的时候用<strong>truncate</strong>, 再插入时自增长id又从1开始 </li><li>当表被<strong>TRUNCATE</strong> 后，这个表和索引所占用的空间会恢复到初始大小，而<strong>DELETE</strong>操作不会减少表或索引所占用的空间。<strong>DROP</strong>语句将表所占用的空间全释放掉。</li><li>速度上，drop &gt; truncate &gt; delete</li><li>delete语句为DML（data maintain Language),这个操作会被放到 rollback segment中,事务提交后才生效。如果有相应的 tigger,执行的时候将被触发。</li><li>truncate、drop是DLL（data define language),操作立即生效，原数据不放到 rollback segment中，<strong>不能回滚</strong>。(如果一不小心把一个表truncate掉，也是可以恢复的，只是不能通过rollback来恢复)</li><li>对于外键（foreignkey ）约束引用的表，不能使用 truncate table，而应使用不带 where 子句的 delete 语句。</li><li>truncatetable不能用于参与了索引视图的表。</li><li>drop语句将删除表的结构所依赖的约束，触发器，索引，依赖于该表的存储过程/函数将保留,但是变为invalid状态。</li></ul><h3 id="超键、候选键、主键、外键"><a href="#超键、候选键、主键、外键" class="headerlink" title="超键、候选键、主键、外键"></a>超键、候选键、主键、外键</h3><ul><li>超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</li><li>候选键：是最小超键，即没有冗余元素（对数据唯一性不起作用的列元素）的超键。</li><li>主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。</li><li>外键：在一个表中存在的另一个表的主键称此表的外键。</li></ul><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Student( </span><br><span class="line"><span class="keyword">ID</span> <span class="built_in">NUMBER</span> PRIMARY <span class="keyword">KEY</span>, </span><br><span class="line"><span class="keyword">NAME</span> VARCHAR2(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>);//建表 </span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_name <span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">Select</span> * <span class="keyword">FROM</span> Table_name;//建视图 </span><br><span class="line"></span><br><span class="line"><span class="keyword">Create</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> index_name <span class="keyword">ON</span> TableName(col_name);//建索引 </span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tablename &#123;column1,column2,…&#125; <span class="keyword">values</span>(exp1,exp2,…);//插入 </span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Viewname &#123;column1,column2,…&#125; <span class="keyword">values</span>(exp1,exp2,…);//插入视图实际影响表 </span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> tablename <span class="keyword">SET</span> <span class="keyword">name</span>=<span class="string">'zang 3'</span> condition;//更新数据 </span><br><span class="line"></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Tablename <span class="keyword">WHERE</span> condition;//删除 </span><br><span class="line"></span><br><span class="line"><span class="keyword">GRANT</span> (<span class="keyword">Select</span>,<span class="keyword">delete</span>,…) <span class="keyword">ON</span> (对象) <span class="keyword">TO</span> USER_NAME [<span class="keyword">WITH</span> <span class="keyword">GRANT</span> <span class="keyword">OPTION</span>];//授权 </span><br><span class="line"></span><br><span class="line"><span class="keyword">REVOKE</span> (权限表) <span class="keyword">ON</span>(对象) <span class="keyword">FROM</span> USER_NAME [<span class="keyword">WITH</span> <span class="keyword">REVOKE</span> <span class="keyword">OPTION</span>] //撤权</span><br></pre></td></tr></table></figure><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><ul><li><a href="https://thomstrong.github.io/2019/07/02/SQL-vs-NoSQL/">SQL vs NoSQL</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;blockquote&gt;
&lt;p&gt;关系型数据库——MySQL部分概念&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;存储过程&quot;&gt;&lt;a href=&quot;#存储过程&quot; class=&quot;h
      
    
    </summary>
    
      <category term="技术" scheme="https://thomstrong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="数据库" scheme="https://thomstrong.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Docker知识点</title>
    <link href="https://thomstrong.github.io/2019/07/04/Docker/"/>
    <id>https://thomstrong.github.io/2019/07/04/Docker/</id>
    <published>2019-07-04T01:13:25.000Z</published>
    <updated>2019-07-15T03:01:12.342Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><blockquote><p>参考<a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" target="_blank" rel="noopener">博文</a></p></blockquote><h1 id="知识铺垫"><a href="#知识铺垫" class="headerlink" title="知识铺垫"></a>知识铺垫</h1><h4 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h4><blockquote><p> 在操作系统中运行其他操作系统，对于底层来说，虚拟机是一个<strong>文件</strong></p></blockquote><ul><li>优势在于可通过还原虚拟机镜像/快照的方式还原原始环境</li><li>资源占用多、冗余步骤多、启动慢三个劣势</li></ul><h4 id="Linux容器"><a href="#Linux容器" class="headerlink" title="Linux容器"></a>Linux容器</h4><blockquote><p>不是模拟完整操作系统，而是对进程进行隔离</p></blockquote><ul><li>优势：启动快（一个容器相当于一个底层的进程）、占用资源少（只占用需要的资源，且可以共享资源）、体积小（只包含有用的组件）</li></ul><h4 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h4><blockquote><p>Linux 容器的封装，提供简单易用的容器使用接口</p></blockquote><ul><li>将应用程序与其依赖打包为一个文件，省去了环境配置带来的问题</li></ul><h1 id="Docker-1"><a href="#Docker-1" class="headerlink" title="Docker"></a>Docker</h1><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><ul><li>提供一次性的环境</li><li>提供弹性的云服务：随开随关，动态扩缩容</li><li>组件微服务架构：通过在一台机器上启动多个容器模拟微服务架构</li></ul><hr><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="image-镜像"><a href="#image-镜像" class="headerlink" title="image/镜像"></a>image/镜像</h4><ul><li>应用及其依赖打包在image文件里</li><li>可以看作是容器的模板，只有通过image才能生成容器</li><li><p>image是二进制文件，通常一个image是继承另一个image，再加上一些个性化设置而生成</p></li><li><p>命令</p><ul><li><code>docker image ls</code> </li><li><code>docker image rm [imageName or imageId]</code> or<code>docker rmi [imageName or imageId]</code></li><li><code>docker image pull [imageName]</code></li></ul></li><li><p>image一般不建议重复造轮</p></li></ul><h4 id="Container-容器"><a href="#Container-容器" class="headerlink" title="Container/容器"></a>Container/容器</h4><ul><li>image 文件生成的容器实例，本身也是一个文件，称为容器文件</li><li>命令<ul><li><code>docker container run [imageName]</code> # 该命令有自动抓取image文件的功能，如果本地没有指定的image文件，就会从仓库自动抓取</li><li><code>docker container run -it [imageName] bash</code> # 将运行的容器映射到终端中<ul><li><code>-p 8000:3000</code>参数：容器的 3000 端口映射到本机的 8000 端口。</li><li><code>-it</code>参数：容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。</li><li><code>koa-demo:0.0.1</code>：image 文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）。</li><li><code>/bin/bash</code>：容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。</li></ul></li><li><code>docker container kill [containerId]</code> # 终止容器运行</li><li><code>docker container rm</code>or <code>docker rm</code> </li></ul></li></ul><h4 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h4><ul><li><p>文本文件，用来配置image</p></li><li><p>.dockerignore # 加入不需要打包入image的文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.git</span><br><span class="line">node_modules</span><br><span class="line">npm-debug.log</span><br></pre></td></tr></table></figure></li><li><p>Dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">8.4</span> <span class="comment"># 继承自官方node image</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /app <span class="comment"># 将当前目录下所有文件（除了.dockerignore排除的路径）复制到image文件的/app下</span></span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app <span class="comment"># 之后的工作路径为/app</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm install --registry=https://registry.npm.taobao.org <span class="comment"># 安装node依赖</span></span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3000</span> <span class="comment"># 将容器的3000端口暴露出来，允许外部连接</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> node demos/01.js <span class="comment"># 容器启动后执行 node demos/01.js这条命令</span></span></span><br><span class="line"><span class="comment"># RUN命令在 image 文件的构建阶段执行，执行结果都会打包进入 image 文件；CMD命令则是在容器启动后执行。另外，一个 Dockerfile 可以包含多个RUN命令，但是只能有一个CMD命令。</span></span><br><span class="line"><span class="comment"># 指定了CMD命令以后，docker container run命令就不能附加命令了（比如前面的/bin/bash），否则它会覆盖CMD命令。</span></span><br></pre></td></tr></table></figure></li><li><p>build/打包 image</p><ul><li><code>docker image build -t koa-demo .</code> # 使用当前目录下的dockerfile打包image，名称为koa-demo</li></ul></li><li><p>生成容器</p><ul><li><code>docker container run --rm -p 8000:3000 -it [imageName] [someCmd]</code></li></ul></li></ul><h3 id="一些命令"><a href="#一些命令" class="headerlink" title="一些命令"></a>一些命令</h3><ul><li><code>docker container start [containerId or containerName]</code> or <code>docker start [containerId or containerName]</code>  # 启动一个已生成的容器</li><li><code>docker container stop</code></li><li><code>docker container logs</code> # 查看容器的标准输出</li><li><code>docker container exec -it [containerID or containerName] /bin/bash</code> # 将容器的shell映射到本地终端</li><li><code>docker container cp [containID]:[/path/to/file] .</code> # 将容器<code>/path/to/file</code>路径对应的文件复制到当前目录</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;blockquote&gt;
&lt;p&gt;参考&lt;a href=&quot;http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html&quot; ta
      
    
    </summary>
    
      <category term="技术" scheme="https://thomstrong.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="虚拟化" scheme="https://thomstrong.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
</feed>
