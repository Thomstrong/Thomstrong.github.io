<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Thomstrong&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://thomstrong.github.io/"/>
  <updated>2019-07-03T07:39:21.054Z</updated>
  <id>https://thomstrong.github.io/</id>
  
  <author>
    <name>Thomstrong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis知识点</title>
    <link href="https://thomstrong.github.io/2019/06/21/Redis/"/>
    <id>https://thomstrong.github.io/2019/06/21/Redis/</id>
    <published>2019-06-21T07:32:20.000Z</published>
    <updated>2019-07-03T07:39:21.054Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Redis知识点汇总"><a href="#Redis知识点汇总" class="headerlink" title="Redis知识点汇总"></a>Redis知识点汇总</h1><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>C 语言写成的，开源的 key-value 数据库</li><li>和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set 使用score排序)和hash（哈希类型）</li><li>这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。</li><li>与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步</li></ul><h3 id="对比memcached"><a href="#对比memcached" class="headerlink" title="对比memcached"></a>对比memcached</h3><p><img src="/images/redis_vs_memcached.jpg" alt="redis_vs_memcached"></p><ul><li>Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。memcache支持简单的数据类型，String。</li><li>Redis支持数据的备份，即master-slave模式的数据备份。</li><li>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而Memecache把数据全部存在内存之中</li><li>redis的速度比memcached快很多</li><li><p>Memcached是多线程，非阻塞IO复用的网络模型；Redis使用单线程的IO复用模型。</p></li><li><p><strong>终极策略：</strong> 使用Redis的String类型做的事，都可以用Memcached替换，以此换取更好的性能提升； 除此以外，优先考虑Redis</p></li></ul><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>(1) <strong>速度快</strong>，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)</p><p>(2)<strong>支持丰富数据类型</strong>，支持string，list，set，sorted set，hash</p><p>(3) <strong>支持事务</strong> ：redis对事务是部分支持的，如果是在入队时报错，那么都不会执行；在非入队时报错，那么成功的就会成功执行。</p><p>(4) <strong>丰富的特性</strong>：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ul><li>字符串操作： SET/GET</li><li>哈希类型操作：HMSET/ HGETALL/ HSET</li><li>列表（链表）：LPUSH/ RPUSH/ LPOP/ RPOP/ LRANGE</li><li>集合：SADD/ SMEMBERS</li><li>有序集合（ZSET）：ZADD/ ZRANGE</li><li><p>HyperLogLog（集合基数统计）:PFADD/ PFCOUNT/ PFMERGE</p></li><li><p>发布订阅</p><ul><li>发布订阅模式，两个客户端之间通过SUBSCRIBE/ PULISH交换消息</li><li>命令：PUBLISH/ SUBSCRIBE/ PUBSUB</li></ul></li><li><p>事务</p><ul><li>从开始到执行会进入以下步骤：开始事务—进入队列—执行事务</li><li>事务可以认为是一个批量执行的脚本，内部命令是原子的，但事务本身并非原子。中间的命令失败不会导致其之前命令回滚，也不会导致其之后命令放弃执行</li><li>命令：<ul><li>MULTI（标记事务开始）</li><li>EXEC（开始执行事务）</li><li>DISCARD（放弃执行事务块）</li></ul></li></ul></li><li><p>脚本：EVAL script numkeys key [key …] arg [arg …]</p></li><li>备份与恢复<ul><li>备份：<code>SAVE</code>命令存储数据到dump.rdb，<code>CONFIG GET dir</code>查看rdb文件存储位置，将文件备份</li><li>恢复：只需将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可</li></ul></li><li>性能测试：<code>redis-benchmark -n 10000  -q</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;Redis知识点汇总&quot;&gt;&lt;a href=&quot;#Redis知识点汇总&quot; class=&quot;headerlink&quot; title=&quot;Redis知识点汇总&quot;&gt;&lt;/a&gt;Redis知
      
    
    </summary>
    
    
      <category term="技术" scheme="https://thomstrong.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Memcached 知识点</title>
    <link href="https://thomstrong.github.io/2019/06/20/Memcached/"/>
    <id>https://thomstrong.github.io/2019/06/20/Memcached/</id>
    <published>2019-06-20T07:30:29.000Z</published>
    <updated>2019-07-03T07:33:05.584Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Memcached知识点"><a href="#Memcached知识点" class="headerlink" title="Memcached知识点"></a>Memcached知识点</h1><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Memcached是一个免费开源的，高性能的，具有分布式对象的缓存系统，它可以用来保存一些经常存取的对象或数据，保存的数据像一张巨大的<strong>HASH表</strong>，该表以Key-value对的方式存在<strong>内存</strong>中。</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ul><li><p>检查客户端请求是否在memcached中</p></li><li><p>若有则直接返回</p></li><li><p>若无则从数据库查询后返回，并存储到memcached中</p></li><li><p>数据库更新需要同时更新memcached，保证一致性</p></li><li><p>memcached内存用完后会使用LRU策略加上到期失效策略，首先替换到期失效数据，之后替换最近未使用过的数据</p><blockquote><p>缓存置换算法（页面置换算法）FIFO/ LFU/ LRU</p><ol><li>FIFO 先进先出，最先进入缓存的最先替换掉</li><li>LFU 最近最少使用，替换掉最近一段时间使用次数最少的数据</li><li>LRU 最近最久未使用使用，替换掉最近一段时间没使用过的，以最近一次使用时间为基准，替换最远的数据空间</li></ol></blockquote></li></ul><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul><li><p>协议简单：基于文本行的协议，直接通过telnet在memcached服务器上可进行存取数据操作</p><blockquote><p>Telnet 远程连接服务，作用于tcp/ip协议的应用层</p></blockquote></li><li><p>基于libevent事件处理：libevent是一套利用C开发的程序库，由事件驱动，跨平台，支持并发编程</p></li><li>内置的内存管理方式：所有数据存于内存，LRU算法替换，数据易失</li><li>分布式：分布式取决于memcache客户端，memcached服务器之间互不通信，数据独立存储</li></ul><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><blockquote><p>服务启动方法<code>/usr/local/memcached/bin/memcached –p 11211 –d –u root –P /tmp/memcached.pid</code></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">telnet 127.0.0.1 11211 # 远程连接memcached</span><br><span class="line">stats items # 获取所有items的序号，例如items:29:hits_to_warm</span><br><span class="line">stats cachedump 29 0 # 获取编号29的item的key，返回如:1:/api/courses/tags/?；0表示返回所有slab中的item；若指定返回1个则使用stats cachedump 29 1</span><br><span class="line"></span><br><span class="line">get :1:/api/courses/tags/? # 获取key对应的值，多个键空格分割</span><br><span class="line"></span><br><span class="line">set cai 0 900 9 # 设置/更新key为cai的值为caicaicai，过期时间为900ms，以下输入的数据占9字节</span><br><span class="line">caicaicai # 存储成功返回STORED，失败返回ERROR</span><br><span class="line"></span><br><span class="line">add cai 0 900 9 # 设置key为cai的值为caicaicai，过期时间为900ms，以下输入的数据占9字节</span><br><span class="line">caicaicai # 存储成功返回STORED，失败或key存在返回NOT_STORED</span><br><span class="line"></span><br><span class="line"><span class="meta"> #</span><span class="bash"> replace 用于直接替换</span></span><br><span class="line"><span class="meta"> #</span><span class="bash"> append 用于直接在key对应的数据后面追加数据</span></span><br><span class="line"><span class="meta"> #</span><span class="bash"> prepend 用于直接在key对应的数据前面追加数据</span></span><br><span class="line"> cas cai 0 900 3 14 # 14为gets获取到的token，CAS 通过先检查token后再设置/更新值，避免数据不一致</span><br><span class="line"> aaa # 成功返回STORED；保存错误/语法错误返回ERROR；EXISTS说明token过期/不合法；NOT_FOUND该key不存在</span><br><span class="line"></span><br><span class="line"> gets cai # 返回带有token的value</span><br><span class="line"></span><br><span class="line">incr key increment_value # 自增key对应的value，必须是32位无符号整数</span><br><span class="line">decr key increment_value # 自减key对应的value，必须是32位无符号整数</span><br><span class="line"></span><br><span class="line">stats # 输出统计信息</span><br></pre></td></tr></table></figure><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ul><li>内存分配：Slab allocation机制分配和管理，先按照预定的大小，将分配的内存分割成特定长度的内存块chunck，然后再把相同的内存块分成组slab，根据值的大小去匹配slab大小，找就近的slab存放</li><li>缓存策略：失效策略 + LRU；不会监控存入的key/value是否过期，而是获取key时去查看记录的时间戳，检查key/value是否过期</li><li>分布式算法：memcached本身不存在分布式，而是客户端进行分布式选择memcached服务器进行分布式存储，因此只考虑服务器选择算法<ul><li>余数算法：求得key的整数散列值，然后根据服务器台数求的余数进行服务器选择；但是服务器的增减都会导致缓存失效</li><li>散列算法：首先将服务器散列值映射到0～2^32^编号的圆上，然后找到从key的散列值开始的第一个圆点作为目标服务器；当从中间插入服务器时，只有第一个服务器逆时针算的第一个服务器会受影响；减少服务器时，只有所减少服务器的逆时针方向第一个服务器之间的数据会受影响</li></ul></li></ul><h3 id="可视化工具"><a href="#可视化工具" class="headerlink" title="可视化工具"></a>可视化工具</h3><p><a href="https://github.com/junstor/memadmin" target="_blank" rel="noopener">Memadmin</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;Memcached知识点&quot;&gt;&lt;a href=&quot;#Memcached知识点&quot; class=&quot;headerlink&quot; title=&quot;Memcached知识点&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="技术" scheme="https://thomstrong.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>数智教育数据可视化创新大赛总结</title>
    <link href="https://thomstrong.github.io/2019/06/20/Tianchi-DataAnalysis/"/>
    <id>https://thomstrong.github.io/2019/06/20/Tianchi-DataAnalysis/</id>
    <published>2019-06-20T03:34:19.000Z</published>
    <updated>2019-07-03T07:29:26.151Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="数智教育数据可视化创新大赛总结"><a href="#数智教育数据可视化创新大赛总结" class="headerlink" title="数智教育数据可视化创新大赛总结"></a>数智教育数据可视化创新大赛总结</h1><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><blockquote><p>使用Django Rest Framework中规中矩的api，memcached简单配置</p></blockquote><ul><li><p>环境搭建</p><ul><li>使用virtualenv创建虚拟环境，防止环境污染</li><li>pip install 可以使用国内镜像源，pip install -i <a href="http://xxx.com/yyy/" target="_blank" rel="noopener">http://xxx.com/yyy/</a><ul><li>阿里云 <a href="http://mirrors.aliyun.com/pypi/simple/" target="_blank" rel="noopener">http://mirrors.aliyun.com/pypi/simple/</a></li><li>中国科技大学 <a href="https://pypi.mirrors.ustc.edu.cn/simple/" target="_blank" rel="noopener">https://pypi.mirrors.ustc.edu.cn/simple/</a></li><li>豆瓣(douban) <a href="http://pypi.douban.com/simple/" target="_blank" rel="noopener">http://pypi.douban.com/simple/</a></li><li>清华大学 <a href="https://pypi.tuna.tsinghua.edu.cn/simple/" target="_blank" rel="noopener">https://pypi.tuna.tsinghua.edu.cn/simple/</a></li><li>中国科学技术大学 <a href="http://pypi.mirrors.ustc.edu.cn/simple/" target="_blank" rel="noopener">http://pypi.mirrors.ustc.edu.cn/simple/</a></li></ul></li></ul></li><li><p>数据库配置</p><ul><li><p>考虑数据整体不会有太大变动，可能需要从本地开发环境直接迁移到线上服务器，所以使用docker搭载postgres的方法，上线后可直接将docker镜像进行恢复然后迁移数据</p></li><li><p>docker 镜像备份方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. docker save [container_name] &gt; bak.tar <span class="comment"># save as tar</span></span><br><span class="line">2. docker load -i ./bak.tar <span class="comment"># 恢复container</span></span><br><span class="line">3. 进入postgre创建database然后执行如下</span><br><span class="line">4. cat your_dump.sql | docker <span class="built_in">exec</span> -i your-db-container psql -U tianchiuser tianchidb</span><br></pre></td></tr></table></figure></li></ul></li><li><p>数据迁移</p><ul><li><p>使用runpython在migration中运行自定义脚本</p><ul><li>编写<code>def fun(apps, schema_editor)</code>函数，通过<code>apps.get_model()</code>获取数据模型</li><li>在operations中加入 <code>migrations.RunPython(fun, reverse_code=migrations.RunPython.noop)</code></li><li><code>reverse_code=migrations.RunPython.noop</code>使用reverse_code去定义回滚时使用的方法，此处会忽略runpython产生的任何修改，直接回滚</li></ul></li><li><p>回滚migration <a href="https://simpleisbetterthancomplex.com/tutorial/2016/07/26/how-to-reset-migrations.html" target="_blank" rel="noopener">参考链接</a></p><ul><li><code>python manage.py migrate [app_name] [migration_name]</code>将某个app的migrations回滚到某个migration文件为止</li><li>合并migration树<ol><li>./manage.py migrate —fake [app_name] zero 回滚全部migrate，但是保留数据</li><li>删除所有migration文件</li><li>./manage.py makemigrations 重新生成migration文件</li><li>./manage.py migrate —fake-initial 重新应用合并的migration 文件</li></ol></li><li><code>python manage.py showmigrations</code>可以查看当前已应用的migration</li></ul></li><li><p>Postgres 中创建用户</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">psql</span><br><span class="line">postgres<span class="comment"># CREATE USER xxxx1 WITH PASSWORD 'xxxx';</span></span><br><span class="line">postgres<span class="comment"># CREATE DATABASE xxxx2;</span></span><br><span class="line">postgres<span class="comment"># GRANT ALL PRIVILEGES ON DATABASE xxxx2 to xxxx1;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>缓存配置(memcached) <a href="http://chibisov.github.io/drf-extensions/docs/#cache-response" target="_blank" rel="noopener">参考文档</a></p><ul><li><p>settings配置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">CACHES = &#123;</span><br><span class="line">    <span class="string">'default'</span>: &#123;</span><br><span class="line">        <span class="string">'BACKEND'</span>: <span class="string">'django.core.cache.backends.memcached.MemcachedCache'</span>,</span><br><span class="line">        <span class="string">'LOCATION'</span>: <span class="string">'127.0.0.1:11211'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">INSTALLED_APPS = [</span><br><span class="line">    ...,</span><br><span class="line">    <span class="string">'django_extensions'</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">REST_FRAMEWORK_EXTENSIONS = &#123;</span><br><span class="line">    <span class="string">'DEFAULT_CACHE_KEY_FUNC'</span>: <span class="string">'utils.cache_funcs.calculate_cache_key'</span></span><br><span class="line">&#125; <span class="comment"># 使用自定义的calculate_cache_key函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过请求的url进行缓存</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_cache_key</span><span class="params">(view_instance, view_method,</span></span></span><br><span class="line"><span class="function"><span class="params">                        request, args, kwargs)</span>:</span></span><br><span class="line">    url = <span class="string">'&#123;&#125;?'</span>.format(request.path)</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> request.query_params:</span><br><span class="line">        url += <span class="string">'&#123;&#125;=&#123;&#125;&amp;'</span>.format(key, request.query_params[key])</span><br><span class="line">    <span class="keyword">return</span> url</span><br></pre></td></tr></table></figure></li><li><p>使用rest_framework_extensions提供的<code>@cache_response([x seconds]])</code>装饰器进行view的缓存</p></li></ul></li></ul><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><blockquote><p>使用 Ant Design Pro脚手架，Umi &amp; Dva</p></blockquote><ul><li><p>Umi 要点</p><ul><li>umi 里约定 mock 文件夹下的文件或者 page(s) 文件夹下的 _mock 文件即 mock 文件</li><li>对于整个系统来说，请求接口是复杂并且繁多的，为了处理大量模拟请求的场景，我们通常把每一个数据模型抽象成一个文件，统一放在 <code>mock</code> 的文件夹中，然后他们会自动被引入。</li><li>当本地开发完毕之后，修改config.js中的proxy配置</li><li>umi with dva<ul><li>按目录约定注册 model，无需手动 <code>app.model</code></li><li>文件名即 namespace，可以省去 <code>model</code> 导出的 <code>namespace</code> key</li><li>无需手写 <code>router.js</code>，交给 umi 处理，支持 <code>model</code> 和 <code>component</code> 的按需加载</li><li>内置 query-string 处理，无需再手动解码和编码</li><li>内置 dva-loading 和 dva-immer，其中 dva-immer 需通过配置开启</li><li>开箱即用，无需安装额外依赖，比如 dva、dva-loading、dva-immer、path-to-regexp、object-assign、react、react-dom 等</li></ul></li></ul></li><li><p>Dva</p><ul><li><p>State：一个对象，保存整个应用状态</p></li><li><p>View：React 组件构成的视图层</p></li><li><p>Action：一个对象，描述事件</p></li><li><p>connect 方法：一个函数，绑定 State 到 View，用于建立state 和 props的映射</p></li><li><p>dispatch 方法：一个函数，发送 Action 到 State，被 connect 的 Component 会自动在 props 中拥有 dispatch 方法。</p></li><li><p>model 对象属性</p><ul><li><p>namespace: 当前 Model 的名称。整个应用的 State，由多个小的 Model 的 State 以 namespace 为 key 合成</p></li><li><p>state: 该 Model 当前的状态。数据保存在这里，直接决定了视图层的输出</p></li><li><p>reducers: Action 处理器，处理同步动作，用来算出最新的 State</p></li><li><p>effects：Action 处理器，处理异步动</p><ul><li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">addAfter1Second</span>(<span class="params">action, &#123; put, call &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> call(delay, <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: <span class="string">'add'</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Effect 是一个 Generator 函数，内部使用 yield 关键字，标识每一步的操作（不管是异步或同步）。</p></li><li><p>call：执行异步函数</p></li><li><p>put：发出一个 Action，类似于 dispatch</p></li></ul></li></ul></li></ul></li><li><p>DOM 和 BOM</p><ul><li><p>window对象对应着浏览器窗口本身，这个对象的属性和方法通常被称为BOM</p></li><li><p>D（文档）可以理解为整个Web加载的网页文档，O（对象）可以理解为类似window对象只来的东西，可以调用属性和方法，这里我们说的是document对象，M（模型）可以理解为网页文档的树形结构，DOM树由节点构成</p></li><li><p>Window对象包含属性：document、location、navigator、screen、history、frames</p><p>Document根节点包含子节点：forms、location、anchors、images、links</p></li><li><p>BOM的核心是window，而window对象又具有双重角色，它既是通过js访问浏览器窗口的一个接口，又是一个Global（全局）对象</p></li><li><p>document对象：实际上是window对象的属性，document == window.document为true，是唯一一个既属于BOM又属于DOM的对象</p></li></ul></li><li><p>Suspense 相关 <a href="https://zhuanlan.zhihu.com/p/58979795" target="_blank" rel="noopener">参考文章</a></p><ul><li><p>懒加载<code>const ScoreLineChart = React.lazy(() =&gt; import(&#39;./ScoreLineChart&#39;));</code></p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;/div&gt;&#125;&gt;</span><br><span class="line">    &lt;ScoreLineChart /&gt;</span><br><span class="line">&lt;/Suspense&gt;</span><br></pre></td></tr></table></figure></li><li><p>使用懒加载的组件必须放入suspense中</p></li><li><p>未使用懒加载的组件不能放入suspense中，否则可能导致所挂载的dom没有渲染出来而导致报错</p></li></ul></li><li><p><code>constructor.name</code>不要用于做为判断的条件，因为webpack后会翻译为其他名字</p></li></ul><h3 id="部署-webpack"><a href="#部署-webpack" class="headerlink" title="部署 webpack"></a>部署 <a href="https://webpack.js.org/" target="_blank" rel="noopener">webpack</a></h3><blockquote><p>Umi build + nginx + docker实现</p></blockquote><ul><li><p>基于docker的打包和发布真的是很方便的，虽然在项目中使用的深度还不是很深，仅用了一些皮毛</p></li><li><p>webpack 打包时可用hush防止缓存不刷新带来的报错 <a href="https://www.cnblogs.com/ihardcoder/p/5623411.html" target="_blank" rel="noopener">参考链接</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].bundle.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>cdn 加速还是很有用的 <a href="https://unpkg.com/" target="_blank" rel="noopener">免费cdn加速</a></p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>官方文档要仔细阅读</li><li>不要重复造轮子</li><li><p>皮毛只能解决问题，但不能理解问题</p></li><li><p>代码规范还是要注重一下..虽然本次比赛比较赶没有任何规范</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;数智教育数据可视化创新大赛总结&quot;&gt;&lt;a href=&quot;#数智教育数据可视化创新大赛总结&quot; class=&quot;headerlink&quot; title=&quot;数智教育数据可视化创新大
      
    
    </summary>
    
    
      <category term="比赛" scheme="https://thomstrong.github.io/tags/%E6%AF%94%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>2019 Byte Camp-工程赛道面试经历</title>
    <link href="https://thomstrong.github.io/2019/06/17/2019-Byte-Camp/"/>
    <id>https://thomstrong.github.io/2019/06/17/2019-Byte-Camp/</id>
    <published>2019-06-17T07:25:59.000Z</published>
    <updated>2019-07-03T07:29:20.683Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="2019-Byte-Camp-工程赛道面试经历"><a href="#2019-Byte-Camp-工程赛道面试经历" class="headerlink" title="2019 Byte Camp-工程赛道面试经历"></a>2019 Byte Camp-工程赛道面试经历</h1><blockquote><p>面试官 30-40岁，主要从事后端</p></blockquote><ol><li><p>自我介绍</p></li><li><p>通过介绍中提及实习经历/实践经历提问</p><ul><li><p>线上实习如何分配时间</p></li><li><p>xx实习中使用的技术栈是什么？为什么用postgres？</p></li><li><p>React 是什么？大体介绍一下</p></li><li><p>你对rest api的认识</p><blockquote><p>针对资源</p><p>使用get/post/put/delete方法</p></blockquote></li><li><p>python 的装饰器是什么</p><blockquote><p>在不改变原函数功能的情况下增加额外功能</p></blockquote></li><li><p>数据库中group by 是什么（只回答了使用方法，原理未提及，需要重新理解）</p><blockquote><p>原理：使用松散索引/紧凑索引/临时表的方法在排序后分组</p></blockquote></li></ul></li><li><p>基础知识问答</p><ul><li><p>Linux进程相关，进程存储空间的分类，进程状态分类</p><blockquote><p>三状态模型：</p><ul><li>就绪ready：获得了处理机以外的所有资源，一旦得到处理机即可运行</li><li>运行running：进程在处理机上运行时</li><li>阻塞waiting：等待或者睡眠状态，等待某一事件发生中</li></ul></blockquote></li><li><p>tcp 三次握手过程，第一次握手发送报文名称，哪些flag置位<a href="https://blog.csdn.net/qq_33982721/article/details/78493967" target="_blank" rel="noopener">参考博客</a></p><blockquote><p>三次握手：避免失效请求报文错误建立了连接，导致server一直等待，浪费资源</p><ul><li>客户端syn seq=x</li><li>服务器 syn seq=y, ack=x+1</li><li>客户端ack=y+1</li></ul><p>四次挥手：tcp全双工模式，需要确定双方均无数据发送才可断开连接</p><ul><li>主机1 fin seq=x ack=y，x-1是主机1前面发送的最后一个字节的序号</li><li>主机2 ack=x+1</li><li>主机2 fin seq=y，y-1是主机2前面发送的最后一个字节序号</li><li>主机1 ack=y+1</li></ul><p>ack序号含义：希望收到第x个字节开始的报文段，且成功收到了前面x-1个报文</p></blockquote></li><li><p>二叉树，什么是完全二叉树，如何判别完全二叉树，设计算法</p><blockquote><p>可以使用栈的方式，按层遍历；如果本层存在有左无右的情况，那么下次遍历必须都是叶子结点；如果存在有右无左的情况，直接false</p></blockquote></li></ul></li><li><p>算法题</p><blockquote><p>给一个升序数组，判断这个数组每个元素平方后不同数字的个数</p></blockquote><ul><li>平方数没用，直接判断绝对值</li><li>使用头尾指针的方式向中间收缩</li><li>需考虑数组中连续相同数的情况</li></ul></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>基础知识复习完全不充分</li><li>描述自己见解时语言不清晰</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;2019-Byte-Camp-工程赛道面试经历&quot;&gt;&lt;a href=&quot;#2019-Byte-Camp-工程赛道面试经历&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
    
      <category term="面经" scheme="https://thomstrong.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
</feed>
