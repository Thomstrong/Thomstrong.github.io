<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Thomstrong&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://thomstrong.github.io/"/>
  <updated>2019-07-03T08:04:01.013Z</updated>
  <id>https://thomstrong.github.io/</id>
  
  <author>
    <name>Thomstrong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SQL vs NoSQL总结</title>
    <link href="https://thomstrong.github.io/2019/07/02/SQL-vs-NoSQL/"/>
    <id>https://thomstrong.github.io/2019/07/02/SQL-vs-NoSQL/</id>
    <published>2019-07-02T08:02:57.000Z</published>
    <updated>2019-07-03T08:04:01.013Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="SQL-vs-NoSQL"><a href="#SQL-vs-NoSQL" class="headerlink" title="SQL vs NoSQL"></a>SQL vs NoSQL</h1><blockquote><p><a href="https://www.xplenty.com/blog/the-sql-vs-nosql-difference/" target="_blank" rel="noopener">参考blog</a></p></blockquote><h3 id="SQL（关系型数据库）"><a href="#SQL（关系型数据库）" class="headerlink" title="SQL（关系型数据库）"></a>SQL（关系型数据库）</h3><ul><li>使用结构化查询语句（Structured Query Language)来定义和管理数据</li><li>通用且使用广泛，能够安全适用于复杂查询密集的环境</li><li>使用之前需要进行数据结构定义，所有数据遵循相同结构，结构的变化较难应付</li><li>MySql，Oracle，Sqlite，Postgres和MS-SQL</li></ul><h3 id="NoSQL（非关系数据库-分布式数据库）"><a href="#NoSQL（非关系数据库-分布式数据库）" class="headerlink" title="NoSQL（非关系数据库/分布式数据库）"></a>NoSQL（非关系数据库/分布式数据库）</h3><ul><li>非结构化数据动态模式，数据以多种方式存储，可以面向列、面向文档、基于图或者K-V模式存储</li><li>没有标准接口来执行复杂查询</li><li>数据文档无需进行预先定义和结构声明，每个文档可以拥有不同的结构，数据域能随意拓展</li><li>MongoDB，BigTable，Redis，RavenDb，Cassandra，Hbase，Neo4j和CouchDb</li></ul><hr><h3 id="拓展性"><a href="#拓展性" class="headerlink" title="拓展性"></a>拓展性</h3><ul><li>SQL具备垂直拓展性，可通过增加CPU/RAM/SSD来提升负载能力</li><li>NoSQL具备水平拓展性，可通过增加更多服务器提升负载能力</li></ul><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><ul><li>SQL数据库基于表存储</li><li>NoSQL数据库基于文档/k-v对/图/宽列存储</li></ul><h3 id="数据存储类型"><a href="#数据存储类型" class="headerlink" title="数据存储类型"></a>数据存储类型</h3><ul><li>SQL不支持分布式数据存储</li><li>NoSQL能更好的适应分布式数据存储，因其使用了k-v对这样类似Json数据的数据存储方式，对于大型数据集的存储有更好的表现。Hbase就是一个很好的例子</li></ul><h3 id="事务应用"><a href="#事务应用" class="headerlink" title="事务应用"></a>事务应用</h3><blockquote><ul><li><p>一个事务是一连串的操作组成，增删改查的集合</p></li><li><p>特性ACID：</p><ul><li>原子性（Atomicity）：要么完整执行，要么不执行</li><li>一致性（Consistency）：执行前后，数据保持完整和逻辑一致（银行存款例子），原子性和持久性是事务一致性的充分条件</li><li>隔离性（Isolation）：多个并发事务是独立的，上下文彼此隔离，互不干扰，使用锁机制进行数据线程安全控制。四种隔离级别<ul><li>读未提交，其隔离级别最低，允许脏读。换句话说就是，如果一个事务正在处理某一数据，并对其进行了更新，但是同时没有提交事务，允许另一个事务也可以访问</li><li>读已提交，和读未提交的区别就是。读未提交可以读取到别人没有提交的数据，但是读已提交只能读取到别人提交后的值，事务进行的中间值不会读取到</li><li>可重复读，简单来说就是事务处理过程中多次读取同一个数据的时候，这个值不会发生改变，其值都和第一次查询到的数据是一致的</li><li>串行化，是最严格的隔离级别，他要求所有的事务都被串行执行，既事务只能一个接一个的进行处理，不能并发执行</li></ul></li><li>持久性（Durability）：在提交后已提交的数据应该能过永久保存，在系统发生异常后仍能回到异常发生前的状态</li></ul></li></ul></blockquote><ul><li>SQL数据库最适合重量级事务类型应用程序，因为它更稳定，且承诺了数据的原子性和完整性</li><li>NoSQL也可以在事务中应用，但是在高负载和复杂事务的应用环境下不能有更好的表现</li></ul><h3 id="外部支持"><a href="#外部支持" class="headerlink" title="外部支持"></a>外部支持</h3><ul><li>SQL数据库有更丰富的提供商和解决方案作为支持</li><li>NoSQL目前仍然依赖于社区</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;SQL-vs-NoSQL&quot;&gt;&lt;a href=&quot;#SQL-vs-NoSQL&quot; class=&quot;headerlink&quot; title=&quot;SQL vs NoSQL&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>网络协议部分复习</title>
    <link href="https://thomstrong.github.io/2019/07/01/Network-Protocal/"/>
    <id>https://thomstrong.github.io/2019/07/01/Network-Protocal/</id>
    <published>2019-07-01T08:01:06.000Z</published>
    <updated>2019-07-03T08:02:18.089Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h1><h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h3><p>OSI 中的层                          功能                                                                     TCP/IP协议族<br>应用层            文件传输，电子邮件，文件服务，虚拟终端       TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet<br>表示层            数据格式化，代码转换，数据加密                                  没有协议<br>会话层            解除或建立与别的接点的联系                                       没有协议<br>传输层            提供端对端的接口                                                    TCP，UDP （RTP）<br>网络层            为数据包选择路由                                                    IP，ICMP，RIP，OSPF，BGP，IGMP<br>数据链路层    传输有地址的帧以及错误检测功能                         SLIP，CSLIP，PPP，ARP，RARP，MTU<br>物理层            以二进制数据形式在物理媒体上传输数据                    ISO2110，IEEE802，IEEE802.2</p><h3 id="TCP-IP五层模型的协议"><a href="#TCP-IP五层模型的协议" class="headerlink" title="TCP/IP五层模型的协议"></a>TCP/IP五层模型的协议</h3><p>应用层<br>传输层：四层交换机、也有工作在四层的路由器</p><p>网络层：路由器、三层交换机</p><p>数据链路层：网桥（现已很少使用）、以太网交换机（二层交换机）、网卡（其实网卡是一半工作在物理层、一半工作在数据链路层）</p><p>物理层：中继器、集线器、还有我们通常说的双绞线也工作在物理层</p><h3 id="RTP协议"><a href="#RTP协议" class="headerlink" title="RTP协议"></a>RTP协议</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>RTP全名是Real-time Transport Protocol（实时传输协议）。它是IETF提出的一个标准，对应的RFC文档为RFC3550（RFC1889为其过期版本）。RFC3550不仅定义了RTP，而且定义了配套的相关协议RTCP（Real-time Transport Control Protocol，即实时传输控制协议）。RTP用来为IP网上的语音、图像、传真等多种需要实时传输的多媒体数据提供<strong>端到端</strong>的实时传输服务。RTP为Internet上端到端的实时传输提供时间信息和流同步，但并不保证服务质量，<strong>服务质量由RTCP来提供</strong>。</p><ul><li>RTP功能：用来为IP网上的语音、图像、传真等多种需要实时传输的多媒体数据提供<strong>端到端</strong>的实时传输服务</li><li>RTCP功能：服务质量的监视与反馈、媒体间的同步，以及多播组中成员的标识。在RTP会话期间，各参与者<strong>周期性地传送RTCP包</strong>。RTCP包中含有已发送的数据包的数量、丢失的数据包的数量等<strong>统计资料</strong>，因此，各参与者可以利用这些信息动态地改变传输速率，甚至改变有效载荷类型。</li><li>RTP和RTCP配合使用，它们能以有效的反馈和最小的开销使传输效率最佳化，因而特别适合传送网上的实时数据。</li></ul><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ul><li>简单的多播音频会议</li><li>音频和视频会议</li><li>翻译器和混合器</li></ul><h4 id="流媒体"><a href="#流媒体" class="headerlink" title="流媒体"></a>流媒体</h4><p>流媒体是指Internet上使用流式传输技术的连续时基媒体。当前在Internet上传输音频和视频等信息主要有两种方式：下载和流式传输两种方式。流式传输是实现流媒体的关键技术。</p><ul><li>要实现流式传输，就是要从降低延迟和恢复数据包时序入手。在发送端，为降低延迟，往往对传输数据进行预处理（降低质量和高效压缩）。在接收端为了恢复时序，采用了接收缓冲；而为了实现媒体的流畅播放，则采用了播放缓冲。</li><li>使用接收缓冲，可以将接收到的数据包缓存起来，然后根据数据包的封装信息（如包序号和时戳等），将乱序的包重新排序，最后将重新排序了的数据包放入播放缓冲播放。</li></ul><h4 id="会话过程"><a href="#会话过程" class="headerlink" title="会话过程"></a>会话过程</h4><p>当应用程序建立一个RTP会话时，应用程序将确定一对目的传输地址。目的传输地址由一个网络地址和一对端口组成，有两个端口：一个给RTP包，一个给RTCP包，使得RTP/RTCP数据能够正确发送。RTP数据发向偶数的UDP端口，而对应的控制信号RTCP数据发向相邻的奇数UDP端口（偶数的UDP端口＋1），这样就构成一个UDP端口对。 RTP的发送过程如下，接收过程则相反。</p><ul><li><p>RTP协议从上层接收流媒体信息码流（如H.263），封装成RTP数据包；RTCP从上层接收控制信息，封装成RTCP控制包。</p></li><li><p>RTP将RTP 数据包发往UDP端口对中偶数端口；RTCP将RTCP控制包发往UDP端口对中的接收端口。</p></li></ul><h3 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul><li>TCP，全称Transfer Control Protocol，中文名为传输控制协议，它工作在OSI的传输层，提供面向连接的可靠传输服务。</li><li>TCP的工作主要是建立连接，然后从应用层程序中接收数据并进行传输。TCP采用虚电路连接方式进行工作，在发送数据前它需要在发送方和接收方建立一个连接，数据在发送出去后，发送方会等待接收方给出一个确认性的应答，否则发送方将认为此数据丢失，并重新发送此数据。</li></ul><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ul><li>TCP连接建立：TCP的连接建立过程又称为TCP<strong>三次握手</strong>。首先发送方主机向接收方主机发起一个建立连接的同步（SYN）请求；接收方主机在收到这个请求后向送方主机回复一个同步/确认（SYN/ACK）应答；发送方主机收到此包后再向接收方主机发送一个确认（ACK），此时TCP连接成功建立</li><li>TCP连接关闭：发送方主机和目的主机建立TCP连接并完成数据传输后，会发送一个将结束标记置1的数据包，以关闭这个TCP连接，并同时释放该连接占用的缓冲区空间；</li><li>TCP重置：TCP允许在传输的过程中突然中断连接，这称为TCP重置；</li><li>TCP数据排序和确认：TCP是一种可靠传输的协议，它在传输的过程中使用序列号和确认号来跟踪数据的接收情况；</li><li>TCP重传：在TCP的传输过程中，如果在重传超时时间内没有收到接收方主机对某数据包的确认回复，发送方主机就认为此数据包丢失，并再次发送这个数据包给接收方，这称为TCP重传；</li><li>TCP延迟确认：TCP并不总是在接收到数据后立即对其进行确认，它允许主机在接收数据的同时发送自己的确认信息给对方。</li><li>TCP数据保护（校验和）：TCP是可靠传输的协议，它提供校验和计算来实现数据在传输过程中的完整性。</li></ul><h3 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><ul><li>UDP协议是英文UserDatagramProtocol的缩写，即用户数据报协议，主要用来支持那些需要在计算机之间传输数据的网络应用。包括网络视频会议系统在内的众多的客户/服务器模式的网络应用都需要使用UDP协议。</li><li>UDP协议的主要作用是将网络数据流量压缩成数据报的形式。一个典型的数据报就是一个二进制数据的传输单位。每一个数据报的前8个字节用来包含报头信息，剩余字节则用来包含具体的传输数据。</li></ul><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ul><li>RTP位于UDP之上，UDP虽然没有TCP那么可靠，并且无法保证实时业务的服务质量，需要RTCP实时监控数据传输和服务质量，但是，由于UDP的传输时延低于TCP，能与视频和音频很好匹配。因此，在实际应用中，RTP/RTCP/UDP用于音频/视频媒体，而TCP用于数据和控制信令的传输。</li><li>UDP和TCP协议的主要区别是两者在如何实现信息的可靠传递方面不同。TCP协议中包含了专门的传递保证机制，当数据接收方收到发送方传来的信息时，会自动向发送方发出确认消息；发送方只有在接收到该确认消息之后才继续传送其它信息，否则将一直等待直到收到确认信息为止。</li><li>TCP比UDP多了建立连接的时间。相对UDP而言，TCP具有更高的安全性和可靠性。TCP协议传输的大小不限制，一旦连接被建立，双方可以按照一定的格式传输大量的数据，而UDP是一个不可靠的协议，大小有限制，每次不能超过64K。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;网络协议&quot;&gt;&lt;a href=&quot;#网络协议&quot; class=&quot;headerlink&quot; title=&quot;网络协议&quot;&gt;&lt;/a&gt;网络协议&lt;/h1&gt;&lt;h3 id=&quot;OSI七层模型
      
    
    </summary>
    
    
      <category term="技术" scheme="https://thomstrong.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Redis知识点</title>
    <link href="https://thomstrong.github.io/2019/06/21/Redis/"/>
    <id>https://thomstrong.github.io/2019/06/21/Redis/</id>
    <published>2019-06-21T07:32:20.000Z</published>
    <updated>2019-07-03T07:39:21.054Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Redis知识点汇总"><a href="#Redis知识点汇总" class="headerlink" title="Redis知识点汇总"></a>Redis知识点汇总</h1><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>C 语言写成的，开源的 key-value 数据库</li><li>和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set 使用score排序)和hash（哈希类型）</li><li>这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。</li><li>与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步</li></ul><h3 id="对比memcached"><a href="#对比memcached" class="headerlink" title="对比memcached"></a>对比memcached</h3><p><img src="/images/redis_vs_memcached.jpg" alt="redis_vs_memcached"></p><ul><li>Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。memcache支持简单的数据类型，String。</li><li>Redis支持数据的备份，即master-slave模式的数据备份。</li><li>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而Memecache把数据全部存在内存之中</li><li>redis的速度比memcached快很多</li><li><p>Memcached是多线程，非阻塞IO复用的网络模型；Redis使用单线程的IO复用模型。</p></li><li><p><strong>终极策略：</strong> 使用Redis的String类型做的事，都可以用Memcached替换，以此换取更好的性能提升； 除此以外，优先考虑Redis</p></li></ul><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>(1) <strong>速度快</strong>，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)</p><p>(2)<strong>支持丰富数据类型</strong>，支持string，list，set，sorted set，hash</p><p>(3) <strong>支持事务</strong> ：redis对事务是部分支持的，如果是在入队时报错，那么都不会执行；在非入队时报错，那么成功的就会成功执行。</p><p>(4) <strong>丰富的特性</strong>：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ul><li>字符串操作： SET/GET</li><li>哈希类型操作：HMSET/ HGETALL/ HSET</li><li>列表（链表）：LPUSH/ RPUSH/ LPOP/ RPOP/ LRANGE</li><li>集合：SADD/ SMEMBERS</li><li>有序集合（ZSET）：ZADD/ ZRANGE</li><li><p>HyperLogLog（集合基数统计）:PFADD/ PFCOUNT/ PFMERGE</p></li><li><p>发布订阅</p><ul><li>发布订阅模式，两个客户端之间通过SUBSCRIBE/ PULISH交换消息</li><li>命令：PUBLISH/ SUBSCRIBE/ PUBSUB</li></ul></li><li><p>事务</p><ul><li>从开始到执行会进入以下步骤：开始事务—进入队列—执行事务</li><li>事务可以认为是一个批量执行的脚本，内部命令是原子的，但事务本身并非原子。中间的命令失败不会导致其之前命令回滚，也不会导致其之后命令放弃执行</li><li>命令：<ul><li>MULTI（标记事务开始）</li><li>EXEC（开始执行事务）</li><li>DISCARD（放弃执行事务块）</li></ul></li></ul></li><li><p>脚本：EVAL script numkeys key [key …] arg [arg …]</p></li><li>备份与恢复<ul><li>备份：<code>SAVE</code>命令存储数据到dump.rdb，<code>CONFIG GET dir</code>查看rdb文件存储位置，将文件备份</li><li>恢复：只需将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可</li></ul></li><li>性能测试：<code>redis-benchmark -n 10000  -q</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;Redis知识点汇总&quot;&gt;&lt;a href=&quot;#Redis知识点汇总&quot; class=&quot;headerlink&quot; title=&quot;Redis知识点汇总&quot;&gt;&lt;/a&gt;Redis知
      
    
    </summary>
    
    
      <category term="技术" scheme="https://thomstrong.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Memcached 知识点</title>
    <link href="https://thomstrong.github.io/2019/06/20/Memcached/"/>
    <id>https://thomstrong.github.io/2019/06/20/Memcached/</id>
    <published>2019-06-20T07:30:29.000Z</published>
    <updated>2019-07-03T07:33:05.584Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Memcached知识点"><a href="#Memcached知识点" class="headerlink" title="Memcached知识点"></a>Memcached知识点</h1><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Memcached是一个免费开源的，高性能的，具有分布式对象的缓存系统，它可以用来保存一些经常存取的对象或数据，保存的数据像一张巨大的<strong>HASH表</strong>，该表以Key-value对的方式存在<strong>内存</strong>中。</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ul><li><p>检查客户端请求是否在memcached中</p></li><li><p>若有则直接返回</p></li><li><p>若无则从数据库查询后返回，并存储到memcached中</p></li><li><p>数据库更新需要同时更新memcached，保证一致性</p></li><li><p>memcached内存用完后会使用LRU策略加上到期失效策略，首先替换到期失效数据，之后替换最近未使用过的数据</p><blockquote><p>缓存置换算法（页面置换算法）FIFO/ LFU/ LRU</p><ol><li>FIFO 先进先出，最先进入缓存的最先替换掉</li><li>LFU 最近最少使用，替换掉最近一段时间使用次数最少的数据</li><li>LRU 最近最久未使用使用，替换掉最近一段时间没使用过的，以最近一次使用时间为基准，替换最远的数据空间</li></ol></blockquote></li></ul><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul><li><p>协议简单：基于文本行的协议，直接通过telnet在memcached服务器上可进行存取数据操作</p><blockquote><p>Telnet 远程连接服务，作用于tcp/ip协议的应用层</p></blockquote></li><li><p>基于libevent事件处理：libevent是一套利用C开发的程序库，由事件驱动，跨平台，支持并发编程</p></li><li>内置的内存管理方式：所有数据存于内存，LRU算法替换，数据易失</li><li>分布式：分布式取决于memcache客户端，memcached服务器之间互不通信，数据独立存储</li></ul><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><blockquote><p>服务启动方法<code>/usr/local/memcached/bin/memcached –p 11211 –d –u root –P /tmp/memcached.pid</code></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">telnet 127.0.0.1 11211 # 远程连接memcached</span><br><span class="line">stats items # 获取所有items的序号，例如items:29:hits_to_warm</span><br><span class="line">stats cachedump 29 0 # 获取编号29的item的key，返回如:1:/api/courses/tags/?；0表示返回所有slab中的item；若指定返回1个则使用stats cachedump 29 1</span><br><span class="line"></span><br><span class="line">get :1:/api/courses/tags/? # 获取key对应的值，多个键空格分割</span><br><span class="line"></span><br><span class="line">set cai 0 900 9 # 设置/更新key为cai的值为caicaicai，过期时间为900ms，以下输入的数据占9字节</span><br><span class="line">caicaicai # 存储成功返回STORED，失败返回ERROR</span><br><span class="line"></span><br><span class="line">add cai 0 900 9 # 设置key为cai的值为caicaicai，过期时间为900ms，以下输入的数据占9字节</span><br><span class="line">caicaicai # 存储成功返回STORED，失败或key存在返回NOT_STORED</span><br><span class="line"></span><br><span class="line"><span class="meta"> #</span><span class="bash"> replace 用于直接替换</span></span><br><span class="line"><span class="meta"> #</span><span class="bash"> append 用于直接在key对应的数据后面追加数据</span></span><br><span class="line"><span class="meta"> #</span><span class="bash"> prepend 用于直接在key对应的数据前面追加数据</span></span><br><span class="line"> cas cai 0 900 3 14 # 14为gets获取到的token，CAS 通过先检查token后再设置/更新值，避免数据不一致</span><br><span class="line"> aaa # 成功返回STORED；保存错误/语法错误返回ERROR；EXISTS说明token过期/不合法；NOT_FOUND该key不存在</span><br><span class="line"></span><br><span class="line"> gets cai # 返回带有token的value</span><br><span class="line"></span><br><span class="line">incr key increment_value # 自增key对应的value，必须是32位无符号整数</span><br><span class="line">decr key increment_value # 自减key对应的value，必须是32位无符号整数</span><br><span class="line"></span><br><span class="line">stats # 输出统计信息</span><br></pre></td></tr></table></figure><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ul><li>内存分配：Slab allocation机制分配和管理，先按照预定的大小，将分配的内存分割成特定长度的内存块chunck，然后再把相同的内存块分成组slab，根据值的大小去匹配slab大小，找就近的slab存放</li><li>缓存策略：失效策略 + LRU；不会监控存入的key/value是否过期，而是获取key时去查看记录的时间戳，检查key/value是否过期</li><li>分布式算法：memcached本身不存在分布式，而是客户端进行分布式选择memcached服务器进行分布式存储，因此只考虑服务器选择算法<ul><li>余数算法：求得key的整数散列值，然后根据服务器台数求的余数进行服务器选择；但是服务器的增减都会导致缓存失效</li><li>散列算法：首先将服务器散列值映射到0～2^32^编号的圆上，然后找到从key的散列值开始的第一个圆点作为目标服务器；当从中间插入服务器时，只有第一个服务器逆时针算的第一个服务器会受影响；减少服务器时，只有所减少服务器的逆时针方向第一个服务器之间的数据会受影响</li></ul></li></ul><h3 id="可视化工具"><a href="#可视化工具" class="headerlink" title="可视化工具"></a>可视化工具</h3><p><a href="https://github.com/junstor/memadmin" target="_blank" rel="noopener">Memadmin</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;Memcached知识点&quot;&gt;&lt;a href=&quot;#Memcached知识点&quot; class=&quot;headerlink&quot; title=&quot;Memcached知识点&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="技术" scheme="https://thomstrong.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>数智教育数据可视化创新大赛总结</title>
    <link href="https://thomstrong.github.io/2019/06/20/Tianchi-DataAnalysis/"/>
    <id>https://thomstrong.github.io/2019/06/20/Tianchi-DataAnalysis/</id>
    <published>2019-06-20T03:34:19.000Z</published>
    <updated>2019-07-03T07:29:26.151Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="数智教育数据可视化创新大赛总结"><a href="#数智教育数据可视化创新大赛总结" class="headerlink" title="数智教育数据可视化创新大赛总结"></a>数智教育数据可视化创新大赛总结</h1><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><blockquote><p>使用Django Rest Framework中规中矩的api，memcached简单配置</p></blockquote><ul><li><p>环境搭建</p><ul><li>使用virtualenv创建虚拟环境，防止环境污染</li><li>pip install 可以使用国内镜像源，pip install -i <a href="http://xxx.com/yyy/" target="_blank" rel="noopener">http://xxx.com/yyy/</a><ul><li>阿里云 <a href="http://mirrors.aliyun.com/pypi/simple/" target="_blank" rel="noopener">http://mirrors.aliyun.com/pypi/simple/</a></li><li>中国科技大学 <a href="https://pypi.mirrors.ustc.edu.cn/simple/" target="_blank" rel="noopener">https://pypi.mirrors.ustc.edu.cn/simple/</a></li><li>豆瓣(douban) <a href="http://pypi.douban.com/simple/" target="_blank" rel="noopener">http://pypi.douban.com/simple/</a></li><li>清华大学 <a href="https://pypi.tuna.tsinghua.edu.cn/simple/" target="_blank" rel="noopener">https://pypi.tuna.tsinghua.edu.cn/simple/</a></li><li>中国科学技术大学 <a href="http://pypi.mirrors.ustc.edu.cn/simple/" target="_blank" rel="noopener">http://pypi.mirrors.ustc.edu.cn/simple/</a></li></ul></li></ul></li><li><p>数据库配置</p><ul><li><p>考虑数据整体不会有太大变动，可能需要从本地开发环境直接迁移到线上服务器，所以使用docker搭载postgres的方法，上线后可直接将docker镜像进行恢复然后迁移数据</p></li><li><p>docker 镜像备份方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. docker save [container_name] &gt; bak.tar <span class="comment"># save as tar</span></span><br><span class="line">2. docker load -i ./bak.tar <span class="comment"># 恢复container</span></span><br><span class="line">3. 进入postgre创建database然后执行如下</span><br><span class="line">4. cat your_dump.sql | docker <span class="built_in">exec</span> -i your-db-container psql -U tianchiuser tianchidb</span><br></pre></td></tr></table></figure></li></ul></li><li><p>数据迁移</p><ul><li><p>使用runpython在migration中运行自定义脚本</p><ul><li>编写<code>def fun(apps, schema_editor)</code>函数，通过<code>apps.get_model()</code>获取数据模型</li><li>在operations中加入 <code>migrations.RunPython(fun, reverse_code=migrations.RunPython.noop)</code></li><li><code>reverse_code=migrations.RunPython.noop</code>使用reverse_code去定义回滚时使用的方法，此处会忽略runpython产生的任何修改，直接回滚</li></ul></li><li><p>回滚migration <a href="https://simpleisbetterthancomplex.com/tutorial/2016/07/26/how-to-reset-migrations.html" target="_blank" rel="noopener">参考链接</a></p><ul><li><code>python manage.py migrate [app_name] [migration_name]</code>将某个app的migrations回滚到某个migration文件为止</li><li>合并migration树<ol><li>./manage.py migrate —fake [app_name] zero 回滚全部migrate，但是保留数据</li><li>删除所有migration文件</li><li>./manage.py makemigrations 重新生成migration文件</li><li>./manage.py migrate —fake-initial 重新应用合并的migration 文件</li></ol></li><li><code>python manage.py showmigrations</code>可以查看当前已应用的migration</li></ul></li><li><p>Postgres 中创建用户</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">psql</span><br><span class="line">postgres<span class="comment"># CREATE USER xxxx1 WITH PASSWORD 'xxxx';</span></span><br><span class="line">postgres<span class="comment"># CREATE DATABASE xxxx2;</span></span><br><span class="line">postgres<span class="comment"># GRANT ALL PRIVILEGES ON DATABASE xxxx2 to xxxx1;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>缓存配置(memcached) <a href="http://chibisov.github.io/drf-extensions/docs/#cache-response" target="_blank" rel="noopener">参考文档</a></p><ul><li><p>settings配置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">CACHES = &#123;</span><br><span class="line">    <span class="string">'default'</span>: &#123;</span><br><span class="line">        <span class="string">'BACKEND'</span>: <span class="string">'django.core.cache.backends.memcached.MemcachedCache'</span>,</span><br><span class="line">        <span class="string">'LOCATION'</span>: <span class="string">'127.0.0.1:11211'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">INSTALLED_APPS = [</span><br><span class="line">    ...,</span><br><span class="line">    <span class="string">'django_extensions'</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">REST_FRAMEWORK_EXTENSIONS = &#123;</span><br><span class="line">    <span class="string">'DEFAULT_CACHE_KEY_FUNC'</span>: <span class="string">'utils.cache_funcs.calculate_cache_key'</span></span><br><span class="line">&#125; <span class="comment"># 使用自定义的calculate_cache_key函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过请求的url进行缓存</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_cache_key</span><span class="params">(view_instance, view_method,</span></span></span><br><span class="line"><span class="function"><span class="params">                        request, args, kwargs)</span>:</span></span><br><span class="line">    url = <span class="string">'&#123;&#125;?'</span>.format(request.path)</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> request.query_params:</span><br><span class="line">        url += <span class="string">'&#123;&#125;=&#123;&#125;&amp;'</span>.format(key, request.query_params[key])</span><br><span class="line">    <span class="keyword">return</span> url</span><br></pre></td></tr></table></figure></li><li><p>使用rest_framework_extensions提供的<code>@cache_response([x seconds]])</code>装饰器进行view的缓存</p></li></ul></li></ul><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><blockquote><p>使用 Ant Design Pro脚手架，Umi &amp; Dva</p></blockquote><ul><li><p>Umi 要点</p><ul><li>umi 里约定 mock 文件夹下的文件或者 page(s) 文件夹下的 _mock 文件即 mock 文件</li><li>对于整个系统来说，请求接口是复杂并且繁多的，为了处理大量模拟请求的场景，我们通常把每一个数据模型抽象成一个文件，统一放在 <code>mock</code> 的文件夹中，然后他们会自动被引入。</li><li>当本地开发完毕之后，修改config.js中的proxy配置</li><li>umi with dva<ul><li>按目录约定注册 model，无需手动 <code>app.model</code></li><li>文件名即 namespace，可以省去 <code>model</code> 导出的 <code>namespace</code> key</li><li>无需手写 <code>router.js</code>，交给 umi 处理，支持 <code>model</code> 和 <code>component</code> 的按需加载</li><li>内置 query-string 处理，无需再手动解码和编码</li><li>内置 dva-loading 和 dva-immer，其中 dva-immer 需通过配置开启</li><li>开箱即用，无需安装额外依赖，比如 dva、dva-loading、dva-immer、path-to-regexp、object-assign、react、react-dom 等</li></ul></li></ul></li><li><p>Dva</p><ul><li><p>State：一个对象，保存整个应用状态</p></li><li><p>View：React 组件构成的视图层</p></li><li><p>Action：一个对象，描述事件</p></li><li><p>connect 方法：一个函数，绑定 State 到 View，用于建立state 和 props的映射</p></li><li><p>dispatch 方法：一个函数，发送 Action 到 State，被 connect 的 Component 会自动在 props 中拥有 dispatch 方法。</p></li><li><p>model 对象属性</p><ul><li><p>namespace: 当前 Model 的名称。整个应用的 State，由多个小的 Model 的 State 以 namespace 为 key 合成</p></li><li><p>state: 该 Model 当前的状态。数据保存在这里，直接决定了视图层的输出</p></li><li><p>reducers: Action 处理器，处理同步动作，用来算出最新的 State</p></li><li><p>effects：Action 处理器，处理异步动</p><ul><li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">addAfter1Second</span>(<span class="params">action, &#123; put, call &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> call(delay, <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: <span class="string">'add'</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Effect 是一个 Generator 函数，内部使用 yield 关键字，标识每一步的操作（不管是异步或同步）。</p></li><li><p>call：执行异步函数</p></li><li><p>put：发出一个 Action，类似于 dispatch</p></li></ul></li></ul></li></ul></li><li><p>DOM 和 BOM</p><ul><li><p>window对象对应着浏览器窗口本身，这个对象的属性和方法通常被称为BOM</p></li><li><p>D（文档）可以理解为整个Web加载的网页文档，O（对象）可以理解为类似window对象只来的东西，可以调用属性和方法，这里我们说的是document对象，M（模型）可以理解为网页文档的树形结构，DOM树由节点构成</p></li><li><p>Window对象包含属性：document、location、navigator、screen、history、frames</p><p>Document根节点包含子节点：forms、location、anchors、images、links</p></li><li><p>BOM的核心是window，而window对象又具有双重角色，它既是通过js访问浏览器窗口的一个接口，又是一个Global（全局）对象</p></li><li><p>document对象：实际上是window对象的属性，document == window.document为true，是唯一一个既属于BOM又属于DOM的对象</p></li></ul></li><li><p>Suspense 相关 <a href="https://zhuanlan.zhihu.com/p/58979795" target="_blank" rel="noopener">参考文章</a></p><ul><li><p>懒加载<code>const ScoreLineChart = React.lazy(() =&gt; import(&#39;./ScoreLineChart&#39;));</code></p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;/div&gt;&#125;&gt;</span><br><span class="line">    &lt;ScoreLineChart /&gt;</span><br><span class="line">&lt;/Suspense&gt;</span><br></pre></td></tr></table></figure></li><li><p>使用懒加载的组件必须放入suspense中</p></li><li><p>未使用懒加载的组件不能放入suspense中，否则可能导致所挂载的dom没有渲染出来而导致报错</p></li></ul></li><li><p><code>constructor.name</code>不要用于做为判断的条件，因为webpack后会翻译为其他名字</p></li></ul><h3 id="部署-webpack"><a href="#部署-webpack" class="headerlink" title="部署 webpack"></a>部署 <a href="https://webpack.js.org/" target="_blank" rel="noopener">webpack</a></h3><blockquote><p>Umi build + nginx + docker实现</p></blockquote><ul><li><p>基于docker的打包和发布真的是很方便的，虽然在项目中使用的深度还不是很深，仅用了一些皮毛</p></li><li><p>webpack 打包时可用hush防止缓存不刷新带来的报错 <a href="https://www.cnblogs.com/ihardcoder/p/5623411.html" target="_blank" rel="noopener">参考链接</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].bundle.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>cdn 加速还是很有用的 <a href="https://unpkg.com/" target="_blank" rel="noopener">免费cdn加速</a></p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>官方文档要仔细阅读</li><li>不要重复造轮子</li><li><p>皮毛只能解决问题，但不能理解问题</p></li><li><p>代码规范还是要注重一下..虽然本次比赛比较赶没有任何规范</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;数智教育数据可视化创新大赛总结&quot;&gt;&lt;a href=&quot;#数智教育数据可视化创新大赛总结&quot; class=&quot;headerlink&quot; title=&quot;数智教育数据可视化创新大
      
    
    </summary>
    
    
      <category term="比赛" scheme="https://thomstrong.github.io/tags/%E6%AF%94%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>2019 Byte Camp-工程赛道面试经历</title>
    <link href="https://thomstrong.github.io/2019/06/17/2019-Byte-Camp/"/>
    <id>https://thomstrong.github.io/2019/06/17/2019-Byte-Camp/</id>
    <published>2019-06-17T07:25:59.000Z</published>
    <updated>2019-07-03T07:29:20.683Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="2019-Byte-Camp-工程赛道面试经历"><a href="#2019-Byte-Camp-工程赛道面试经历" class="headerlink" title="2019 Byte Camp-工程赛道面试经历"></a>2019 Byte Camp-工程赛道面试经历</h1><blockquote><p>面试官 30-40岁，主要从事后端</p></blockquote><ol><li><p>自我介绍</p></li><li><p>通过介绍中提及实习经历/实践经历提问</p><ul><li><p>线上实习如何分配时间</p></li><li><p>xx实习中使用的技术栈是什么？为什么用postgres？</p></li><li><p>React 是什么？大体介绍一下</p></li><li><p>你对rest api的认识</p><blockquote><p>针对资源</p><p>使用get/post/put/delete方法</p></blockquote></li><li><p>python 的装饰器是什么</p><blockquote><p>在不改变原函数功能的情况下增加额外功能</p></blockquote></li><li><p>数据库中group by 是什么（只回答了使用方法，原理未提及，需要重新理解）</p><blockquote><p>原理：使用松散索引/紧凑索引/临时表的方法在排序后分组</p></blockquote></li></ul></li><li><p>基础知识问答</p><ul><li><p>Linux进程相关，进程存储空间的分类，进程状态分类</p><blockquote><p>三状态模型：</p><ul><li>就绪ready：获得了处理机以外的所有资源，一旦得到处理机即可运行</li><li>运行running：进程在处理机上运行时</li><li>阻塞waiting：等待或者睡眠状态，等待某一事件发生中</li></ul></blockquote></li><li><p>tcp 三次握手过程，第一次握手发送报文名称，哪些flag置位<a href="https://blog.csdn.net/qq_33982721/article/details/78493967" target="_blank" rel="noopener">参考博客</a></p><blockquote><p>三次握手：避免失效请求报文错误建立了连接，导致server一直等待，浪费资源</p><ul><li>客户端syn seq=x</li><li>服务器 syn seq=y, ack=x+1</li><li>客户端ack=y+1</li></ul><p>四次挥手：tcp全双工模式，需要确定双方均无数据发送才可断开连接</p><ul><li>主机1 fin seq=x ack=y，x-1是主机1前面发送的最后一个字节的序号</li><li>主机2 ack=x+1</li><li>主机2 fin seq=y，y-1是主机2前面发送的最后一个字节序号</li><li>主机1 ack=y+1</li></ul><p>ack序号含义：希望收到第x个字节开始的报文段，且成功收到了前面x-1个报文</p></blockquote></li><li><p>二叉树，什么是完全二叉树，如何判别完全二叉树，设计算法</p><blockquote><p>可以使用栈的方式，按层遍历；如果本层存在有左无右的情况，那么下次遍历必须都是叶子结点；如果存在有右无左的情况，直接false</p></blockquote></li></ul></li><li><p>算法题</p><blockquote><p>给一个升序数组，判断这个数组每个元素平方后不同数字的个数</p></blockquote><ul><li>平方数没用，直接判断绝对值</li><li>使用头尾指针的方式向中间收缩</li><li>需考虑数组中连续相同数的情况</li></ul></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>基础知识复习完全不充分</li><li>描述自己见解时语言不清晰</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;2019-Byte-Camp-工程赛道面试经历&quot;&gt;&lt;a href=&quot;#2019-Byte-Camp-工程赛道面试经历&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
    
      <category term="面经" scheme="https://thomstrong.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
</feed>
